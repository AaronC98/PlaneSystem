<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>SPARK 2005 to SPARK 2014 Mapping Specification &#8212; SPARK 2014 Reference Manual 2019</title>
    
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2019',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="GNU Free Documentation License" href="gfdl.html" />
    <link rel="prev" title="17. Glossary" href="glossary.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="gfdl.html" title="GNU Free Documentation License"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="glossary.html" title="17. Glossary"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">SPARK 2014 Reference Manual 2019</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">SPARK 2005 to SPARK 2014 Mapping Specification</a><ul>
<li><a class="reference internal" href="#spark-2005-features-and-spark-alternatives">SPARK 2005 Features and SPARK 2014 Alternatives</a></li>
<li><a class="reference internal" href="#subprogram-patterns">Subprogram patterns</a><ul>
<li><a class="reference internal" href="#global-and-derives">Global and Derives</a></li>
<li><a class="reference internal" href="#pre-post-return-contracts">Pre/Post/Return contracts</a></li>
<li><a class="reference internal" href="#attributes-of-unconstrained-out-parameter-in-precondition">Attributes of unconstrained out parameter in precondition</a></li>
<li><a class="reference internal" href="#data-abstraction-refinement-and-initialization">Data Abstraction, Refinement and Initialization</a></li>
</ul>
</li>
<li><a class="reference internal" href="#package-patterns">Package patterns</a><ul>
<li><a class="reference internal" href="#abstract-data-types-adts">Abstract Data Types (ADTs)</a><ul>
<li><a class="reference internal" href="#visible-type">Visible type</a></li>
<li><a class="reference internal" href="#private-type">Private type</a></li>
<li><a class="reference internal" href="#private-type-with-pre-post-contracts">Private type with pre/post contracts</a></li>
<li><a class="reference internal" href="#private-public-child-visibility">Private/Public child visibility</a></li>
</ul>
</li>
<li><a class="reference internal" href="#abstract-state-machines-asms">Abstract State Machines (ASMs)</a><ul>
<li><a class="reference internal" href="#visible-concrete-state">Visible, concrete state</a><ul>
<li><a class="reference internal" href="#initialized-by-declaration">Initialized by declaration</a></li>
<li><a class="reference internal" href="#initialized-by-elaboration">Initialized by elaboration</a></li>
</ul>
</li>
<li><a class="reference internal" href="#private-concrete-state">Private, concrete state</a></li>
<li><a class="reference internal" href="#private-abstract-state-refining-onto-concrete-states-in-body">Private, abstract state, refining onto concrete states in body</a><ul>
<li><a class="reference internal" href="#initialized-by-procedure-call">Initialized by procedure call</a></li>
<li><a class="reference internal" href="#initialized-by-elaboration-of-declaration">Initialized by elaboration of declaration</a></li>
<li><a class="reference internal" href="#initialized-by-package-body-statements">Initialized by package body statements</a></li>
<li><a class="reference internal" href="#initialized-by-mixture-of-declaration-and-statements">Initialized by mixture of declaration and statements</a></li>
</ul>
</li>
<li><a class="reference internal" href="#initial-condition">Initial condition</a></li>
<li><a class="reference internal" href="#private-abstract-state-refining-onto-state-of-private-child">Private, abstract state, refining onto state of private child</a></li>
<li><a class="reference internal" href="#private-abstract-state-refining-onto-concrete-state-of-embedded-package">Private, abstract state, refining onto concrete state of embedded package</a></li>
<li><a class="reference internal" href="#private-abstract-state-refining-onto-mixture-of-the-above">Private, abstract state, refining onto mixture of the above</a></li>
</ul>
</li>
<li><a class="reference internal" href="#external-variables">External Variables</a><ul>
<li><a class="reference internal" href="#basic-input-and-output-device-drivers">Basic Input and Output Device Drivers</a></li>
<li><a class="reference internal" href="#input-driver-using-tail-in-a-contract">Input driver using &#8216;Tail in a contract</a></li>
<li><a class="reference internal" href="#output-driver-using-append-in-a-contract">Output driver using &#8216;Append in a contract</a></li>
<li><a class="reference internal" href="#refinement-of-external-state-voting-input-switch">Refinement of external state - voting input switch</a></li>
<li><a class="reference internal" href="#complex-i-o-device">Complex I/O Device</a></li>
<li><a class="reference internal" href="#increasing-values-in-input-stream">Increasing values in input stream</a></li>
</ul>
</li>
<li><a class="reference internal" href="#package-inheritance">Package Inheritance</a><ul>
<li><a class="reference internal" href="#contracts-with-remote-state">Contracts with remote state</a></li>
<li><a class="reference internal" href="#package-nested-inside-package">Package nested inside package</a></li>
<li><a class="reference internal" href="#package-nested-inside-subprogram">Package nested inside subprogram</a></li>
<li><a class="reference internal" href="#circular-dependence-and-elaboration-order">Circular dependence and elaboration order</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#bodies-and-proof">Bodies and Proof</a><ul>
<li><a class="reference internal" href="#assert-assume-check-contracts">Assert, Assume, Check contracts</a><ul>
<li><a class="reference internal" href="#assert-in-loop-contract">Assert (in loop) contract</a></li>
<li><a class="reference internal" href="#assert-no-loop-contract">Assert (no loop) contract</a></li>
<li><a class="reference internal" href="#assume-contract">Assume contract</a></li>
<li><a class="reference internal" href="#check-contract">Check contract</a></li>
</ul>
</li>
<li><a class="reference internal" href="#assert-used-to-control-path-explosion">Assert used to control path explosion</a></li>
</ul>
</li>
<li><a class="reference internal" href="#other-contracts-and-annotations">Other Contracts and Annotations</a><ul>
<li><a class="reference internal" href="#always-valid-assertion">Always_Valid assertion</a></li>
<li><a class="reference internal" href="#rule-declaration-annotation">Rule declaration annotation</a></li>
<li><a class="reference internal" href="#proof-types-and-proof-functions">Proof types and proof functions</a></li>
<li><a class="reference internal" href="#using-an-external-prover">Using an External Prover</a></li>
<li><a class="reference internal" href="#quoting-an-own-variable-in-a-contract">Quoting an Own Variable in a Contract</a></li>
<li><a class="reference internal" href="#main-program-annotation">Main_Program annotation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#update-expressions">Update Expressions</a></li>
<li><a class="reference internal" href="#value-of-variable-on-entry-to-a-loop">Value of Variable on Entry to a Loop</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="glossary.html"
                        title="previous chapter">17. Glossary</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="gfdl.html"
                        title="next chapter">GNU Free Documentation License</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/mapping-spec.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="spark-2005-to-spark-2014-mapping-specification">
<span id="mapping-spec-label"></span><h1>SPARK 2005 to SPARK 2014 Mapping Specification<a class="headerlink" href="#spark-2005-to-spark-2014-mapping-specification" title="Permalink to this headline">¶</a></h1>
<p>This appendix defines the mapping between SPARK 2005 and SPARK 2014.
It is intended as both a completeness check for the SPARK 2014 language
design, and as a guide for projects upgrading from SPARK 2005 to SPARK 2014.</p>
<div class="section" id="spark-2005-features-and-spark-alternatives">
<h2>SPARK 2005 Features and SPARK 2014 Alternatives<a class="headerlink" href="#spark-2005-features-and-spark-alternatives" title="Permalink to this headline">¶</a></h2>
<p>Nearly every SPARK 2005 feature has a SPARK 2014 equivalent or there is
an alternative way of providing the same feature in SPARK 2014.  The only
SPARK 2005 (not including RavenSPARK) features that do not have a direct
alternative are:</p>
<blockquote>
<div><ul class="simple">
<li>the &#8216;Always_Valid attribute;</li>
<li>the ability to add pre and postconditions to an instantiation of a
generic subprogram, e.g., Unchecked_Conversion; and</li>
<li>a precondition on the body of a subprogram refining the one on the
specification - this is not usually required in SPARK 2014, it is
normally replaced by the use of expression functions.</li>
</ul>
</div></blockquote>
<p>At the moment the first two features have to be accomplished using
pragma Assume.</p>
<p>The following subsections of this appendix demonstrate how many SPARK
2005 idioms map into SPARK 2014.  As a quick reference the table below
shows, for each SPARK 2005 annotation or SPARK 2005 specific feature,
a reference to the equivalent or alternative in SPARK 2014.  In the table
headings 2014 RM is the SPARK 2014 Reference Manual and Mapping is this
appendix, the SPARK 2005 to SPARK 2014 mapping specification.</p>
<table border="1" class="docutils">
<colgroup>
<col width="9%" />
<col width="22%" />
<col width="26%" />
<col width="44%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">SPARK 2005</th>
<th class="head">SPARK 2014</th>
<th class="head">2014 RM</th>
<th class="head">Mapping</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>~ in post</td>
<td>&#8216;Old attribute   - see Ada RM 6.1.1</td>
<td>&nbsp;</td>
<td><a class="reference internal" href="#ms-pre-post-return-label"><span class="std std-ref">A.2.2</span></a></td>
</tr>
<tr class="row-odd"><td>~ in body</td>
<td>&#8216;Loop_Entry attribute</td>
<td><a class="reference internal" href="statements.html#loop-entry"><span class="std std-ref">5.5.3</span></a></td>
<td><a class="reference internal" href="#ms-value-of-variable-on-entry-to-a-loop-label"><span class="std std-ref">A.7</span></a></td>
</tr>
<tr class="row-even"><td>&lt;-&gt;</td>
<td>=</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>A -&gt; B</td>
<td>(if A then B)     - see Ada RM 4.5.7</td>
<td>&nbsp;</td>
<td><a class="reference internal" href="#ms-pre-post-return-label"><span class="std std-ref">A.2.2</span></a></td>
</tr>
<tr class="row-even"><td>%</td>
<td>not needed</td>
<td>&nbsp;</td>
<td><a class="reference internal" href="#ms-value-of-variable-on-entry-to-a-loop-label"><span class="std std-ref">A.7</span></a></td>
</tr>
<tr class="row-odd"><td>always_valid</td>
<td>not supported</td>
<td>&nbsp;</td>
<td><a class="reference internal" href="#ms-proof-assume-contract-label"><span class="std std-ref">A.4.1</span></a></td>
</tr>
<tr class="row-even"><td>assert</td>
<td>pragma Assert_And_Cut</td>
<td><a class="reference internal" href="statements.html#pragma-assume"><span class="std std-ref">5.9</span></a></td>
<td><a class="reference internal" href="#ms-assert-no-loop-contract-label"><span class="std std-ref">A.4.2</span></a></td>
</tr>
<tr class="row-odd"><td>assert in loop</td>
<td>pragma Loop_Invariant</td>
<td><a class="reference internal" href="statements.html#loop-invariants"><span class="std std-ref">5.5.3</span></a></td>
<td><a class="reference internal" href="#ms-assert-loop-contract-label"><span class="std std-ref">A.4.1</span></a></td>
</tr>
<tr class="row-even"><td>assume</td>
<td>pragma Assume</td>
<td><a class="reference internal" href="statements.html#pragma-assume"><span class="std std-ref">5.9</span></a></td>
<td><a class="reference internal" href="#ms-proof-assume-contract-label"><span class="std std-ref">A.4.1</span></a></td>
</tr>
<tr class="row-odd"><td>check</td>
<td>pragma Assert     - see Ada RM 11.4.2</td>
<td>&nbsp;</td>
<td><a class="reference internal" href="#ms-check-contract-label"><span class="std std-ref">A.4.1</span></a></td>
</tr>
<tr class="row-even"><td>derives on spec</td>
<td>Depends aspect</td>
<td><a class="reference internal" href="subprograms.html#depends-aspects"><span class="std std-ref">6.1.5</span></a></td>
<td><a class="reference internal" href="#ms-global-derives-label"><span class="std std-ref">A.2.1</span></a></td>
</tr>
<tr class="row-odd"><td>derives on body</td>
<td>No separate spec - Depends aspect</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>derives on body</td>
<td>Separate spec - Refined_Depends aspect</td>
<td><a class="reference internal" href="packages.html#refined-depends-aspect"><span class="std std-ref">7.2.5</span></a></td>
<td><a class="reference internal" href="#ms-asm-abstract-state-refined-in-private-child-label"><span class="std std-ref">A.3.2</span></a></td>
</tr>
<tr class="row-odd"><td>for all</td>
<td>quantified_expression - see Ada RM 4.5.8</td>
<td>&nbsp;</td>
<td><a class="reference internal" href="#ms-attributes-of-unconstrained-out-parameter-in-precondition-label"><span class="std std-ref">A.2.3</span></a></td>
</tr>
<tr class="row-even"><td>for some</td>
<td>quantified_expression - See Ada RM 4.5.8</td>
<td>&nbsp;</td>
<td><a class="reference internal" href="#ms-assert-loop-contract-label"><span class="std std-ref">A.4.1</span></a></td>
</tr>
<tr class="row-odd"><td>global on spec</td>
<td>Global aspect</td>
<td><a class="reference internal" href="subprograms.html#global-aspects"><span class="std std-ref">6.1.4</span></a></td>
<td><a class="reference internal" href="#ms-global-derives-label"><span class="std std-ref">A.2.1</span></a></td>
</tr>
<tr class="row-even"><td>global on body</td>
<td>No separate spec - Global aspect</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>global on body</td>
<td>Separate spec - Refined_Global aspect</td>
<td><a class="reference internal" href="packages.html#refined-global-aspect"><span class="std std-ref">7.2.4</span></a></td>
<td><a class="reference internal" href="#ms-nesting-refinement-label"><span class="std std-ref">A.2.4</span></a></td>
</tr>
<tr class="row-even"><td>hide</td>
<td>pragma SPARK_Mode - see User Guide</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>inherit</td>
<td>not needed</td>
<td>&nbsp;</td>
<td><a class="reference internal" href="#ms-package-inheritance-label"><span class="std std-ref">A.3.4</span></a></td>
</tr>
<tr class="row-even"><td>initializes</td>
<td>Initializes aspect</td>
<td><a class="reference internal" href="packages.html#initializes-aspect"><span class="std std-ref">7.1.5</span></a></td>
<td><a class="reference internal" href="#ms-nesting-refinement-label"><span class="std std-ref">A.2.4</span></a></td>
</tr>
<tr class="row-odd"><td>main_program</td>
<td>not needed</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>object assertions</td>
<td>rule declarations are not needed</td>
<td>&nbsp;</td>
<td><a class="reference internal" href="#ms-proof-types-and-proof-functions-label"><span class="std std-ref">A.5.3</span></a></td>
</tr>
<tr class="row-odd"><td>own on spec</td>
<td>Abstract_State aspect</td>
<td><a class="reference internal" href="packages.html#abstract-state-aspect"><span class="std std-ref">7.1.4</span></a></td>
<td><a class="reference internal" href="#ms-asm-label"><span class="std std-ref">A.3.2</span></a></td>
</tr>
<tr class="row-even"><td>own on body</td>
<td>Refined_State aspect</td>
<td><a class="reference internal" href="packages.html#refined-state-aspect"><span class="std std-ref">7.2.2</span></a></td>
<td><a class="reference internal" href="#ms-asm-label"><span class="std std-ref">A.3.2</span></a></td>
</tr>
<tr class="row-odd"><td>post on spec</td>
<td>postcondition     - see Ada RM 6.1.1</td>
<td><a class="reference internal" href="subprograms.html#preconditions-and-postconditions"><span class="std std-ref">6.1.1</span></a></td>
<td><a class="reference internal" href="#ms-pre-post-return-label"><span class="std std-ref">A.2.2</span></a></td>
</tr>
<tr class="row-even"><td>post on body</td>
<td>No separate spec - postcondition</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>post on body</td>
<td>Separate spec - Refined_Post aspect</td>
<td><a class="reference internal" href="packages.html#refined-postcondition"><span class="std std-ref">7.2.7</span></a></td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>pre</td>
<td>precondition      - see Ada RM 6.1.1</td>
<td><a class="reference internal" href="subprograms.html#preconditions-and-postconditions"><span class="std std-ref">6.1.1</span></a></td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>proof functions</td>
<td>Ghost functions</td>
<td><a class="reference internal" href="subprograms.html#ghost-functions"><span class="std std-ref">6.9</span></a></td>
<td><a class="reference internal" href="#ms-proof-types-and-proof-functions-label"><span class="std std-ref">A.5.3</span></a></td>
</tr>
<tr class="row-even"><td>proof types</td>
<td>Ada types</td>
<td>&nbsp;</td>
<td><a class="reference internal" href="#ms-quote-own-variable-in-contract-label"><span class="std std-ref">A.5.5</span></a></td>
</tr>
<tr class="row-odd"><td>return</td>
<td>&#8216;Result attribute - see Ada RM 6.1.1</td>
<td>&nbsp;</td>
<td><a class="reference internal" href="#ms-pre-post-return-label"><span class="std std-ref">A.2.2</span></a></td>
</tr>
<tr class="row-even"><td>update</td>
<td>&#8216;Update attribute</td>
<td><a class="reference internal" href="names-and-expressions.html#update-expressions"><span class="std std-ref">4.4.1</span></a></td>
<td><a class="reference internal" href="#ms-quote-own-variable-in-contract-label"><span class="std std-ref">A.6</span></a></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="subprogram-patterns">
<h2>Subprogram patterns<a class="headerlink" href="#subprogram-patterns" title="Permalink to this headline">¶</a></h2>
<div class="section" id="global-and-derives">
<span id="ms-global-derives-label"></span><h3>Global and Derives<a class="headerlink" href="#global-and-derives" title="Permalink to this headline">¶</a></h3>
<p>This example demonstrates how global variables can be accessed through
procedures/functions and presents how the SPARK 2005 <cite>derives</cite> annotation maps
over to <cite>depends</cite> in SPARK 2014. The example consists of one procedure (<cite>Swap</cite>) and
one function (<cite>Add</cite>). <cite>Swap</cite> accesses two global variables and swaps their contents
while <cite>Add</cite> returns their sum.</p>
<p>Specification in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Swap_Add_05</span>
<span class="c">--# own X, Y: Integer;</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Swap</span><span class="p">;</span>
   <span class="c">--# global in out X, Y;</span>
   <span class="c">--# derives X from Y &amp;</span>
   <span class="c">--#         Y from X;</span>

   <span class="k">function </span><span class="nf">Add</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>
   <span class="c">--# global in X, Y;</span>

<span class="k">end </span><span class="nf">Swap_Add_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>body in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Swap_Add_05</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Swap</span>
   <span class="kr">is</span><span class="p"></span>
      <span class="n">Temporary</span><span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Temporary</span> <span class="o">:=</span> <span class="n">X</span><span class="p">;</span>
      <span class="n">X</span>         <span class="o">:=</span> <span class="n">Y</span><span class="p">;</span>
      <span class="n">Y</span>         <span class="o">:=</span> <span class="n">Temporary</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Swap</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Add</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="kr">return</span><span class="p"> </span><span class="n">X</span> <span class="o">+</span> <span class="n">Y</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Add</span><span class="p">;</span>

<span class="k">end </span><span class="nf">Swap_Add_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specification in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Swap_Add_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span>
<span class="kr">is</span><span class="p"></span>
   <span class="c">-- Visible variables are not state abstractions.</span>
   <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Swap</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="o">))</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">X</span> <span class="o">=&gt;</span> <span class="n">Y</span><span class="p">,</span>   <span class="c">-- to be read as &quot;X depends on Y&quot;</span>
                      <span class="n">Y</span> <span class="o">=&gt;</span> <span class="n">X</span><span class="o">)</span><span class="p">;</span>  <span class="c">-- to be read as &quot;Y depends on X&quot;</span>

   <span class="k">function </span><span class="nf">Add</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="o">))</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Swap_Add_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Swap_Add_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Swap</span> <span class="kr">is</span><span class="p"></span>
      <span class="n">Temporary</span><span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Temporary</span> <span class="o">:=</span> <span class="n">X</span><span class="p">;</span>
      <span class="n">X</span>         <span class="o">:=</span> <span class="n">Y</span><span class="p">;</span>
      <span class="n">Y</span>         <span class="o">:=</span> <span class="n">Temporary</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Swap</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Add</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">X</span> <span class="o">+</span> <span class="n">Y</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Swap_Add_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="pre-post-return-contracts">
<span id="ms-pre-post-return-label"></span><h3>Pre/Post/Return contracts<a class="headerlink" href="#pre-post-return-contracts" title="Permalink to this headline">¶</a></h3>
<p>This example demonstrates how the <cite>Pre</cite>/<cite>Post</cite>/<cite>Return</cite> contracts are
restructured and how they map from SPARK 2005 to SPARK 2014. Procedure
<cite>Swap</cite> and function <cite>Add</cite> perform the same task as in the previous
example, but the global variables have been replaced by parameters
(this is not necessarry for proof) and they have been augmented by pre
and post annotations. Two additional functions (<cite>Max</cite> and <cite>Divide</cite>)
and one additional procedure (<cite>Swap_Array_Elements</cite>) have also been
included in this example in order to demonstrate further
features. <cite>Max</cite> returns the maximum of the two parameters. <cite>Divide</cite>
returns the division of the two parameters after having ensured that the
divisor is not equal to zero. The <cite>Swap_Array_Elements</cite> procedure
swaps the contents of two elements of an array.</p>
<p>Specification in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Swap_Add_Max_05</span> <span class="kr">is</span><span class="p"></span>

   <span class="kr">subtype</span><span class="p"> </span><span class="n">Index</span>      <span class="kr">is</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">range</span><span class="p"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Array_Type</span> <span class="kr">is</span><span class="p"> </span><span class="kr">array</span><span class="p"> </span><span class="o">(</span><span class="n">Index</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Swap</span> <span class="o">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--# post X = Y~ and Y = X~;</span>

   <span class="k">function </span><span class="nf">Add</span> <span class="o">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>
   <span class="c">--# pre ((X &gt;= 0 and Y &gt;= 0) -&gt; (X + Y &lt;= Integer&#39;Last)) and</span>
   <span class="c">--#     ((X &lt;  0 and Y &lt;  0) -&gt; (X + Y &gt;= Integer&#39;First));</span>
   <span class="c">--# return X + Y;</span>

   <span class="k">function </span><span class="nf">Max</span> <span class="o">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>
   <span class="c">--# return Z =&gt; (X &gt;= Y -&gt; Z = X) and</span>
   <span class="c">--#             (Y &gt;  X -&gt; Z = Y);</span>

   <span class="k">function </span><span class="nf">Divide</span> <span class="o">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>
   <span class="c">--# pre Y /= 0 and X &gt; Integer&#39;First;</span>
   <span class="c">--# return X / Y;</span>

   <span class="k">procedure </span><span class="nf">Swap_Array_Elements</span><span class="o">(</span><span class="n">I</span><span class="p">,</span> <span class="n">J</span> <span class="o">:</span> <span class="n">Index</span><span class="p">;</span> <span class="n">A</span><span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Array_Type</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--# post A = A~[I =&gt; A~(J); J =&gt; A~(I)];</span>

<span class="k">end </span><span class="nf">Swap_Add_Max_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Swap_Add_Max_05</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Swap</span> <span class="o">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
      <span class="n">Temporary</span><span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Temporary</span> <span class="o">:=</span> <span class="n">X</span><span class="p">;</span>
      <span class="n">X</span>         <span class="o">:=</span> <span class="n">Y</span><span class="p">;</span>
      <span class="n">Y</span>         <span class="o">:=</span> <span class="n">Temporary</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Swap</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Add</span> <span class="o">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="kr">return</span><span class="p"> </span><span class="n">X</span> <span class="o">+</span> <span class="n">Y</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Add</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Max</span> <span class="o">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span>
   <span class="kr">is</span><span class="p"></span>
      <span class="n">Result</span><span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="kr">if</span><span class="p"> </span><span class="n">X</span> <span class="o">&gt;=</span> <span class="n">Y</span> <span class="kr">then</span><span class="p"></span>
         <span class="n">Result</span> <span class="o">:=</span> <span class="n">X</span><span class="p">;</span>
      <span class="kr">else</span><span class="p"></span>
         <span class="n">Result</span> <span class="o">:=</span> <span class="n">Y</span><span class="p">;</span>
      <span class="k">end if</span><span class="p">;</span>
      <span class="kr">return</span><span class="p"> </span><span class="n">Result</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Max</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Divide</span> <span class="o">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="kr">return</span><span class="p"> </span><span class="n">X</span> <span class="o">/</span> <span class="n">Y</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Divide</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Swap_Array_Elements</span><span class="o">(</span><span class="n">I</span><span class="p">,</span> <span class="n">J</span> <span class="o">:</span> <span class="n">Index</span><span class="p">;</span> <span class="n">A</span><span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Array_Type</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
      <span class="n">Temporary</span><span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Temporary</span> <span class="o">:=</span> <span class="n">A</span><span class="o">(</span><span class="n">I</span><span class="o">)</span><span class="p">;</span>
      <span class="n">A</span><span class="o">(</span><span class="n">I</span><span class="o">)</span>      <span class="o">:=</span> <span class="n">A</span><span class="o">(</span><span class="n">J</span><span class="o">)</span><span class="p">;</span>
      <span class="n">A</span><span class="o">(</span><span class="n">J</span><span class="o">)</span>      <span class="o">:=</span> <span class="n">Temporary</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Swap_Array_Elements</span><span class="p">;</span>

<span class="k">end </span><span class="nf">Swap_Add_Max_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specification in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Swap_Add_Max_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span>
<span class="kr">is</span><span class="p"></span>
   <span class="kr">subtype</span><span class="p"> </span><span class="n">Index</span>      <span class="kr">is</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">range</span><span class="p"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Array_Type</span> <span class="kr">is</span><span class="p"> </span><span class="kr">array</span><span class="p"> </span><span class="o">(</span><span class="n">Index</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Swap</span> <span class="o">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Post</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">X</span> <span class="o">=</span> <span class="n">Y</span><span class="na">&#39;Old</span> <span class="kr">and</span><span class="p"> </span><span class="n">Y</span> <span class="o">=</span> <span class="n">X</span><span class="na">&#39;Old</span><span class="o">)</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Add</span> <span class="o">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Pre</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="kr">if</span><span class="p"> </span><span class="n">X</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="kr">and</span><span class="p"> </span><span class="n">Y</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="kr">then</span><span class="p"> </span><span class="n">X</span> <span class="o">&lt;=</span> <span class="n">Integer</span><span class="na">&#39;Last</span> <span class="o">-</span> <span class="n">Y</span>
                   <span class="kr">elsif</span><span class="p"> </span><span class="n">X</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="kr">and</span><span class="p"> </span><span class="n">Y</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="kr">then</span><span class="p"> </span><span class="n">X</span> <span class="o">&gt;=</span> <span class="n">Integer</span><span class="na">&#39;First</span> <span class="o">-</span> <span class="n">Y</span><span class="o">)</span><span class="p">,</span>
          <span class="c">-- The precondition may be written as X + Y in Integer if</span>
          <span class="c">-- an extended arithmetic mode is selected</span>
          <span class="n">Post</span> <span class="o">=&gt;</span> <span class="n">Add</span><span class="na">&#39;Result</span> <span class="o">=</span> <span class="n">X</span> <span class="o">+</span> <span class="n">Y</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Max</span> <span class="o">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Post</span> <span class="o">=&gt;</span> <span class="n">Max</span><span class="na">&#39;Result</span> <span class="o">=</span> <span class="o">(</span><span class="kr">if</span><span class="p"> </span><span class="n">X</span> <span class="o">&gt;=</span> <span class="n">Y</span> <span class="kr">then</span><span class="p"> </span><span class="n">X</span> <span class="kr">else</span><span class="p"> </span><span class="n">Y</span><span class="o">)</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Divide</span> <span class="o">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Pre</span>  <span class="o">=&gt;</span> <span class="n">Y</span> <span class="o">/=</span> <span class="mi">0</span> <span class="kr">and</span><span class="p"> </span><span class="n">X</span> <span class="o">&gt;</span> <span class="n">Integer</span><span class="na">&#39;First</span><span class="p">,</span>
          <span class="n">Post</span> <span class="o">=&gt;</span> <span class="n">Divide</span><span class="na">&#39;Result</span> <span class="o">=</span> <span class="n">X</span> <span class="o">/</span> <span class="n">Y</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Swap_Array_Elements</span><span class="o">(</span><span class="n">I</span><span class="p">,</span> <span class="n">J</span> <span class="o">:</span> <span class="n">Index</span><span class="p">;</span> <span class="n">A</span><span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Array_Type</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Post</span> <span class="o">=&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="na">&#39;Old&#39;Update</span> <span class="o">(</span><span class="n">I</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="na">&#39;Old</span> <span class="o">(</span><span class="n">J</span><span class="o">)</span><span class="p">,</span>
                                    <span class="n">J</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="na">&#39;Old</span> <span class="o">(</span><span class="n">I</span><span class="o">))</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Swap_Add_Max_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Swap_Add_Max_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Swap</span> <span class="o">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span> <span class="kr">is</span><span class="p"></span>
      <span class="n">Temporary</span><span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Temporary</span> <span class="o">:=</span> <span class="n">X</span><span class="p">;</span>
      <span class="n">X</span>         <span class="o">:=</span> <span class="n">Y</span><span class="p">;</span>
      <span class="n">Y</span>         <span class="o">:=</span> <span class="n">Temporary</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Swap</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Add</span> <span class="o">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">X</span> <span class="o">+</span> <span class="n">Y</span><span class="o">)</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Max</span> <span class="o">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">is</span><span class="p"></span>
     <span class="o">(</span><span class="kr">if</span><span class="p"> </span><span class="n">X</span> <span class="o">&gt;=</span> <span class="n">Y</span> <span class="kr">then</span><span class="p"> </span><span class="n">X</span>
      <span class="kr">else</span><span class="p"> </span><span class="n">Y</span><span class="o">)</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Divide</span> <span class="o">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">X</span> <span class="o">/</span> <span class="n">Y</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Swap_Array_Elements</span><span class="o">(</span><span class="n">I</span><span class="p">,</span> <span class="n">J</span> <span class="o">:</span> <span class="n">Index</span><span class="p">;</span> <span class="n">A</span><span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Array_Type</span><span class="o">)</span> <span class="kr">is</span><span class="p"></span>
      <span class="n">Temporary</span><span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Temporary</span> <span class="o">:=</span> <span class="n">A</span><span class="o">(</span><span class="n">I</span><span class="o">)</span><span class="p">;</span>
      <span class="n">A</span><span class="o">(</span><span class="n">I</span><span class="o">)</span>      <span class="o">:=</span> <span class="n">A</span><span class="o">(</span><span class="n">J</span><span class="o">)</span><span class="p">;</span>
      <span class="n">A</span><span class="o">(</span><span class="n">J</span><span class="o">)</span>      <span class="o">:=</span> <span class="n">Temporary</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Swap_Array_Elements</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Swap_Add_Max_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="attributes-of-unconstrained-out-parameter-in-precondition">
<span id="ms-attributes-of-unconstrained-out-parameter-in-precondition-label"></span><h3>Attributes of unconstrained out parameter in precondition<a class="headerlink" href="#attributes-of-unconstrained-out-parameter-in-precondition" title="Permalink to this headline">¶</a></h3>
<p>The following example illustrates the fact that the attributes of an unconstrained
formal array parameter of mode &#8220;out&#8221; are permitted to appear in a precondition.
The flow analyzer also needs to be smart about this, since it knows that X&#8217;First and
X&#8217;Last are well-defined in the body, even though the content of X is not.</p>
<p>Specification in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">P</span>
<span class="kr">is</span><span class="p"></span>
   <span class="kr">type</span><span class="p"> </span><span class="n">A</span> <span class="kr">is</span><span class="p"> </span><span class="kr">array</span><span class="p"> </span><span class="o">(</span><span class="n">Positive</span> <span class="kr">range</span><span class="p"> </span><span class="o">&lt;&gt;)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>

   <span class="c">-- Shows that X&#39;First and X&#39;Last _can_ be used in</span>
   <span class="c">-- precondition here, even though X is mode &quot;out&quot;...</span>
   <span class="k">procedure </span><span class="nf">Init</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">A</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--# pre X&#39;First = 1  and</span>
   <span class="c">--#     X&#39;Last  &gt;= 20;</span>
   <span class="c">--# post for all I in Positive range X&#39;Range =&gt;</span>
   <span class="c">--#      ((I /= 20 -&gt; (X (I) = 0)) and</span>
   <span class="c">--#         (I = 1 -&gt; (X (I) = X&#39;Last)) and</span>
   <span class="c">--#         (I = 20 -&gt; (X (I) = -1)));</span>

<span class="k">end </span><span class="nf">P</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">P</span> <span class="kr">is</span><span class="p"></span>

   <span class="k">procedure </span><span class="nf">Init</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">A</span><span class="o">)</span> <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">X</span> <span class="o">:=</span> <span class="o">(</span><span class="kr">others</span><span class="p"> </span><span class="o">=&gt;</span> <span class="mi">0</span><span class="o">)</span><span class="p">;</span>
      <span class="n">X</span> <span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">X</span><span class="na">&#39;Last</span><span class="p">;</span>
      <span class="n">X</span> <span class="o">(</span><span class="mi">20</span><span class="o">)</span> <span class="o">:=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="k">end </span><span class="nf">Init</span><span class="p">;</span>

<span class="k">end </span><span class="nf">P</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specification in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">P</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span>
<span class="kr">is</span><span class="p"></span>
   <span class="kr">type</span><span class="p"> </span><span class="n">A</span> <span class="kr">is</span><span class="p"> </span><span class="kr">array</span><span class="p"> </span><span class="o">(</span><span class="n">Positive</span> <span class="kr">range</span><span class="p"> </span><span class="o">&lt;&gt;)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>

   <span class="c">-- Shows that X&#39;First, X&#39;Last and X&#39;Length _can_ be used</span>
   <span class="c">-- in precondition here, even though X is mode &quot;out&quot;...</span>
   <span class="k">procedure </span><span class="nf">Init</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">A</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Pre</span>  <span class="o">=&gt;</span> <span class="n">X</span><span class="na">&#39;First</span> <span class="o">=</span> <span class="mi">1</span> <span class="kr">and</span><span class="p"> </span><span class="n">X</span><span class="na">&#39;Last</span> <span class="o">&gt;=</span> <span class="mi">20</span><span class="p">,</span>
          <span class="n">Post</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="kr">for</span><span class="p"> </span><span class="kr">all</span><span class="p"> </span><span class="n">I</span> <span class="kr">in</span><span class="p"> </span><span class="n">X</span><span class="na">&#39;Range</span> <span class="o">=&gt;</span>
                     <span class="o">(</span><span class="kr">if</span><span class="p"> </span><span class="n">I</span> <span class="o">=</span> <span class="mi">1</span> <span class="kr">then</span><span class="p"> </span><span class="n">X</span> <span class="o">(</span><span class="n">I</span><span class="o">)</span> <span class="o">=</span> <span class="n">X</span><span class="na">&#39;Last</span>
                      <span class="kr">elsif</span><span class="p"> </span><span class="n">I</span> <span class="o">=</span> <span class="mi">20</span> <span class="kr">then</span><span class="p"> </span><span class="n">X</span> <span class="o">(</span><span class="n">I</span><span class="o">)</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                      <span class="kr">else</span><span class="p"> </span><span class="n">X</span> <span class="o">(</span><span class="n">I</span><span class="o">)</span> <span class="o">=</span> <span class="mi">0</span><span class="o">))</span><span class="p">;</span>
<span class="k">end </span><span class="nf">P</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">P</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Init</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">A</span><span class="o">)</span> <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">X</span> <span class="o">:=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">=&gt;</span> <span class="n">X</span><span class="na">&#39;Last</span><span class="p">,</span> <span class="mi">20</span> <span class="o">=&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kr">others</span><span class="p"> </span><span class="o">=&gt;</span> <span class="mi">0</span><span class="o">)</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Init</span><span class="p">;</span>
<span class="k">end </span><span class="nf">P</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="data-abstraction-refinement-and-initialization">
<span id="ms-nesting-refinement-label"></span><h3>Data Abstraction, Refinement and Initialization<a class="headerlink" href="#data-abstraction-refinement-and-initialization" title="Permalink to this headline">¶</a></h3>
<p>This example demonstrates data abstraction and refinement.  It also
shows how abstract data is shown to be initialized during package
elaboration (it need not be - it could be initialized through an
explicit subprogram call, in which case the Initalizes annotation
should not be given).  There is also a demonstration of how procedures
and functions can be nested within other procedures and
functions. Furthermore, it illustrates how global variable refinement
can be performed.</p>
<p>Specification in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Nesting_Refinement_05</span>
<span class="c">--# own State;</span>
<span class="c">--# initializes State;</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Operate_On_State</span><span class="p">;</span>
   <span class="c">--# global in out State;</span>
<span class="k">end </span><span class="nf">Nesting_Refinement_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Nesting_Refinement_05</span>
<span class="c">--# own State is X, Y;     -- Refined State</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Operate_On_State</span>
   <span class="c">--# global in out X;    -- Refined Global</span>
   <span class="c">--#           out Y;</span>
   <span class="kr">is</span><span class="p"></span>
      <span class="n">Z</span><span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>

      <span class="k">procedure </span><span class="nf">Add_Z_To_X</span>
      <span class="c">--# global in out X;</span>
      <span class="c">--#        in     Z;</span>
      <span class="kr">is</span><span class="p"></span>
      <span class="kr">begin</span><span class="p"></span>
	 <span class="n">X</span> <span class="o">:=</span> <span class="n">X</span> <span class="o">+</span> <span class="n">Z</span><span class="p">;</span>
      <span class="k">end </span><span class="nf">Add_Z_To_X</span><span class="p">;</span>

      <span class="k">procedure </span><span class="nf">Overwrite_Y_With_Z</span>
      <span class="c">--# global    out Y;</span>
      <span class="c">--#        in     Z;</span>
      <span class="kr">is</span><span class="p"></span>
      <span class="kr">begin</span><span class="p"></span>
	 <span class="n">Y</span> <span class="o">:=</span> <span class="n">Z</span><span class="p">;</span>
      <span class="k">end </span><span class="nf">Overwrite_Y_With_Z</span><span class="p">;</span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Z</span> <span class="o">:=</span> <span class="mi">5</span><span class="p">;</span>
      <span class="n">Add_Z_To_X</span><span class="p">;</span>
      <span class="n">Overwrite_Y_With_Z</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Operate_On_State</span><span class="p">;</span>

<span class="kr">begin</span><span class="p"> </span><span class="c">-- Promised to initialize State</span>
      <span class="c">-- (which consists of X and Y)</span>
   <span class="n">X</span> <span class="o">:=</span> <span class="mi">10</span><span class="p">;</span>
   <span class="n">Y</span> <span class="o">:=</span> <span class="mi">20</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Nesting_Refinement_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specification in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Nesting_Refinement_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="p">,</span>
       <span class="n">Initializes</span>    <span class="o">=&gt;</span> <span class="n">State</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Operate_On_State</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Nesting_Refinement_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Nesting_Refinement_14</span>
  <span class="c">-- State is refined onto two concrete variables X and Y</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="o">))</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Operate_On_State</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">X</span><span class="p">,</span>
                             <span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">Y</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
      <span class="n">Z</span><span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>

      <span class="k">procedure </span><span class="nf">Add_Z_To_X</span>
        <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">X</span><span class="p">,</span>
                        <span class="n">Input</span>  <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">)</span>
      <span class="kr">is</span><span class="p"></span>
      <span class="kr">begin</span><span class="p"></span>
         <span class="n">X</span> <span class="o">:=</span> <span class="n">X</span> <span class="o">+</span> <span class="n">Z</span><span class="p">;</span>
      <span class="k">end </span><span class="nf">Add_Z_To_X</span><span class="p">;</span>

      <span class="k">procedure </span><span class="nf">Overwrite_Y_With_Z</span>
        <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">Y</span><span class="p">,</span>
                        <span class="n">Input</span>  <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">)</span>
      <span class="kr">is</span><span class="p"></span>
      <span class="kr">begin</span><span class="p"></span>
         <span class="n">Y</span> <span class="o">:=</span> <span class="n">Z</span><span class="p">;</span>
      <span class="k">end </span><span class="nf">Overwrite_Y_With_Z</span><span class="p">;</span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Z</span> <span class="o">:=</span> <span class="mi">5</span><span class="p">;</span>
      <span class="n">Add_Z_To_X</span><span class="p">;</span>
      <span class="n">Overwrite_Y_With_Z</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Operate_On_State</span><span class="p">;</span>

<span class="kr">begin</span><span class="p"></span>
   <span class="c">-- Promised to initialize State</span>
   <span class="c">-- (which consists of X and Y)</span>
   <span class="n">X</span> <span class="o">:=</span> <span class="mi">10</span><span class="p">;</span>
   <span class="n">Y</span> <span class="o">:=</span> <span class="mi">20</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Nesting_Refinement_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
</div>
<div class="section" id="package-patterns">
<h2>Package patterns<a class="headerlink" href="#package-patterns" title="Permalink to this headline">¶</a></h2>
<div class="section" id="abstract-data-types-adts">
<h3>Abstract Data Types (ADTs)<a class="headerlink" href="#abstract-data-types-adts" title="Permalink to this headline">¶</a></h3>
<div class="section" id="visible-type">
<span id="ms-adt-visible-label"></span><h4>Visible type<a class="headerlink" href="#visible-type" title="Permalink to this headline">¶</a></h4>
<p>The following example adds no mapping information. The SPARK 2005 and SPARK 2014 versions
of the code are identical. Only the specification of the SPARK 2005 code will be presented.
The reason why this code is being provided is to allow for a comparison between a package that
is purely public and an equivalent one that also has private elements.</p>
<p>Specification in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Stacks_05</span> <span class="kr">is</span><span class="p"></span>
   <span class="n">Stack_Size</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="o">:=</span> <span class="mi">100</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span><span class="n">Pointer_Range</span> <span class="kr">is</span><span class="p"> </span><span class="kr">range</span><span class="p"> </span><span class="mi">0</span> <span class="o">..</span> <span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">subtype</span><span class="p"> </span><span class="n">Index_Range</span> <span class="kr">is</span><span class="p"> </span><span class="n">Pointer_Range</span> <span class="kr">range</span><span class="p"> </span><span class="mi">1</span> <span class="o">..</span> <span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span><span class="n">Vector</span> <span class="kr">is</span><span class="p"> </span><span class="n">array</span><span class="o">(</span><span class="n">Index_Range</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>

   <span class="kr">type</span><span class="p"> </span><span class="n">Stack</span> <span class="kr">is</span><span class="p"></span>
      <span class="kr">record</span><span class="p"></span>
         <span class="n">Stack_Vector</span> <span class="o">:</span> <span class="n">Vector</span><span class="p">;</span>
         <span class="n">Stack_Pointer</span> <span class="o">:</span> <span class="n">Pointer_Range</span><span class="p">;</span>
      <span class="k">end record</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Is_Empty</span><span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Stack</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span><span class="p">;</span>
   <span class="k">function </span><span class="nf">Is_Full</span><span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Stack</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Clear</span><span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Stack</span><span class="o">)</span><span class="p">;</span>
   <span class="k">procedure </span><span class="nf">Push</span><span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Stack</span><span class="p">;</span> <span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
   <span class="k">procedure </span><span class="nf">Pop</span><span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Stack</span><span class="p">;</span> <span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Stacks_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="private-type">
<span id="ms-adt-private-label"></span><h4>Private type<a class="headerlink" href="#private-type" title="Permalink to this headline">¶</a></h4>
<p>Similarly to the previous example, this one does not contain any annotations either. Due
to this, the SPARK 2005 and SPARK 2014 versions are exactly the same. Only the specification of
the 2005 version shall be presented.</p>
<p>Specification in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Stacks_05</span> <span class="kr">is</span><span class="p"></span>

   <span class="kr">type</span><span class="p"> </span><span class="n">Stack</span> <span class="kr">is</span><span class="p"> </span><span class="kr">private</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Is_Empty</span><span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Stack</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span><span class="p">;</span>
   <span class="k">function </span><span class="nf">Is_Full</span><span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Stack</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Clear</span><span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Stack</span><span class="o">)</span><span class="p">;</span>
   <span class="k">procedure </span><span class="nf">Push</span><span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Stack</span><span class="p">;</span> <span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
   <span class="k">procedure </span><span class="nf">Pop</span><span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Stack</span><span class="p">;</span> <span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span>

<span class="kr">private</span><span class="p"></span>
   <span class="n">Stack_Size</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="o">:=</span> <span class="mi">100</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span><span class="n">Pointer_Range</span> <span class="kr">is</span><span class="p"> </span><span class="kr">range</span><span class="p"> </span><span class="mi">0</span> <span class="o">..</span> <span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">subtype</span><span class="p"> </span><span class="n">Index_Range</span> <span class="kr">is</span><span class="p"> </span><span class="n">Pointer_Range</span> <span class="kr">range</span><span class="p"> </span><span class="mi">1</span> <span class="o">..</span> <span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span><span class="n">Vector</span> <span class="kr">is</span><span class="p"> </span><span class="n">array</span><span class="o">(</span><span class="n">Index_Range</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>

   <span class="kr">type</span><span class="p"> </span><span class="n">Stack</span> <span class="kr">is</span><span class="p"></span>
      <span class="kr">record</span><span class="p"></span>
         <span class="n">Stack_Vector</span> <span class="o">:</span> <span class="n">Vector</span><span class="p">;</span>
         <span class="n">Stack_Pointer</span> <span class="o">:</span> <span class="n">Pointer_Range</span><span class="p">;</span>
      <span class="k">end record</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Stacks_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="private-type-with-pre-post-contracts">
<span id="ms-adt-private-refinement-label"></span><h4>Private type with pre/post contracts<a class="headerlink" href="#private-type-with-pre-post-contracts" title="Permalink to this headline">¶</a></h4>
<p>This example demonstrates how <cite>pre</cite> and <cite>post</cite> conditions of
subprograms may be specified in terms of functions declared in the
same package specification.  The function declarations are completed
in the body and the postconditions of the completed functions are used
to prove the implementations of the other subprograms.  In SPARK 2014
explicit postconditions do not have to be specified on the bodies of
the functions as they are implemented as expression functions and the
expression, E, of the function acts as a default refined
postcondition, i.e., F&#8217;Result = E.  Note that the SPARK 2014 version is
proven entirely automatically whereas the SPARK 2005 version requires
user defined proof rules.</p>
<p>Specification in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Stacks_05</span>
<span class="kr">is</span><span class="p"></span>

   <span class="kr">type</span><span class="p"> </span><span class="n">Stack</span> <span class="kr">is</span><span class="p"> </span><span class="kr">private</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Is_Empty</span><span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Stack</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span><span class="p">;</span>
   <span class="k">function </span><span class="nf">Is_Full</span><span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Stack</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Clear</span><span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Stack</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--# post Is_Empty(S);</span>
   <span class="k">procedure </span><span class="nf">Push</span><span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Stack</span><span class="p">;</span> <span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--# pre  not Is_Full(S);</span>
   <span class="c">--# post not Is_Empty(S);</span>
   <span class="k">procedure </span><span class="nf">Pop</span><span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Stack</span><span class="p">;</span> <span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--# pre  not Is_Empty(S);</span>
   <span class="c">--# post not Is_Full(S);</span>

<span class="kr">private</span><span class="p"></span>
   <span class="n">Stack_Size</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="o">:=</span> <span class="mi">100</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Pointer_Range</span> <span class="kr">is</span><span class="p"> </span><span class="kr">range</span><span class="p"> </span><span class="mi">0</span> <span class="o">..</span> <span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">subtype</span><span class="p"> </span><span class="n">Index_Range</span>   <span class="kr">is</span><span class="p"> </span><span class="n">Pointer_Range</span> <span class="kr">range</span><span class="p"> </span><span class="mi">1</span> <span class="o">..</span> <span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Vector</span>        <span class="kr">is</span><span class="p"> </span><span class="n">array</span><span class="o">(</span><span class="n">Index_Range</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>

   <span class="kr">type</span><span class="p"> </span><span class="n">Stack</span> <span class="kr">is</span><span class="p"></span>
      <span class="kr">record</span><span class="p"></span>
         <span class="n">Stack_Vector</span>  <span class="o">:</span> <span class="n">Vector</span><span class="p">;</span>
         <span class="n">Stack_Pointer</span> <span class="o">:</span> <span class="n">Pointer_Range</span><span class="p">;</span>
      <span class="k">end record</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Stacks_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Stacks_05</span> <span class="kr">is</span><span class="p"></span>

   <span class="k">function </span><span class="nf">Is_Empty</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Stack</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span>
   <span class="c">--# return S.Stack_Pointer = 0;</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="kr">return</span><span class="p"> </span><span class="n">S.Stack_Pointer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Is_Empty</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Is_Full</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Stack</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span>
   <span class="c">--# return S.Stack_Pointer = Stack_Size;</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="kr">return</span><span class="p"> </span><span class="n">S.Stack_Pointer</span> <span class="o">=</span> <span class="n">Stack_Size</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Is_Full</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Clear</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Stack</span><span class="o">)</span>
   <span class="c">--# post Is_Empty(S);</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">S.Stack_Pointer</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Clear</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Push</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Stack</span><span class="p">;</span> <span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">S.Stack_Pointer</span> <span class="o">:=</span> <span class="n">S.Stack_Pointer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">S.Stack_Vector</span> <span class="o">(</span><span class="n">S.Stack_Pointer</span><span class="o">)</span> <span class="o">:=</span> <span class="n">X</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Push</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Pop</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Stack</span><span class="p">;</span> <span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">X</span> <span class="o">:=</span> <span class="n">S.Stack_Vector</span> <span class="o">(</span><span class="n">S.Stack_Pointer</span><span class="o">)</span><span class="p">;</span>
      <span class="n">S.Stack_Pointer</span> <span class="o">:=</span> <span class="n">S.Stack_Pointer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Pop</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Stacks_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specification in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Stacks_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span>
<span class="kr">is</span><span class="p"></span>
   <span class="kr">type</span><span class="p"> </span><span class="n">Stack</span> <span class="kr">is</span><span class="p"> </span><span class="kr">private</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Is_Empty</span><span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Stack</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span><span class="p">;</span>
   <span class="k">function </span><span class="nf">Is_Full</span><span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Stack</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Clear</span><span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Stack</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Post</span> <span class="o">=&gt;</span> <span class="n">Is_Empty</span><span class="o">(</span><span class="n">S</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Push</span><span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Stack</span><span class="p">;</span> <span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Pre</span>  <span class="o">=&gt;</span> <span class="kr">not</span><span class="p"> </span><span class="n">Is_Full</span><span class="o">(</span><span class="n">S</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Post</span> <span class="o">=&gt;</span> <span class="kr">not</span><span class="p"> </span><span class="n">Is_Empty</span><span class="o">(</span><span class="n">S</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Pop</span><span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Stack</span><span class="p">;</span> <span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Pre</span>  <span class="o">=&gt;</span> <span class="kr">not</span><span class="p"> </span><span class="n">Is_Empty</span><span class="o">(</span><span class="n">S</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Post</span> <span class="o">=&gt;</span> <span class="kr">not</span><span class="p"> </span><span class="n">Is_Full</span><span class="o">(</span><span class="n">S</span><span class="o">)</span><span class="p">;</span>

<span class="kr">private</span><span class="p"></span>
   <span class="n">Stack_Size</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="o">:=</span> <span class="mi">100</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Pointer_Range</span> <span class="kr">is</span><span class="p"> </span><span class="kr">range</span><span class="p"> </span><span class="mi">0</span> <span class="o">..</span> <span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">subtype</span><span class="p"> </span><span class="n">Index_Range</span>   <span class="kr">is</span><span class="p"> </span><span class="n">Pointer_Range</span> <span class="kr">range</span><span class="p"> </span><span class="mi">1</span> <span class="o">..</span> <span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Vector</span>        <span class="kr">is</span><span class="p"> </span><span class="n">array</span><span class="o">(</span><span class="n">Index_Range</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>

   <span class="kr">type</span><span class="p"> </span><span class="n">Stack</span> <span class="kr">is</span><span class="p"> </span><span class="kr">record</span><span class="p"></span>
      <span class="n">Stack_Vector</span>  <span class="o">:</span> <span class="n">Vector</span><span class="p">;</span>
      <span class="n">Stack_Pointer</span> <span class="o">:</span> <span class="n">Pointer_Range</span><span class="p">;</span>
   <span class="k">end record</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Stacks_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Stacks_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span>
<span class="kr">is</span><span class="p"></span>
   <span class="c">-- Expression function has default refined postcondition of</span>
   <span class="c">-- Is_Empty&#39;Result = (S.Stack_Pointer = 0)</span>
   <span class="k">function </span><span class="nf">Is_Empty</span><span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Stack</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">S.Stack_Pointer</span> <span class="o">=</span> <span class="mi">0</span><span class="o">)</span><span class="p">;</span>

   <span class="c">-- Expression function has default refined postcondition of</span>
   <span class="c">-- Is_Empty&#39;Result = (S.Stack_Pointer = Stack_Size)</span>
   <span class="k">function </span><span class="nf">Is_Full</span><span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Stack</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">S.Stack_Pointer</span> <span class="o">=</span> <span class="n">Stack_Size</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Clear</span><span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Stack</span><span class="o">)</span> <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">S.Stack_Pointer</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Clear</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Push</span><span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Stack</span><span class="p">;</span> <span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span> <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">S.Stack_Pointer</span> <span class="o">:=</span> <span class="n">S.Stack_Pointer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">S.Stack_Vector</span><span class="o">(</span><span class="n">S.Stack_Pointer</span><span class="o">)</span> <span class="o">:=</span> <span class="n">X</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Push</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Pop</span><span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Stack</span><span class="p">;</span> <span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span> <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">X</span> <span class="o">:=</span> <span class="n">S.Stack_Vector</span><span class="o">(</span><span class="n">S.Stack_Pointer</span><span class="o">)</span><span class="p">;</span>
      <span class="n">S.Stack_Pointer</span> <span class="o">:=</span> <span class="n">S.Stack_Pointer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Pop</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Stacks_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<span class="target" id="ms-adt-public-child-non-tagged-parent-label"></span><span class="target" id="ms-adt-tagged-type-label"></span><span class="target" id="ms-adt-tagged-type-extension-label"></span></div>
<div class="section" id="private-public-child-visibility">
<span id="ms-adt-private-public-child-visibility-label"></span><h4>Private/Public child visibility<a class="headerlink" href="#private-public-child-visibility" title="Permalink to this headline">¶</a></h4>
<p>The following example demonstrates visibility rules that apply between public children,
private children and their parent in SPARK 2005. More specifically, it shows that:</p>
<ul class="simple">
<li>Private children are able to see their private siblings but not their public siblings.</li>
<li>Public children are able to see their public siblings but not their private siblings.</li>
<li>All children have access to their parent but the parent can only access private children.</li>
</ul>
<p>Applying the SPARK tools on the following files will produce certain errors. This was
intentionally done in order to illustrate both legal and illegal access attempts.</p>
<p>SPARK 2014 shares Ada2012&#8217;s visibility rules. No restrictions have been applied
in terms of visibility.  Note that SPARK 2014 code does not require Inherit annotations.</p>
<p>Specification of parent in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Parent_05</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">F</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>
   <span class="k">function </span><span class="nf">G</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Parent_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specification of private child A in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">--#inherit Parent_05; -- OK</span>
<span class="kr">private</span><span class="p"> </span><span class="k">package </span><span class="nf">Parent_05.Private_Child_A_05</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">F</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Parent_05.Private_Child_A_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specification of private child B in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">--#inherit Parent_05.Private_Child_A_05, -- OK</span>
<span class="c">--#        Parent_05.Public_Child_A_05;  -- error, public sibling</span>
<span class="kr">private</span><span class="p"> </span><span class="k">package </span><span class="nf">Parent_05.Private_Child_B_05</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">H</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Parent_05.Private_Child_B_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specification of public child A in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">--#inherit Parent_05,                     -- OK</span>
<span class="c">--#        Parent_05.Private_Child_A_05;  -- error, private sibling</span>
<span class="k">package </span><span class="nf">Parent_05.Public_Child_A_05</span>
<span class="kr">is</span><span class="p"></span>
  <span class="k">function </span><span class="nf">G</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Parent_05.Public_Child_A_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specification of public child B in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">--#inherit Parent_05.Public_Child_A_05; -- OK</span>
<span class="k">package </span><span class="nf">Parent_05.Public_Child_B_05</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">H</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Parent_05.Public_Child_B_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body of parent in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">Parent_05.Private_Child_A_05</span><span class="p">,</span>   <span class="c">-- OK</span>
     <span class="n">Parent_05.Public_Child_A_05</span><span class="p">;</span>    <span class="c">-- error, public children not visible</span>
<span class="k">package body </span><span class="nf">Parent_05</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">F</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="kr">return</span><span class="p"> </span><span class="n">Private_Child_A_05.F</span> <span class="o">(</span><span class="n">X</span><span class="o">)</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">F</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">G</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="kr">return</span><span class="p"> </span><span class="n">Public_Child_A_05.G</span> <span class="o">(</span><span class="n">X</span><span class="o">)</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">G</span><span class="p">;</span>

<span class="k">end </span><span class="nf">Parent_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body of public child A in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Parent_05.Public_Child_A_05</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">G</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">is</span><span class="p"></span>
      <span class="n">Result</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="kr">if</span><span class="p"> </span><span class="n">X</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="kr">then</span><span class="p"></span>
         <span class="n">Result</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="kr">else</span><span class="p"></span>
         <span class="n">Result</span> <span class="o">:=</span> <span class="n">Parent_05.F</span> <span class="o">(</span><span class="n">X</span><span class="o">)</span><span class="p">;</span>  <span class="c">-- OK</span>
      <span class="k">end if</span><span class="p">;</span>
      <span class="kr">return</span><span class="p"> </span><span class="n">Result</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">G</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Parent_05.Public_Child_A_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body of public child B in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">Parent_05.Private_Child_B_05</span><span class="p">;</span>
<span class="k">package body </span><span class="nf">Parent_05.Public_Child_B_05</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">H</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="kr">return</span><span class="p"> </span><span class="n">Parent_05.Private_Child_B_05.H</span> <span class="o">(</span><span class="n">X</span><span class="o">)</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">H</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Parent_05.Public_Child_B_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body of private child B in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Parent_05.Private_Child_B_05</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">H</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">is</span><span class="p"></span>
      <span class="n">Result</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="kr">if</span><span class="p"> </span><span class="n">X</span> <span class="o">&lt;=</span> <span class="mi">10</span> <span class="kr">then</span><span class="p"></span>
         <span class="n">Result</span> <span class="o">:=</span> <span class="mi">10</span><span class="p">;</span>
      <span class="kr">else</span><span class="p"></span>
         <span class="n">Result</span> <span class="o">:=</span> <span class="n">Parent_05.F</span> <span class="o">(</span><span class="n">X</span><span class="o">)</span><span class="p">;</span>  <span class="c">-- Illegal in SPARK 2005</span>
      <span class="k">end if</span><span class="p">;</span>
      <span class="kr">return</span><span class="p"> </span><span class="n">Result</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">H</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Parent_05.Private_Child_B_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specification of parent in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Parent_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">F</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>
   <span class="k">function </span><span class="nf">G</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Parent_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specification of private child A in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">private</span><span class="p"> </span><span class="k">package </span><span class="nf">Parent_14.Private_Child_A_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">F</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Parent_14.Private_Child_A_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specification of private child B in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">private</span><span class="p"> </span><span class="k">package </span><span class="nf">Parent_14.Private_Child_B_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">H</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Parent_14.Private_Child_B_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specification of public child A in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Parent_14.Public_Child_A_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span>
<span class="kr">is</span><span class="p"></span>
  <span class="k">function </span><span class="nf">G</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Parent_14.Public_Child_A_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specification of public child B in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Parent_14.Public_Child_B_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">H</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Parent_14.Public_Child_B_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body of parent in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">Parent_14.Private_Child_A_14</span><span class="p">,</span>   <span class="c">-- OK</span>
     <span class="n">Parent_14.Public_Child_A_14</span><span class="p">;</span>    <span class="c">-- OK</span>

<span class="k">package body </span><span class="nf">Parent_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">F</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">Private_Child_A_14.F</span> <span class="o">(</span><span class="n">X</span><span class="o">))</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">G</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">Public_Child_A_14.G</span> <span class="o">(</span><span class="n">X</span><span class="o">))</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Parent_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body of public child A in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Parent_14.Public_Child_A_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">G</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">is</span><span class="p"></span>
     <span class="o">(</span><span class="kr">if</span><span class="p"> </span><span class="n">X</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="kr">then</span><span class="p"> </span><span class="mi">0</span>
      <span class="kr">else</span><span class="p"> </span><span class="n">Parent_14.F</span> <span class="o">(</span><span class="n">X</span><span class="o">))</span><span class="p">;</span>  <span class="c">-- OK</span>
<span class="k">end </span><span class="nf">Parent_14.Public_Child_A_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body of public child B in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">Parent_14.Private_Child_B_14</span><span class="p">;</span>

<span class="k">package body </span><span class="nf">Parent_14.Public_Child_B_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">H</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">is</span><span class="p"></span>
     <span class="o">(</span><span class="n">Parent_14.Private_Child_B_14.H</span> <span class="o">(</span><span class="n">X</span><span class="o">))</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Parent_14.Public_Child_B_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body of private child B in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Parent_14.Private_Child_B_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">H</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">is</span><span class="p"></span>
     <span class="o">(</span><span class="kr">if</span><span class="p"> </span><span class="n">X</span> <span class="o">&lt;=</span> <span class="mi">10</span> <span class="kr">then</span><span class="p"> </span><span class="mi">10</span>
      <span class="kr">else</span><span class="p"> </span><span class="n">Parent_14.F</span> <span class="o">(</span><span class="n">X</span><span class="o">))</span><span class="p">;</span>  <span class="c">-- Legal in SPARK 2014</span>
<span class="k">end </span><span class="nf">Parent_14.Private_Child_B_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
</div>
<div class="section" id="abstract-state-machines-asms">
<span id="ms-asm-label"></span><h3>Abstract State Machines (ASMs)<a class="headerlink" href="#abstract-state-machines-asms" title="Permalink to this headline">¶</a></h3>
<div class="section" id="visible-concrete-state">
<h4>Visible, concrete state<a class="headerlink" href="#visible-concrete-state" title="Permalink to this headline">¶</a></h4>
<div class="section" id="initialized-by-declaration">
<span id="ms-asm-visible-concrete-initialized-by-declaration-label"></span><h5>Initialized by declaration<a class="headerlink" href="#initialized-by-declaration" title="Permalink to this headline">¶</a></h5>
<p>The example that follows presents a way in SPARK 2005 of initializing
a concrete own variable (a state that is not refined) at the point
of the declaration of the variables that compose it.  Generally it
is not good practice to declare several concrete own variables,
data abstraction should be used but here we are doing it for the
point of illustration.</p>
<p>In SPARK 2014 the client&#8217;s view of package state is either visible
(declared in the visible part of the package) or a state abstraction
representing hidden state.  A variable cannot overload the name of a
state abstraction and therefore a state abstraction must be completed
by a refinement given in the body of the package - there is no concept
of a concrete state abstraction.  The constituents of a state
abstraction may be initialized at their declaration.</p>
<p>Specification in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Stack_05</span>
<span class="c">--# own S, Pointer;    -- concrete state</span>
<span class="c">--# initializes S, Pointer;</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Push</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--# global in out S, Pointer;</span>

   <span class="k">procedure </span><span class="nf">Pop</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--# global in S; in out Pointer;</span>
<span class="k">end </span><span class="nf">Stack_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Stack_05</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">Stack_Size</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="o">:=</span> <span class="mi">100</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Pointer_Range</span> <span class="kr">is</span><span class="p"> </span><span class="kr">range</span><span class="p"> </span><span class="mi">0</span> <span class="o">..</span> <span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">subtype</span><span class="p"> </span><span class="n">Index_Range</span>   <span class="kr">is</span><span class="p"> </span><span class="n">Pointer_Range</span> <span class="kr">range</span><span class="p"> </span><span class="mi">1</span><span class="o">..</span><span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Vector</span>        <span class="kr">is</span><span class="p"> </span><span class="n">array</span><span class="o">(</span><span class="n">Index_Range</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>

   <span class="n">S</span> <span class="o">:</span> <span class="n">Vector</span> <span class="o">:=</span> <span class="n">Vector</span><span class="o">&#39;(</span><span class="n">Index_Range</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">)</span><span class="p">;</span>  <span class="c">-- Initialization of S</span>
   <span class="n">Pointer</span> <span class="o">:</span> <span class="n">Pointer_Range</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>             <span class="c">-- Initialization of Pointer</span>

   <span class="k">procedure </span><span class="nf">Push</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Pointer</span> <span class="o">:=</span> <span class="n">Pointer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">S</span><span class="o">(</span><span class="n">Pointer</span><span class="o">)</span> <span class="o">:=</span> <span class="n">X</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Push</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Pop</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">X</span> <span class="o">:=</span> <span class="n">S</span><span class="o">(</span><span class="n">Pointer</span><span class="o">)</span><span class="p">;</span>
      <span class="n">Pointer</span> <span class="o">:=</span> <span class="n">Pointer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Pop</span><span class="p">;</span>

<span class="k">end </span><span class="nf">Stack_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specification in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Stack_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">S_State</span><span class="p">,</span> <span class="n">Pointer_State</span><span class="o">)</span><span class="p">,</span>
       <span class="n">Initializes</span>    <span class="o">=&gt;</span> <span class="o">(</span><span class="n">S_State</span><span class="p">,</span> <span class="n">Pointer_State</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Push</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">S_State</span><span class="p">,</span> <span class="n">Pointer_State</span><span class="o">))</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Pop</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span>  <span class="o">=&gt;</span> <span class="n">S_State</span><span class="p">,</span>
                     <span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">Pointer_State</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Stack_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Stack_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">S_State</span>       <span class="o">=&gt;</span> <span class="n">S</span><span class="p">,</span>
                         <span class="n">Pointer_State</span> <span class="o">=&gt;</span> <span class="n">Pointer</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">Stack_Size</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="o">:=</span> <span class="mi">100</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Pointer_Range</span> <span class="kr">is</span><span class="p"> </span><span class="kr">range</span><span class="p"> </span><span class="mi">0</span> <span class="o">..</span> <span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">subtype</span><span class="p"> </span><span class="n">Index_Range</span>   <span class="kr">is</span><span class="p"> </span><span class="n">Pointer_Range</span> <span class="kr">range</span><span class="p"> </span><span class="mi">1</span><span class="o">..</span><span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Vector</span>        <span class="kr">is</span><span class="p"> </span><span class="n">array</span><span class="o">(</span><span class="n">Index_Range</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>

   <span class="n">S</span> <span class="o">:</span> <span class="n">Vector</span> <span class="o">:=</span> <span class="n">Vector</span><span class="o">&#39;(</span><span class="n">Index_Range</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">)</span><span class="p">;</span>  <span class="c">-- Initialization of S</span>
   <span class="n">Pointer</span> <span class="o">:</span> <span class="n">Pointer_Range</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>             <span class="c">-- Initialization of Pointer</span>

   <span class="k">procedure </span><span class="nf">Push</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">S</span><span class="p">,</span> <span class="n">Pointer</span><span class="o">))</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Pointer</span> <span class="o">:=</span> <span class="n">Pointer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">S</span> <span class="o">(</span><span class="n">Pointer</span><span class="o">)</span> <span class="o">:=</span> <span class="n">X</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Push</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Pop</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span>  <span class="o">=&gt;</span> <span class="n">S</span><span class="p">,</span>
                             <span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">Pointer</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">X</span> <span class="o">:=</span> <span class="n">S</span> <span class="o">(</span><span class="n">Pointer</span><span class="o">)</span><span class="p">;</span>
      <span class="n">Pointer</span> <span class="o">:=</span> <span class="n">Pointer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Pop</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Stack_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="initialized-by-elaboration">
<span id="ms-asm-visible-concrete-initialized-by-elaboration-label"></span><h5>Initialized by elaboration<a class="headerlink" href="#initialized-by-elaboration" title="Permalink to this headline">¶</a></h5>
<p>The following example presents how a package&#8217;s concrete state can be initialized at
the statements section of the body. The specifications of both SPARK 2005 and SPARK 2014
are not presented since they are identical to the specifications of the previous example.</p>
<p>Body in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Stack_05</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">Stack_Size</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="o">:=</span> <span class="mi">100</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Pointer_Range</span> <span class="kr">is</span><span class="p"> </span><span class="kr">range</span><span class="p"> </span><span class="mi">0</span> <span class="o">..</span> <span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">subtype</span><span class="p"> </span><span class="n">Index_Range</span>   <span class="kr">is</span><span class="p"> </span><span class="n">Pointer_Range</span> <span class="kr">range</span><span class="p"> </span><span class="mi">1</span><span class="o">..</span><span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Vector</span>        <span class="kr">is</span><span class="p"> </span><span class="n">array</span><span class="o">(</span><span class="n">Index_Range</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>

   <span class="n">S</span> <span class="o">:</span> <span class="n">Vector</span><span class="p">;</span>
   <span class="n">Pointer</span> <span class="o">:</span> <span class="n">Pointer_Range</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Push</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Pointer</span> <span class="o">:=</span> <span class="n">Pointer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">S</span><span class="o">(</span><span class="n">Pointer</span><span class="o">)</span> <span class="o">:=</span> <span class="n">X</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Push</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Pop</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">X</span> <span class="o">:=</span> <span class="n">S</span><span class="o">(</span><span class="n">Pointer</span><span class="o">)</span><span class="p">;</span>
      <span class="n">Pointer</span> <span class="o">:=</span> <span class="n">Pointer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Pop</span><span class="p">;</span>

<span class="kr">begin</span><span class="p"> </span> <span class="c">-- initialization</span>
   <span class="n">Pointer</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="n">S</span> <span class="o">:=</span> <span class="n">Vector</span><span class="o">&#39;(</span><span class="n">Index_Range</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Stack_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Stack_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">S_State</span>       <span class="o">=&gt;</span> <span class="n">S</span><span class="p">,</span>
                         <span class="n">Pointer_State</span> <span class="o">=&gt;</span> <span class="n">Pointer</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">Stack_Size</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="o">:=</span> <span class="mi">100</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Pointer_Range</span> <span class="kr">is</span><span class="p"> </span><span class="kr">range</span><span class="p"> </span><span class="mi">0</span> <span class="o">..</span> <span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">subtype</span><span class="p"> </span><span class="n">Index_Range</span>   <span class="kr">is</span><span class="p"> </span><span class="n">Pointer_Range</span> <span class="kr">range</span><span class="p"> </span><span class="mi">1</span><span class="o">..</span><span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Vector</span>        <span class="kr">is</span><span class="p"> </span><span class="n">array</span><span class="o">(</span><span class="n">Index_Range</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>

   <span class="n">S</span> <span class="o">:</span> <span class="n">Vector</span><span class="p">;</span>
   <span class="n">Pointer</span> <span class="o">:</span> <span class="n">Pointer_Range</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Push</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">S</span><span class="p">,</span> <span class="n">Pointer</span><span class="o">))</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Pointer</span> <span class="o">:=</span> <span class="n">Pointer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">S</span> <span class="o">(</span><span class="n">Pointer</span><span class="o">)</span> <span class="o">:=</span> <span class="n">X</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Push</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Pop</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span>  <span class="o">=&gt;</span> <span class="n">S</span><span class="p">,</span>
                             <span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">Pointer</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">X</span> <span class="o">:=</span> <span class="n">S</span> <span class="o">(</span><span class="n">Pointer</span><span class="o">)</span><span class="p">;</span>
      <span class="n">Pointer</span> <span class="o">:=</span> <span class="n">Pointer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Pop</span><span class="p">;</span>
<span class="kr">begin</span><span class="p"></span>
   <span class="c">-- initialization</span>
   <span class="n">Pointer</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="n">S</span> <span class="o">:=</span> <span class="n">Vector</span><span class="o">&#39;(</span><span class="n">Index_Range</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Stack_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
</div>
<div class="section" id="private-concrete-state">
<span id="ms-asm-private-concrete-label"></span><h4>Private, concrete state<a class="headerlink" href="#private-concrete-state" title="Permalink to this headline">¶</a></h4>
<p>In SPARK 2005 variables declared in the private part of a package are
considered to be concrete own variables.  In SPARK 2014 they are hidden
state and must be constituents of a state abstraction.</p>
<p>The SPARK 2005 body has not been included since it does not contain
any annotations.</p>
<p>Specification in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Stack_05</span>
<span class="c">--# own S, Pointer;</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Push</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--# global in out S, Pointer;</span>

   <span class="k">procedure </span><span class="nf">Pop</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--# global in     S;</span>
   <span class="c">--#        in out Pointer;</span>
<span class="kr">private</span><span class="p"></span>
   <span class="n">Stack_Size</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="o">:=</span> <span class="mi">100</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Pointer_Range</span> <span class="kr">is</span><span class="p"> </span><span class="kr">range</span><span class="p"> </span><span class="mi">0</span> <span class="o">..</span> <span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">subtype</span><span class="p"> </span><span class="n">Index_Range</span>   <span class="kr">is</span><span class="p"> </span><span class="n">Pointer_Range</span> <span class="kr">range</span><span class="p"> </span><span class="mi">1</span><span class="o">..</span><span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Vector</span>        <span class="kr">is</span><span class="p"> </span><span class="n">array</span><span class="o">(</span><span class="n">Index_Range</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>

   <span class="n">S</span> <span class="o">:</span> <span class="n">Vector</span><span class="p">;</span>
   <span class="n">Pointer</span> <span class="o">:</span> <span class="n">Pointer_Range</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Stack_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specification in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Stack_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">S_State</span><span class="p">,</span> <span class="n">Pointer_State</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Push</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">S_State</span><span class="p">,</span> <span class="n">Pointer_State</span><span class="o">))</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Pop</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span>  <span class="o">=&gt;</span> <span class="n">S_State</span><span class="p">,</span>
                     <span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">Pointer_State</span><span class="o">)</span><span class="p">;</span>

<span class="kr">private</span><span class="p"></span>
   <span class="n">Stack_Size</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="o">:=</span> <span class="mi">100</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Pointer_Range</span> <span class="kr">is</span><span class="p"> </span><span class="kr">range</span><span class="p"> </span><span class="mi">0</span> <span class="o">..</span> <span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">subtype</span><span class="p"> </span><span class="n">Index_Range</span>   <span class="kr">is</span><span class="p"> </span><span class="n">Pointer_Range</span> <span class="kr">range</span><span class="p"> </span><span class="mi">1</span><span class="o">..</span><span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Vector</span>        <span class="kr">is</span><span class="p"> </span><span class="n">array</span><span class="o">(</span><span class="n">Index_Range</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>

   <span class="n">S</span>       <span class="o">:</span> <span class="n">Vector</span> <span class="kr">with</span><span class="p"> </span><span class="n">Part_Of</span> <span class="o">=&gt;</span> <span class="n">S_State</span><span class="p">;</span>
   <span class="n">Pointer</span> <span class="o">:</span> <span class="n">Pointer_Range</span> <span class="kr">with</span><span class="p"> </span><span class="n">Part_Of</span> <span class="o">=&gt;</span> <span class="n">Pointer_State</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Stack_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Stack_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">S_State</span>       <span class="o">=&gt;</span> <span class="n">S</span><span class="p">,</span>
                         <span class="n">Pointer_State</span> <span class="o">=&gt;</span> <span class="n">Pointer</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Push</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">S</span><span class="p">,</span> <span class="n">Pointer</span><span class="o">))</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Pointer</span> <span class="o">:=</span> <span class="n">Pointer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">S</span> <span class="o">(</span><span class="n">Pointer</span><span class="o">)</span> <span class="o">:=</span> <span class="n">X</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Push</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Pop</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span>  <span class="o">=&gt;</span> <span class="n">S</span><span class="p">,</span>
                             <span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">Pointer</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">X</span> <span class="o">:=</span> <span class="n">S</span> <span class="o">(</span><span class="n">Pointer</span><span class="o">)</span><span class="p">;</span>
      <span class="n">Pointer</span> <span class="o">:=</span> <span class="n">Pointer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Pop</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Stack_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="private-abstract-state-refining-onto-concrete-states-in-body">
<h4>Private, abstract state, refining onto concrete states in body<a class="headerlink" href="#private-abstract-state-refining-onto-concrete-states-in-body" title="Permalink to this headline">¶</a></h4>
<div class="section" id="initialized-by-procedure-call">
<span id="ms-asm-private-abstract-bodyref-procedureinit-label"></span><h5>Initialized by procedure call<a class="headerlink" href="#initialized-by-procedure-call" title="Permalink to this headline">¶</a></h5>
<p>In this example, the abstract state declared at the specification is refined at the body.
Procedure <cite>Init</cite> can be invoked by users of the package, in order to initialize the state.</p>
<p>Specification in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Stack_05</span>
<span class="c">--# own State;</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Push</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--# global in out State;</span>

   <span class="k">procedure </span><span class="nf">Pop</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--# global in out State;</span>

   <span class="k">procedure </span><span class="nf">Init</span><span class="p">;</span>
   <span class="c">--# global    out State;</span>

<span class="k">end </span><span class="nf">Stack_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Stack_05</span>
<span class="c">--# own State is S, Pointer;</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">Stack_Size</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="o">:=</span> <span class="mi">100</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Pointer_Range</span> <span class="kr">is</span><span class="p"> </span><span class="kr">range</span><span class="p"> </span><span class="mi">0</span> <span class="o">..</span> <span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">subtype</span><span class="p"> </span><span class="n">Index_Range</span>   <span class="kr">is</span><span class="p"> </span><span class="n">Pointer_Range</span> <span class="kr">range</span><span class="p"> </span><span class="mi">1</span><span class="o">..</span><span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Vector</span>        <span class="kr">is</span><span class="p"> </span><span class="n">array</span><span class="o">(</span><span class="n">Index_Range</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>

   <span class="n">Pointer</span> <span class="o">:</span> <span class="n">Pointer_Range</span><span class="p">;</span>
   <span class="n">S</span>       <span class="o">:</span> <span class="n">Vector</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Push</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
   <span class="c">--# global in out Pointer, S;</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Pointer</span> <span class="o">:=</span> <span class="n">Pointer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">S</span><span class="o">(</span><span class="n">Pointer</span><span class="o">)</span> <span class="o">:=</span> <span class="n">X</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Push</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Pop</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
   <span class="c">--# global in     S;</span>
   <span class="c">--#        in out Pointer;</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">X</span> <span class="o">:=</span> <span class="n">S</span><span class="o">(</span><span class="n">Pointer</span><span class="o">)</span><span class="p">;</span>
      <span class="n">Pointer</span> <span class="o">:=</span> <span class="n">Pointer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Pop</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Init</span>
   <span class="c">--# global    out Pointer, S;</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Pointer</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">S</span> <span class="o">:=</span> <span class="n">Vector</span><span class="o">&#39;(</span><span class="n">Index_Range</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">)</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Init</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Stack_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specification in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Stack_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="n">State</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Push</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Pop</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Init</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Stack_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Stack_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Pointer</span><span class="p">,</span> <span class="n">S</span><span class="o">))</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">Stack_Size</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="o">:=</span> <span class="mi">100</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Pointer_Range</span> <span class="kr">is</span><span class="p"> </span><span class="kr">range</span><span class="p"> </span><span class="mi">0</span> <span class="o">..</span> <span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">subtype</span><span class="p"> </span><span class="n">Index_Range</span>   <span class="kr">is</span><span class="p"> </span><span class="n">Pointer_Range</span> <span class="kr">range</span><span class="p"> </span><span class="mi">1</span><span class="o">..</span><span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Vector</span>        <span class="kr">is</span><span class="p"> </span><span class="n">array</span><span class="o">(</span><span class="n">Index_Range</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>

   <span class="n">Pointer</span> <span class="o">:</span> <span class="n">Pointer_Range</span><span class="p">;</span>
   <span class="n">S</span>       <span class="o">:</span> <span class="n">Vector</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Push</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Pointer</span><span class="p">,</span> <span class="n">S</span><span class="o">))</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Pointer</span> <span class="o">:=</span> <span class="n">Pointer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">S</span> <span class="o">(</span><span class="n">Pointer</span><span class="o">)</span> <span class="o">:=</span> <span class="n">X</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Push</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Pop</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">Pointer</span><span class="p">,</span>
                             <span class="n">Input</span>  <span class="o">=&gt;</span> <span class="n">S</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">X</span> <span class="o">:=</span> <span class="n">S</span> <span class="o">(</span><span class="n">Pointer</span><span class="o">)</span><span class="p">;</span>
      <span class="n">Pointer</span> <span class="o">:=</span> <span class="n">Pointer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Pop</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Init</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Pointer</span><span class="p">,</span> <span class="n">S</span><span class="o">))</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Pointer</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">S</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Index_Range</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">)</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Init</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Stack_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="initialized-by-elaboration-of-declaration">
<span id="ms-asm-private-abstract-bodyref-elaborationinit-label"></span><h5>Initialized by elaboration of declaration<a class="headerlink" href="#initialized-by-elaboration-of-declaration" title="Permalink to this headline">¶</a></h5>
<p>The example that follows introduces an abstract state at the specification and refines it
at the body. The constituents of the abstract state are initialized at declaration.</p>
<p>Specification in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Stack_05</span>
<span class="c">--# own State;</span>
<span class="c">--# initializes State;</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Push</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--# global in out State;</span>

   <span class="k">procedure </span><span class="nf">Pop</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--# global in out State;</span>

<span class="k">end </span><span class="nf">Stack_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Stack_05</span>
<span class="c">--# own State is Pointer, S; -- refinement of state</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">Stack_Size</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="o">:=</span> <span class="mi">100</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Pointer_Range</span> <span class="kr">is</span><span class="p"> </span><span class="kr">range</span><span class="p"> </span><span class="mi">0</span> <span class="o">..</span> <span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">subtype</span><span class="p"> </span><span class="n">Index_Range</span>   <span class="kr">is</span><span class="p"> </span><span class="n">Pointer_Range</span> <span class="kr">range</span><span class="p"> </span><span class="mi">1</span><span class="o">..</span><span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Vector</span>        <span class="kr">is</span><span class="p"> </span><span class="n">array</span><span class="o">(</span><span class="n">Index_Range</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>

   <span class="n">S</span> <span class="o">:</span> <span class="n">Vector</span> <span class="o">:=</span> <span class="n">Vector</span><span class="o">&#39;(</span><span class="kr">others</span><span class="p"> </span><span class="o">=&gt;</span> <span class="mi">0</span><span class="o">)</span><span class="p">;</span>
   <span class="n">Pointer</span> <span class="o">:</span> <span class="n">Pointer_Range</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="c">-- initialization by elaboration of declaration</span>

   <span class="k">procedure </span><span class="nf">Push</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
   <span class="c">--# global in out Pointer, S;</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Pointer</span> <span class="o">:=</span> <span class="n">Pointer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">S</span><span class="o">(</span><span class="n">Pointer</span><span class="o">)</span> <span class="o">:=</span> <span class="n">X</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Push</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Pop</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
   <span class="c">--# global in     S;</span>
   <span class="c">--#        in out Pointer;</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">X</span> <span class="o">:=</span> <span class="n">S</span><span class="o">(</span><span class="n">Pointer</span><span class="o">)</span><span class="p">;</span>
      <span class="n">Pointer</span> <span class="o">:=</span> <span class="n">Pointer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Pop</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Stack_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specification in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Stack_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="p">,</span>
       <span class="n">Initializes</span>    <span class="o">=&gt;</span> <span class="n">State</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Push</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Pop</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Stack_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Stack_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Pointer</span><span class="p">,</span> <span class="n">S</span><span class="o">))</span> <span class="c">-- refinement of state</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">Stack_Size</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="o">:=</span> <span class="mi">100</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Pointer_Range</span> <span class="kr">is</span><span class="p"> </span><span class="kr">range</span><span class="p"> </span><span class="mi">0</span> <span class="o">..</span> <span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">subtype</span><span class="p"> </span><span class="n">Index_Range</span>   <span class="kr">is</span><span class="p"> </span><span class="n">Pointer_Range</span> <span class="kr">range</span><span class="p"> </span><span class="mi">1</span><span class="o">..</span><span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Vector</span>        <span class="kr">is</span><span class="p"> </span><span class="n">array</span><span class="o">(</span><span class="n">Index_Range</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>

   <span class="n">S</span> <span class="o">:</span> <span class="n">Vector</span> <span class="o">:=</span> <span class="o">(</span><span class="kr">others</span><span class="p"> </span><span class="o">=&gt;</span> <span class="mi">0</span><span class="o">)</span><span class="p">;</span>
   <span class="n">Pointer</span> <span class="o">:</span> <span class="n">Pointer_Range</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="c">-- initialization by elaboration of declaration</span>

   <span class="k">procedure </span><span class="nf">Push</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Pointer</span><span class="p">,</span> <span class="n">S</span><span class="o">))</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Pointer</span> <span class="o">:=</span> <span class="n">Pointer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">S</span> <span class="o">(</span><span class="n">Pointer</span><span class="o">)</span> <span class="o">:=</span> <span class="n">X</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Push</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Pop</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">Pointer</span><span class="p">,</span>
                             <span class="n">Input</span>  <span class="o">=&gt;</span> <span class="n">S</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">X</span> <span class="o">:=</span> <span class="n">S</span> <span class="o">(</span><span class="n">Pointer</span><span class="o">)</span><span class="p">;</span>
      <span class="n">Pointer</span> <span class="o">:=</span> <span class="n">Pointer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Pop</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Stack_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="initialized-by-package-body-statements">
<span id="ms-asm-private-abstract-bodyref-statementinit-label"></span><h5>Initialized by package body statements<a class="headerlink" href="#initialized-by-package-body-statements" title="Permalink to this headline">¶</a></h5>
<p>This example introduces an abstract state at the specification and refines it at the body.
The constituents of the abstract state are initialized at the statements part of the body.
The specifications of the SPARK 2005 and SPARK 2014 versions of the code are as in the previous
example and have thus not been included.</p>
<p>Body in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Stack_05</span>
<span class="c">--# own State is Pointer, S;  -- refinement of state</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">Stack_Size</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="o">:=</span> <span class="mi">100</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Pointer_Range</span> <span class="kr">is</span><span class="p"> </span><span class="kr">range</span><span class="p"> </span><span class="mi">0</span> <span class="o">..</span> <span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">subtype</span><span class="p"> </span><span class="n">Index_Range</span>   <span class="kr">is</span><span class="p"> </span><span class="n">Pointer_Range</span> <span class="kr">range</span><span class="p"> </span><span class="mi">1</span><span class="o">..</span><span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Vector</span>        <span class="kr">is</span><span class="p"> </span><span class="n">array</span><span class="o">(</span><span class="n">Index_Range</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>

   <span class="n">S</span> <span class="o">:</span> <span class="n">Vector</span><span class="p">;</span>
   <span class="n">Pointer</span> <span class="o">:</span> <span class="n">Pointer_Range</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Push</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
   <span class="c">--# global in out Pointer, S;</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Pointer</span> <span class="o">:=</span> <span class="n">Pointer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">S</span><span class="o">(</span><span class="n">Pointer</span><span class="o">)</span> <span class="o">:=</span> <span class="n">X</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Push</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Pop</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
   <span class="c">--# global in out Pointer;</span>
   <span class="c">--#        in     S;</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">X</span> <span class="o">:=</span> <span class="n">S</span><span class="o">(</span><span class="n">Pointer</span><span class="o">)</span><span class="p">;</span>
      <span class="n">Pointer</span> <span class="o">:=</span> <span class="n">Pointer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Pop</span><span class="p">;</span>
<span class="kr">begin</span><span class="p"> </span> <span class="c">-- initialized by package body statements</span>
   <span class="n">Pointer</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="n">S</span> <span class="o">:=</span> <span class="n">Vector</span><span class="o">&#39;(</span><span class="n">Index_Range</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Stack_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Stack_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Pointer</span><span class="p">,</span> <span class="n">S</span><span class="o">))</span>  <span class="c">-- refinement of state</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">Stack_Size</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="o">:=</span> <span class="mi">100</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Pointer_Range</span> <span class="kr">is</span><span class="p"> </span><span class="kr">range</span><span class="p"> </span><span class="mi">0</span> <span class="o">..</span> <span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">subtype</span><span class="p"> </span><span class="n">Index_Range</span>   <span class="kr">is</span><span class="p"> </span><span class="n">Pointer_Range</span> <span class="kr">range</span><span class="p"> </span><span class="mi">1</span><span class="o">..</span><span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Vector</span>        <span class="kr">is</span><span class="p"> </span><span class="n">array</span><span class="o">(</span><span class="n">Index_Range</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>

   <span class="n">S</span>       <span class="o">:</span> <span class="n">Vector</span><span class="p">;</span>
   <span class="n">Pointer</span> <span class="o">:</span> <span class="n">Pointer_Range</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Push</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Pointer</span><span class="p">,</span> <span class="n">S</span><span class="o">))</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Pointer</span> <span class="o">:=</span> <span class="n">Pointer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">S</span> <span class="o">(</span><span class="n">Pointer</span><span class="o">)</span> <span class="o">:=</span> <span class="n">X</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Push</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Pop</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">Pointer</span><span class="p">,</span>
                             <span class="n">Input</span>  <span class="o">=&gt;</span> <span class="n">S</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">X</span> <span class="o">:=</span> <span class="n">S</span> <span class="o">(</span><span class="n">Pointer</span><span class="o">)</span><span class="p">;</span>
      <span class="n">Pointer</span> <span class="o">:=</span> <span class="n">Pointer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Pop</span><span class="p">;</span>
<span class="kr">begin</span><span class="p"></span>
   <span class="c">-- initialized by package body statements</span>
   <span class="n">Pointer</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="n">S</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Index_Range</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Stack_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="initialized-by-mixture-of-declaration-and-statements">
<span id="ms-asm-private-abstract-bodyref-mixedinit-label"></span><h5>Initialized by mixture of declaration and statements<a class="headerlink" href="#initialized-by-mixture-of-declaration-and-statements" title="Permalink to this headline">¶</a></h5>
<p>This example introduces an abstract state at the specification and refines it at the body.
Some of the constituents of the abstract state are initialized during their declaration and
the rest at the statements part of the body.</p>
<p>Specification in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Stack_05</span>
<span class="c">--# own Stack;</span>
<span class="c">--# initializes Stack;</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Push</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--# global in out Stack;</span>

   <span class="k">procedure </span><span class="nf">Pop</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--# global in out Stack;</span>

<span class="k">end </span><span class="nf">Stack_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Stack_05</span>
<span class="c">--# own Stack is S, Pointer; -- state refinement</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">Stack_Size</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="o">:=</span> <span class="mi">100</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Pointer_Range</span> <span class="kr">is</span><span class="p"> </span><span class="kr">range</span><span class="p"> </span><span class="mi">0</span> <span class="o">..</span> <span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">subtype</span><span class="p"> </span><span class="n">Index_Range</span>   <span class="kr">is</span><span class="p"> </span><span class="n">Pointer_Range</span> <span class="kr">range</span><span class="p"> </span><span class="mi">1</span><span class="o">..</span><span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Vector</span>        <span class="kr">is</span><span class="p"> </span><span class="n">array</span><span class="o">(</span><span class="n">Index_Range</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>
   <span class="n">S</span> <span class="o">:</span> <span class="n">Vector</span><span class="p">;</span>

   <span class="n">Pointer</span> <span class="o">:</span> <span class="n">Pointer_Range</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="c">-- initialization by elaboration of declaration</span>

   <span class="k">procedure </span><span class="nf">Push</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
   <span class="c">--# global in out S, Pointer;</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Pointer</span> <span class="o">:=</span> <span class="n">Pointer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">S</span><span class="o">(</span><span class="n">Pointer</span><span class="o">)</span> <span class="o">:=</span> <span class="n">X</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Push</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Pop</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
   <span class="c">--# global in     S;</span>
   <span class="c">--#        in out Pointer;</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">X</span> <span class="o">:=</span> <span class="n">S</span><span class="o">(</span><span class="n">Pointer</span><span class="o">)</span><span class="p">;</span>
      <span class="n">Pointer</span> <span class="o">:=</span> <span class="n">Pointer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Pop</span><span class="p">;</span>
<span class="kr">begin</span><span class="p"> </span> <span class="c">-- initialization by body statements</span>
   <span class="n">S</span> <span class="o">:=</span> <span class="n">Vector</span><span class="o">&#39;(</span><span class="n">Index_Range</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Stack_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specification in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Stack_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="n">Stack</span><span class="p">,</span>
       <span class="n">Initializes</span>    <span class="o">=&gt;</span> <span class="n">Stack</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Push</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">Stack</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Pop</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">Stack</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Stack_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Stack_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Stack</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">S</span><span class="p">,</span> <span class="n">Pointer</span><span class="o">))</span> <span class="c">-- state refinement</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">Stack_Size</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="o">:=</span> <span class="mi">100</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Pointer_Range</span> <span class="kr">is</span><span class="p"> </span><span class="kr">range</span><span class="p"> </span><span class="mi">0</span> <span class="o">..</span> <span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">subtype</span><span class="p"> </span><span class="n">Index_Range</span>   <span class="kr">is</span><span class="p"> </span><span class="n">Pointer_Range</span> <span class="kr">range</span><span class="p"> </span><span class="mi">1</span><span class="o">..</span><span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Vector</span>        <span class="kr">is</span><span class="p"> </span><span class="n">array</span><span class="o">(</span><span class="n">Index_Range</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>

   <span class="n">S</span>       <span class="o">:</span> <span class="n">Vector</span><span class="p">;</span> <span class="c">-- left uninitialized</span>
   <span class="n">Pointer</span> <span class="o">:</span> <span class="n">Pointer_Range</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="c">-- initialization by elaboration of declaration</span>

   <span class="k">procedure </span><span class="nf">Push</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">S</span><span class="p">,</span> <span class="n">Pointer</span><span class="o">))</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Pointer</span> <span class="o">:=</span> <span class="n">Pointer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">S</span> <span class="o">(</span><span class="n">Pointer</span><span class="o">)</span> <span class="o">:=</span> <span class="n">X</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Push</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Pop</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span>  <span class="o">=&gt;</span> <span class="n">S</span><span class="p">,</span>
                             <span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">Pointer</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">X</span> <span class="o">:=</span> <span class="n">S</span> <span class="o">(</span><span class="n">Pointer</span><span class="o">)</span><span class="p">;</span>
      <span class="n">Pointer</span> <span class="o">:=</span> <span class="n">Pointer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Pop</span><span class="p">;</span>
<span class="kr">begin</span><span class="p"></span>
   <span class="c">-- partial initialization by body statements</span>
   <span class="n">S</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Index_Range</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Stack_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
</div>
<div class="section" id="initial-condition">
<span id="ms-asm-initial-condition-label"></span><h4>Initial condition<a class="headerlink" href="#initial-condition" title="Permalink to this headline">¶</a></h4>
<p>This example introduces a new SPARK 2014 feature that did not exist in
SPARK 2005. On top of declaring an abstract state and promising to
initialize it, we also illustrate certain conditions that will be
valid after initialization. There is a verification condition to show that
immediately after the elaboration of the package that the specified
Initial_Condition is True. Checks will be generated that have to be
proven (or executed at run-time) to show that the initial condition is
True.</p>
<p>Specification in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Stack_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span>    <span class="o">=&gt;</span> <span class="n">State</span><span class="p">,</span>
       <span class="n">Initializes</span>       <span class="o">=&gt;</span> <span class="n">State</span><span class="p">,</span>
       <span class="n">Initial_Condition</span> <span class="o">=&gt;</span> <span class="n">Is_Empty</span>  <span class="c">-- Stating that Is_Empty holds</span>
                                      <span class="c">-- after initialization</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">Is_Empty</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Is_Full</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Top</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="p">,</span>
          <span class="n">Pre</span>    <span class="o">=&gt;</span> <span class="kr">not</span><span class="p"> </span><span class="n">Is_Empty</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Push</span> <span class="o">(</span><span class="n">X</span><span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Pre</span>    <span class="o">=&gt;</span> <span class="kr">not</span><span class="p"> </span><span class="n">Is_Full</span><span class="p">,</span>
          <span class="n">Post</span>   <span class="o">=&gt;</span> <span class="n">Top</span> <span class="o">=</span> <span class="n">X</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Pop</span> <span class="o">(</span><span class="n">X</span><span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Pre</span>    <span class="o">=&gt;</span> <span class="kr">not</span><span class="p"> </span><span class="n">Is_Empty</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Stack_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Stack_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">S</span><span class="p">,</span>
                                   <span class="n">Pointer</span><span class="o">))</span> <span class="c">-- State refinement</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">Max_Stack_Size</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="o">:=</span> <span class="mi">1024</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span><span class="n">Pointer_Range</span> <span class="kr">is</span><span class="p"> </span><span class="kr">range</span><span class="p"> </span><span class="mi">0</span> <span class="o">..</span> <span class="n">Max_Stack_Size</span><span class="p">;</span>
   <span class="kr">subtype</span><span class="p"> </span><span class="n">Index_Range</span> <span class="kr">is</span><span class="p"> </span><span class="n">Pointer_Range</span> <span class="kr">range</span><span class="p"> </span><span class="mi">1</span> <span class="o">..</span> <span class="n">Max_Stack_Size</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span><span class="n">Vector</span> <span class="kr">is</span><span class="p"> </span><span class="kr">array</span><span class="p"> </span><span class="o">(</span><span class="n">Index_Range</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>

   <span class="c">-- Declaration of constituents</span>
   <span class="n">S</span>       <span class="o">:</span> <span class="n">Vector</span><span class="p">;</span>
   <span class="n">Pointer</span> <span class="o">:</span> <span class="n">Pointer_Range</span><span class="p">;</span>

   <span class="c">-- The subprogram contracts are refined in terms of the constituents.</span>
   <span class="c">-- Expression functions could be used where applicable</span>

   <span class="k">function </span><span class="nf">Is_Empty</span>  <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">Pointer</span> <span class="o">=</span> <span class="mi">0</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="n">Pointer</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Is_Full</span>  <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">Pointer</span> <span class="o">=</span> <span class="n">Max_Stack_Size</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="n">Pointer</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Top</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">S</span> <span class="o">(</span><span class="n">Pointer</span><span class="o">))</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Pointer</span><span class="p">,</span> <span class="n">S</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Push</span><span class="o">(</span><span class="n">X</span><span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Pointer</span><span class="p">,</span> <span class="n">S</span><span class="o">))</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Pointer</span> <span class="o">:=</span> <span class="n">Pointer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">S</span> <span class="o">(</span><span class="n">Pointer</span><span class="o">)</span> <span class="o">:=</span> <span class="n">X</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Push</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Pop</span><span class="o">(</span><span class="n">X</span><span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span>  <span class="o">=&gt;</span> <span class="n">S</span><span class="p">,</span>
                             <span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">Pointer</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">X</span> <span class="o">:=</span> <span class="n">S</span> <span class="o">(</span><span class="n">Pointer</span><span class="o">)</span><span class="p">;</span>
      <span class="n">Pointer</span> <span class="o">:=</span> <span class="n">Pointer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Pop</span><span class="p">;</span>
<span class="kr">begin</span><span class="p"></span>
   <span class="c">-- Initialization - we promised to initialize the state</span>
   <span class="c">-- and that initially the stack will be empty</span>
   <span class="n">Pointer</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c">-- Is_Empty is True.</span>
   <span class="n">S</span> <span class="o">:=</span> <span class="n">Vector</span><span class="o">&#39;(</span><span class="n">Index_Range</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Stack_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="private-abstract-state-refining-onto-state-of-private-child">
<span id="ms-asm-abstract-state-refined-in-private-child-label"></span><h4>Private, abstract state, refining onto state of private child<a class="headerlink" href="#private-abstract-state-refining-onto-state-of-private-child" title="Permalink to this headline">¶</a></h4>
<p>The following example shows a parent package Power that contains an
own variable (a state abstraction). This state abstraction is refined
onto state abstractions of two private children Source_A and Source_B.</p>
<p>Specification of Parent in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">-- Use of child packages to encapsulate state</span>
<span class="k">package </span><span class="nf">Power_05</span>
<span class="c">--# own State;</span>
<span class="c">--# initializes State;</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Read_Power</span><span class="o">(</span><span class="n">Level</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--# global State;</span>
   <span class="c">--# derives Level from State;</span>
<span class="k">end </span><span class="nf">Power_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body of Parent in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">Power_05.Source_A_05</span><span class="p">,</span> <span class="n">Power_05.Source_B_05</span><span class="p">;</span>

<span class="k">package body </span><span class="nf">Power_05</span>
<span class="c">--# own State is Power_05.Source_A_05.State,</span>
<span class="c">--#              Power_05.Source_B_05.State;</span>
<span class="kr">is</span><span class="p"></span>

  <span class="k">procedure </span><span class="nf">Read_Power</span><span class="o">(</span><span class="n">Level</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
  <span class="c">--# global Source_A_05.State, Source_B_05.State;</span>
  <span class="c">--# derives</span>
  <span class="c">--#     Level</span>
  <span class="c">--#     from</span>
  <span class="c">--#         Source_A_05.State,</span>
  <span class="c">--#         Source_B_05.State;</span>
  <span class="kr">is</span><span class="p"></span>
     <span class="n">Level_A</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
     <span class="n">Level_B</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
  <span class="kr">begin</span><span class="p"></span>
     <span class="n">Source_A_05.Read</span> <span class="o">(</span><span class="n">Level_A</span><span class="o">)</span><span class="p">;</span>
     <span class="n">Source_B_05.Read</span> <span class="o">(</span><span class="n">Level_B</span><span class="o">)</span><span class="p">;</span>
     <span class="n">Level</span> <span class="o">:=</span> <span class="n">Level_A</span> <span class="o">+</span> <span class="n">Level_B</span><span class="p">;</span>
  <span class="k">end </span><span class="nf">Read_Power</span><span class="p">;</span>

<span class="k">end </span><span class="nf">Power_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specifications of Private Children in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">--# inherit Power_05;</span>
<span class="kr">private</span><span class="p"> </span><span class="k">package </span><span class="nf">Power_05.Source_A_05</span>
<span class="c">--# own State;</span>
<span class="c">--# initializes State;</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Read</span> <span class="o">(</span><span class="n">Level</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--# global State;</span>
   <span class="c">--# derives Level from State;</span>
<span class="k">end </span><span class="nf">Power_05.Source_A_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">--# inherit Power_05;</span>
<span class="kr">private</span><span class="p"> </span><span class="k">package </span><span class="nf">Power_05.Source_B_05</span>
<span class="c">--# own State;</span>
<span class="c">--# initializes State;</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Read</span> <span class="o">(</span><span class="n">Level</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--# global State;</span>
   <span class="c">--# derives Level from State;</span>
<span class="k">end </span><span class="nf">Power_05.Source_B_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Bodies of Private Children in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Power_05.Source_A_05</span>
<span class="c">--# own State is S;</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">S</span> <span class="o">:</span> <span class="n">Integer</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Read</span> <span class="o">(</span><span class="n">Level</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
   <span class="c">--# global in S;</span>
   <span class="c">--# derives Level from S;</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Level</span> <span class="o">:=</span> <span class="n">S</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Read</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Power_05.Source_A_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Power_05.Source_B_05</span>
<span class="c">--# own State is S;</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">S</span> <span class="o">:</span> <span class="n">Integer</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Read</span> <span class="o">(</span><span class="n">Level</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
   <span class="c">--# global in S;</span>
   <span class="c">--# derives Level from S;</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Level</span> <span class="o">:=</span> <span class="n">S</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Read</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Power_05.Source_B_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specification of Parent in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">-- Use of child packages to encapsulate state</span>
<span class="k">package </span><span class="nf">Power_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="p">,</span>
       <span class="n">Initializes</span>    <span class="o">=&gt;</span> <span class="n">State</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Read_Power</span><span class="o">(</span><span class="n">Level</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="n">State</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Level</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Power_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body of Parent in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">Power_14.Source_A_14</span><span class="p">,</span>
     <span class="n">Power_14.Source_B_14</span><span class="p">;</span>

<span class="k">package body </span><span class="nf">Power_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Power_14.Source_A_14.State</span><span class="p">,</span>
                                   <span class="n">Power_14.Source_B_14.State</span><span class="o">))</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Read_Power</span><span class="o">(</span><span class="n">Level</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Source_A_14.State</span><span class="p">,</span> <span class="n">Source_B_14.State</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Refined_Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Level</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Source_A_14.State</span><span class="p">,</span>
                                        <span class="n">Source_B_14.State</span><span class="o">))</span>
   <span class="kr">is</span><span class="p"></span>
      <span class="n">Level_A</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
      <span class="n">Level_B</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Source_A_14.Read</span> <span class="o">(</span><span class="n">Level_A</span><span class="o">)</span><span class="p">;</span>
      <span class="n">Source_B_14.Read</span> <span class="o">(</span><span class="n">Level_B</span><span class="o">)</span><span class="p">;</span>
      <span class="n">Level</span> <span class="o">:=</span> <span class="n">Level_A</span> <span class="o">+</span> <span class="n">Level_B</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Read_Power</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Power_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specifications of Private Children in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">private</span><span class="p"> </span><span class="k">package </span><span class="nf">Power_14.Source_A_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State</span> <span class="kr">with</span><span class="p"> </span><span class="n">Part_Of</span> <span class="o">=&gt;</span><span class="n">Power_14.State</span><span class="o">)</span><span class="p">,</span>
       <span class="n">Initializes</span>    <span class="o">=&gt;</span> <span class="n">State</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Read</span> <span class="o">(</span><span class="n">Level</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Level</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Power_14.Source_A_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">private</span><span class="p"> </span><span class="k">package </span><span class="nf">Power_14.Source_B_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State</span> <span class="kr">with</span><span class="p"> </span><span class="n">Part_Of</span> <span class="o">=&gt;</span> <span class="n">Power_14.State</span><span class="o">)</span><span class="p">,</span>
       <span class="n">Initializes</span>    <span class="o">=&gt;</span> <span class="n">State</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Read</span> <span class="o">(</span><span class="n">Level</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="n">State</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Level</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Power_14.Source_B_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Bodies of Private Children in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Power_14.Source_A_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State</span> <span class="o">=&gt;</span> <span class="n">S</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">S</span> <span class="o">:</span> <span class="n">Integer</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Read</span> <span class="o">(</span><span class="n">Level</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span> <span class="o">=&gt;</span> <span class="n">S</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Refined_Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Level</span> <span class="o">=&gt;</span> <span class="n">S</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Level</span> <span class="o">:=</span> <span class="n">S</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Read</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Power_14.Source_A_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Power_14.Source_B_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State</span> <span class="o">=&gt;</span> <span class="n">S</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">S</span> <span class="o">:</span> <span class="n">Integer</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Read</span> <span class="o">(</span><span class="n">Level</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span> <span class="o">=&gt;</span> <span class="n">S</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Refined_Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Level</span> <span class="o">=&gt;</span> <span class="n">S</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Level</span> <span class="o">:=</span> <span class="n">S</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Read</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Power_14.Source_B_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="private-abstract-state-refining-onto-concrete-state-of-embedded-package">
<span id="ms-asm-abstract-state-refined-in-embedded-package-label"></span><h4>Private, abstract state, refining onto concrete state of embedded package<a class="headerlink" href="#private-abstract-state-refining-onto-concrete-state-of-embedded-package" title="Permalink to this headline">¶</a></h4>
<p>This example is based around the packages from section
<a class="reference internal" href="#ms-asm-abstract-state-refined-in-embedded-package-label"><span class="std std-ref">Private, abstract state, refining onto concrete state of embedded package</span></a>,
with the private child packages converted into embedded packages and
the refinement onto concrete visible state.</p>
<p>Specification in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">-- Use of embedded packages to encapsulate state</span>
<span class="k">package </span><span class="nf">Power_05</span>
<span class="c">--# own State;</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Read_Power</span><span class="o">(</span><span class="n">Level</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--# global State;</span>
   <span class="c">--# derives Level from State;</span>
<span class="k">end </span><span class="nf">Power_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Power_05</span>
<span class="c">--# own State is Source_A.State,</span>
<span class="c">--#              Source_B.State;</span>
<span class="kr">is</span><span class="p"></span>

  <span class="c">--  Embedded package spec for Source_A</span>
  <span class="k">package </span><span class="nf">Source_A</span>
  <span class="c">--# own State;</span>
  <span class="kr">is</span><span class="p"></span>
     <span class="k">procedure </span><span class="nf">Read</span> <span class="o">(</span><span class="n">Level</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
      <span class="c">--# global State;</span>
      <span class="c">--# derives Level from State;</span>
  <span class="k">end </span><span class="nf">Source_A</span><span class="p">;</span>

  <span class="c">--  Embedded package spec for Source_B.</span>
  <span class="k">package </span><span class="nf">Source_B</span>
  <span class="c">--# own State;</span>
  <span class="kr">is</span><span class="p"></span>
    <span class="k">procedure </span><span class="nf">Read</span> <span class="o">(</span><span class="n">Level</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
    <span class="c">--# global State;</span>
    <span class="c">--# derives Level from State;</span>
  <span class="k">end </span><span class="nf">Source_B</span><span class="p">;</span>

  <span class="c">--  Embedded package body for Source_A</span>
  <span class="k">package body </span><span class="nf">Source_A</span>
  <span class="kr">is</span><span class="p"></span>
    <span class="n">State</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>

    <span class="k">procedure </span><span class="nf">Read</span> <span class="o">(</span><span class="n">Level</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
    <span class="kr">is</span><span class="p"></span>
    <span class="kr">begin</span><span class="p"></span>
      <span class="n">Level</span> <span class="o">:=</span> <span class="n">State</span><span class="p">;</span>
    <span class="k">end </span><span class="nf">Read</span><span class="p">;</span>
  <span class="k">end </span><span class="nf">Source_A</span><span class="p">;</span>

  <span class="c">--  Embedded package body for Source_B</span>
  <span class="k">package body </span><span class="nf">Source_B</span>
  <span class="kr">is</span><span class="p"></span>
    <span class="n">State</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>

    <span class="k">procedure </span><span class="nf">Read</span> <span class="o">(</span><span class="n">Level</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
    <span class="kr">is</span><span class="p"></span>
    <span class="kr">begin</span><span class="p"></span>
      <span class="n">Level</span> <span class="o">:=</span> <span class="n">State</span><span class="p">;</span>
    <span class="k">end </span><span class="nf">Read</span><span class="p">;</span>

  <span class="k">end </span><span class="nf">Source_B</span><span class="p">;</span>

  <span class="k">procedure </span><span class="nf">Read_Power</span><span class="o">(</span><span class="n">Level</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
  <span class="c">--# global Source_A.State, Source_B.State;</span>
  <span class="c">--# derives</span>
  <span class="c">--#     Level</span>
  <span class="c">--#     from</span>
  <span class="c">--#         Source_A.State,</span>
  <span class="c">--#         Source_B.State;</span>
  <span class="kr">is</span><span class="p"></span>
     <span class="n">Level_A</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
     <span class="n">Level_B</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
  <span class="kr">begin</span><span class="p"></span>
     <span class="n">Source_A.</span> <span class="n">Read</span> <span class="o">(</span><span class="n">Level_A</span><span class="o">)</span><span class="p">;</span>
     <span class="n">Source_B.Read</span> <span class="o">(</span><span class="n">Level_B</span><span class="o">)</span><span class="p">;</span>
     <span class="n">Level</span> <span class="o">:=</span> <span class="n">Level_A</span> <span class="o">+</span> <span class="n">Level_B</span><span class="p">;</span>
  <span class="k">end </span><span class="nf">Read_Power</span><span class="p">;</span>

<span class="k">end </span><span class="nf">Power_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specification in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">-- Use of embedded packages to encapsulate state</span>
<span class="k">package </span><span class="nf">Power_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="p">,</span>
       <span class="n">Initializes</span>    <span class="o">=&gt;</span> <span class="n">State</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Read_Power</span><span class="o">(</span><span class="n">Level</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="n">State</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Level</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Power_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Power_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Source_A.State</span><span class="p">,</span>
                                   <span class="n">Source_B.State</span><span class="o">))</span>
<span class="kr">is</span><span class="p"></span>
   <span class="c">--  Embedded package spec for Source_A</span>
   <span class="k">package </span><span class="nf">Source_A</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Initializes</span> <span class="o">=&gt;</span> <span class="n">State</span>
   <span class="kr">is</span><span class="p"></span>
      <span class="n">State</span> <span class="o">:</span> <span class="n">Integer</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>

      <span class="k">procedure </span><span class="nf">Read</span> <span class="o">(</span><span class="n">Level</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
        <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="n">State</span><span class="p">,</span>
             <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Level</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Source_A</span><span class="p">;</span>

   <span class="c">--  Embedded package spec for Source_B.</span>
   <span class="k">package </span><span class="nf">Source_B</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Initializes</span> <span class="o">=&gt;</span> <span class="n">State</span>
   <span class="kr">is</span><span class="p"></span>
      <span class="n">State</span> <span class="o">:</span> <span class="n">Integer</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>

      <span class="k">procedure </span><span class="nf">Read</span> <span class="o">(</span><span class="n">Level</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
        <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="n">State</span><span class="p">,</span>
             <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Level</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Source_B</span><span class="p">;</span>

   <span class="c">--  Embedded package body for Source_A</span>
   <span class="k">package body </span><span class="nf">Source_A</span> <span class="kr">is</span><span class="p"></span>
      <span class="k">procedure </span><span class="nf">Read</span> <span class="o">(</span><span class="n">Level</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span> <span class="kr">is</span><span class="p"></span>
      <span class="kr">begin</span><span class="p"></span>
         <span class="n">Level</span> <span class="o">:=</span> <span class="n">State</span><span class="p">;</span>
      <span class="k">end </span><span class="nf">Read</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Source_A</span><span class="p">;</span>

   <span class="c">--  Embedded package body for Source_B</span>
   <span class="k">package body </span><span class="nf">Source_B</span> <span class="kr">is</span><span class="p"></span>
      <span class="k">procedure </span><span class="nf">Read</span> <span class="o">(</span><span class="n">Level</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span> <span class="kr">is</span><span class="p"></span>
      <span class="kr">begin</span><span class="p"></span>
         <span class="n">Level</span> <span class="o">:=</span> <span class="n">State</span><span class="p">;</span>
      <span class="k">end </span><span class="nf">Read</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Source_B</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Read_Power</span><span class="o">(</span><span class="n">Level</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Source_A.State</span><span class="p">,</span>
                              <span class="n">Source_B.State</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Refined_Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Level</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Source_A.State</span><span class="p">,</span>
                                        <span class="n">Source_B.State</span><span class="o">))</span>
   <span class="kr">is</span><span class="p"></span>
      <span class="n">Level_A</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
      <span class="n">Level_B</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Source_A.</span> <span class="n">Read</span> <span class="o">(</span><span class="n">Level_A</span><span class="o">)</span><span class="p">;</span>
      <span class="n">Source_B.Read</span> <span class="o">(</span><span class="n">Level_B</span><span class="o">)</span><span class="p">;</span>
      <span class="n">Level</span> <span class="o">:=</span> <span class="n">Level_A</span> <span class="o">+</span> <span class="n">Level_B</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Read_Power</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Power_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="private-abstract-state-refining-onto-mixture-of-the-above">
<span id="ms-asm-abstract-state-refined-in-embedded-and-private-child-label"></span><h4>Private, abstract state, refining onto mixture of the above<a class="headerlink" href="#private-abstract-state-refining-onto-mixture-of-the-above" title="Permalink to this headline">¶</a></h4>
<p>This example is based around the packages from sections
<a class="reference internal" href="#ms-asm-abstract-state-refined-in-private-child-label"><span class="std std-ref">Private, abstract state, refining onto state of private child</span></a>
and <a class="reference internal" href="#ms-asm-abstract-state-refined-in-embedded-package-label"><span class="std std-ref">Private, abstract state, refining onto concrete state of embedded package</span></a>.
Source_A is an embedded package, while Source_B is a private child. In order to
avoid repetition, the code of this example is not being presented.</p>
</div>
</div>
<div class="section" id="external-variables">
<h3>External Variables<a class="headerlink" href="#external-variables" title="Permalink to this headline">¶</a></h3>
<div class="section" id="basic-input-and-output-device-drivers">
<span id="ms-external-variables-input-output-label"></span><h4>Basic Input and Output Device Drivers<a class="headerlink" href="#basic-input-and-output-device-drivers" title="Permalink to this headline">¶</a></h4>
<p>The following example shows a main program - Copy - that reads all available data
from a given input port, stores it internally during the reading process in a stack
and then outputs all the data read to an output port. The specifications of the
stack packages are not presented since they are identical to previous examples.</p>
<p>Specification of main program in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">Input_Port_05</span><span class="p">,</span> <span class="n">Output_Port_05</span><span class="p">,</span> <span class="n">Stacks_05</span><span class="p">;</span>
<span class="c">--# inherit Input_Port_05, Output_Port_05, Stacks_05;</span>
<span class="c">--# main_program;</span>
<span class="k">procedure </span><span class="nf">Copy_05</span>
<span class="c">--# global in     Input_Port_05.Input_State;</span>
<span class="c">--#        out    Output_Port_05.Output_State;</span>
<span class="c">--# derives Output_Port_05.Output_State from Input_Port_05.Input_State;</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">The_Stack</span>   <span class="o">:</span> <span class="n">Stacks_05.Stack</span><span class="p">;</span>
   <span class="n">Value</span>       <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="n">Done</span>        <span class="o">:</span> <span class="n">Boolean</span><span class="p">;</span>
   <span class="n">Final_Value</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="n">Integer</span> <span class="o">:=</span> <span class="mi">999</span><span class="p">;</span>
<span class="kr">begin</span><span class="p"></span>
   <span class="n">Stacks_05.Clear</span><span class="o">(</span><span class="n">The_Stack</span><span class="o">)</span><span class="p">;</span>
   <span class="kr">loop</span><span class="p"></span>
      <span class="n">Input_Port_05.Read_From_Port</span><span class="o">(</span><span class="n">Value</span><span class="o">)</span><span class="p">;</span>
      <span class="n">Stacks_05.Push</span><span class="o">(</span><span class="n">The_Stack</span><span class="p">,</span> <span class="n">Value</span><span class="o">)</span><span class="p">;</span>
      <span class="n">Done</span> <span class="o">:=</span> <span class="n">Value</span> <span class="o">=</span> <span class="n">Final_Value</span><span class="p">;</span>
      <span class="kr">exit</span><span class="p"> </span><span class="kr">when</span><span class="p"> </span><span class="n">Done</span><span class="p">;</span>
   <span class="k">end loop</span><span class="p">;</span>
   <span class="kr">loop</span><span class="p"></span>
      <span class="n">Stacks_05.Pop</span><span class="o">(</span><span class="n">The_Stack</span><span class="p">,</span> <span class="n">Value</span><span class="o">)</span><span class="p">;</span>
      <span class="n">Output_Port_05.Write_To_Port</span><span class="o">(</span><span class="n">Value</span><span class="o">)</span><span class="p">;</span>
      <span class="kr">exit</span><span class="p"> </span><span class="kr">when</span><span class="p"> </span><span class="n">Stacks_05.Is_Empty</span><span class="o">(</span><span class="n">The_Stack</span><span class="o">)</span><span class="p">;</span>
   <span class="k">end loop</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Copy_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specification of input port in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Input_Port_05</span>
  <span class="c">--# own in Input_State;</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Read_From_Port</span><span class="o">(</span><span class="n">Input_Value</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--# global in Input_State;</span>
   <span class="c">--# derives Input_Value from Input_State;</span>

<span class="k">end </span><span class="nf">Input_Port_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body of input port in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Input_Port_05</span>
<span class="kr">is</span><span class="p"></span>

   <span class="n">Input_State</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="kr">for</span><span class="p"> </span><span class="n">Input_State</span><span class="na">&#39;Address</span> <span class="kr">use</span><span class="p"></span>
     <span class="n">System.Storage_Elements.To_Address</span> <span class="o">(</span><span class="mi">16#ACECAE0#</span><span class="o">)</span><span class="p">;</span>
   <span class="kr">pragma</span><span class="p"> </span><span class="n">Volatile</span> <span class="o">(</span><span class="n">Input_State</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Read_From_Port</span><span class="o">(</span><span class="n">Input_Value</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Input_Value</span> <span class="o">:=</span> <span class="n">Input_State</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Read_From_Port</span><span class="p">;</span>

<span class="k">end </span><span class="nf">Input_Port_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specification of output port in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Output_Port_05</span>
  <span class="c">--# own out Output_State;</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Write_To_Port</span><span class="o">(</span><span class="n">Output_Value</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--# global out Output_State;</span>
   <span class="c">--# derives Output_State from Output_Value;</span>
<span class="k">end </span><span class="nf">Output_Port_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body of output port in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Output_Port_05</span>
<span class="kr">is</span><span class="p"></span>

   <span class="n">Output_State</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="kr">for</span><span class="p"> </span><span class="n">Output_State</span><span class="na">&#39;Address</span> <span class="kr">use</span><span class="p"></span>
     <span class="n">System.Storage_Elements.To_Address</span> <span class="o">(</span><span class="mi">16#ACECAF0#</span><span class="o">)</span><span class="p">;</span>
   <span class="kr">pragma</span><span class="p"> </span><span class="n">Volatile</span> <span class="o">(</span><span class="n">Output_State</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Write_To_Port</span><span class="o">(</span><span class="n">Output_Value</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Output_State</span> <span class="o">:=</span> <span class="n">Output_Value</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Write_To_Port</span><span class="p">;</span>

<span class="k">end </span><span class="nf">Output_Port_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specification of main program in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">Input_Port_14</span><span class="p">,</span>
     <span class="n">Output_Port_14</span><span class="p">,</span>
     <span class="n">Stacks_14</span><span class="p">;</span>
<span class="c">--  No need to specify that Copy_14 is a main program</span>

<span class="k">procedure </span><span class="nf">Copy_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span>  <span class="o">=&gt;</span> <span class="n">Input_Port_14.Input_State</span><span class="p">,</span>
                   <span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">Output_Port_14.Output_State</span><span class="o">)</span><span class="p">,</span>
       <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output_Port_14.Output_State</span> <span class="o">=&gt;</span> <span class="n">Input_Port_14.Input_State</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">The_Stack</span>   <span class="o">:</span> <span class="n">Stacks_14.Stack</span><span class="p">;</span>
   <span class="n">Value</span>       <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="n">Done</span>        <span class="o">:</span> <span class="n">Boolean</span><span class="p">;</span>
   <span class="n">Final_Value</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="n">Integer</span> <span class="o">:=</span> <span class="mi">999</span><span class="p">;</span>
<span class="kr">begin</span><span class="p"></span>
   <span class="n">Stacks_14.Clear</span><span class="o">(</span><span class="n">The_Stack</span><span class="o">)</span><span class="p">;</span>
   <span class="kr">loop</span><span class="p"></span>
      <span class="n">Input_Port_14.Read_From_Port</span><span class="o">(</span><span class="n">Value</span><span class="o">)</span><span class="p">;</span>
      <span class="n">Stacks_14.Push</span><span class="o">(</span><span class="n">The_Stack</span><span class="p">,</span> <span class="n">Value</span><span class="o">)</span><span class="p">;</span>
      <span class="n">Done</span> <span class="o">:=</span> <span class="n">Value</span> <span class="o">=</span> <span class="n">Final_Value</span><span class="p">;</span>
      <span class="kr">exit</span><span class="p"> </span><span class="kr">when</span><span class="p"> </span><span class="n">Done</span><span class="p">;</span>
   <span class="k">end loop</span><span class="p">;</span>
   <span class="kr">loop</span><span class="p"></span>
      <span class="n">Stacks_14.Pop</span><span class="o">(</span><span class="n">The_Stack</span><span class="p">,</span> <span class="n">Value</span><span class="o">)</span><span class="p">;</span>
      <span class="n">Output_Port_14.Write_To_Port</span><span class="o">(</span><span class="n">Value</span><span class="o">)</span><span class="p">;</span>
      <span class="kr">exit</span><span class="p"> </span><span class="kr">when</span><span class="p"> </span><span class="n">Stacks_14.Is_Empty</span><span class="o">(</span><span class="n">The_Stack</span><span class="o">)</span><span class="p">;</span>
   <span class="k">end loop</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Copy_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specification of input port in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Input_Port_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input_State</span> <span class="kr">with</span><span class="p"> </span><span class="n">External</span> <span class="o">=&gt;</span> <span class="n">Async_Writers</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Read_From_Port</span><span class="o">(</span><span class="n">Input_Value</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span> <span class="o">=&gt;</span> <span class="n">Input_State</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input_Value</span> <span class="o">=&gt;</span> <span class="n">Input_State</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Input_Port_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specification of output port in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Output_Port_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output_State</span> <span class="kr">with</span><span class="p"> </span><span class="n">External</span> <span class="o">=&gt;</span> <span class="n">Async_Readers</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Write_To_Port</span><span class="o">(</span><span class="n">Output_Value</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">Output_State</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output_State</span> <span class="o">=&gt;</span> <span class="n">Output_Value</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Output_Port_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body of input port in SPARK 2014:</p>
<p>This is as per SPARK 2005, but uses aspects instead of representation clauses and pragmas.</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">System.Storage_Elements</span><span class="p">;</span>

<span class="k">package body </span><span class="nf">Input_Port_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input_State</span> <span class="o">=&gt;</span> <span class="n">Input_S</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">Input_S</span> <span class="o">:</span> <span class="n">Integer</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Volatile</span><span class="p">,</span>
          <span class="n">Async_Writers</span><span class="p">,</span>
          <span class="n">Address</span> <span class="o">=&gt;</span> <span class="n">System.Storage_Elements.To_Address</span> <span class="o">(</span><span class="mi">16#ACECAE0#</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Read_From_Port</span><span class="o">(</span><span class="n">Input_Value</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span> <span class="o">=&gt;</span> <span class="n">Input_S</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Refined_Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input_Value</span> <span class="o">=&gt;</span> <span class="n">Input_S</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Input_Value</span> <span class="o">:=</span> <span class="n">Input_S</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Read_From_Port</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Input_Port_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body of output port in SPARK 2014:</p>
<p>This is as per SPARK 2005, but uses aspects instead of representation clauses and pragmas.</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">System.Storage_Elements</span><span class="p">;</span>

<span class="k">package body </span><span class="nf">Output_Port_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output_State</span> <span class="o">=&gt;</span> <span class="n">Output_S</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">Output_S</span> <span class="o">:</span> <span class="n">Integer</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Volatile</span><span class="p">,</span>
          <span class="n">Async_Readers</span><span class="p">,</span>
          <span class="n">Address</span> <span class="o">=&gt;</span> <span class="n">System.Storage_Elements.To_Address</span> <span class="o">(</span><span class="mi">16#ACECAF0#</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Write_To_Port</span><span class="o">(</span><span class="n">Output_Value</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">Output_S</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Refined_Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output_S</span> <span class="o">=&gt;</span> <span class="n">Output_Value</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Output_S</span> <span class="o">:=</span> <span class="n">Output_Value</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Write_To_Port</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Output_Port_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="input-driver-using-tail-in-a-contract">
<span id="ms-external-variables-input-append-tail-label"></span><h4>Input driver using &#8216;Tail in a contract<a class="headerlink" href="#input-driver-using-tail-in-a-contract" title="Permalink to this headline">¶</a></h4>
<p>This example uses the Input_Port package from section <a class="reference internal" href="#basic-input-and-output-device-drivers">Basic Input and Output Device Drivers</a>
and adds a contract using the &#8216;Tail attribute. The example also use the Always_Valid attribute
in order to allow proof to succeed (otherwise, there is no guarantee in the proof context
that the value read from the port is of the correct type).</p>
<p>SPARK 2014 does not have the attribute &#8216;Tail but, often, an equivalent
proof can be achieved using assert pragmas.  Neither is there a direct
equivalent of the Always_Valid attribute but the paragma Assume may be
used to the same effect.</p>
<p>Specification in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Input_Port</span>
  <span class="c">--# own in Inputs : Integer;</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Read_From_Port</span><span class="o">(</span><span class="n">Input_Value</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--# global in Inputs;</span>
   <span class="c">--# derives Input_Value from Inputs;</span>
   <span class="c">--# post (Inputs~ = 0  -&gt; (Input_Value = Inputs&#39;Tail (Inputs~))) and</span>
   <span class="c">--#      (Inputs~ /= 0 -&gt; (Input_Value = Inputs~));</span>

<span class="k">end </span><span class="nf">Input_Port</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Input_Port</span>
<span class="kr">is</span><span class="p"></span>

   <span class="n">Inputs</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="kr">for</span><span class="p"> </span><span class="n">Inputs</span><span class="na">&#39;Address</span> <span class="kr">use</span><span class="p"></span>
     <span class="n">System.Storage_Elements.To_Address</span> <span class="o">(</span><span class="mi">16#ACECAF0#</span><span class="o">)</span><span class="p">;</span>

   <span class="c">--# assert Inputs&#39;Always_Valid;</span>
   <span class="kr">pragma</span><span class="p"> </span><span class="n">Volatile</span> <span class="o">(</span><span class="n">Inputs</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Read_From_Port</span><span class="o">(</span><span class="n">Input_Value</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Input_Value</span> <span class="o">:=</span> <span class="n">Inputs</span><span class="p">;</span>
      <span class="kr">if</span><span class="p"> </span><span class="n">Input_Value</span> <span class="o">=</span> <span class="mi">0</span> <span class="kr">then</span><span class="p"></span>
         <span class="n">Input_Value</span> <span class="o">:=</span> <span class="n">Inputs</span><span class="p">;</span>
      <span class="k">end if</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Read_From_Port</span><span class="p">;</span>

<span class="k">end </span><span class="nf">Input_Port</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specification in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Input_Port_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Inputs</span> <span class="kr">with</span><span class="p"> </span><span class="n">External</span> <span class="o">=&gt;</span> <span class="n">Async_Writers</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Read_From_Port</span><span class="o">(</span><span class="n">Input_Value</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="n">Inputs</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input_Value</span> <span class="o">=&gt;</span> <span class="n">Inputs</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Input_Port_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">System.Storage_Elements</span><span class="p">;</span>

<span class="k">package body </span><span class="nf">Input_Port_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Inputs</span> <span class="o">=&gt;</span> <span class="n">Input_Port</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">Input_Port</span> <span class="o">:</span> <span class="n">Integer</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Volatile</span><span class="p">,</span>
          <span class="n">Async_Writers</span><span class="p">,</span>
          <span class="n">Address</span> <span class="o">=&gt;</span> <span class="n">System.Storage_Elements.To_Address</span> <span class="o">(</span><span class="mi">16#ACECAF0#</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Read_From_Port</span><span class="o">(</span><span class="n">Input_Value</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span>  <span class="o">=&gt;</span> <span class="n">Input_Port</span><span class="p">,</span>
          <span class="n">Refined_Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input_Value</span> <span class="o">=&gt;</span> <span class="n">Input_Port</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
      <span class="n">First_Read</span>  <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
      <span class="n">Second_Read</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Second_Read</span> <span class="o">:=</span> <span class="n">Input_Port</span><span class="p">;</span>    <span class="c">-- Ensure Second_Read is initialized</span>
      <span class="kr">pragma</span><span class="p"> </span><span class="n">Assume</span> <span class="o">(</span><span class="n">Second_Read</span><span class="na">&#39;Valid</span><span class="o">)</span><span class="p">;</span>
      <span class="n">First_Read</span>  <span class="o">:=</span> <span class="n">Second_Read</span><span class="p">;</span>   <span class="c">-- but it is infact the First_Read.</span>
      <span class="kr">if</span><span class="p"> </span><span class="n">First_Read</span> <span class="o">=</span> <span class="mi">0</span> <span class="kr">then</span><span class="p"></span>
         <span class="n">Second_Read</span> <span class="o">:=</span> <span class="n">Input_Port</span><span class="p">;</span> <span class="c">-- Now it is the Second_Read</span>
         <span class="kr">pragma</span><span class="p"> </span><span class="n">Assume</span> <span class="o">(</span><span class="n">Second_Read</span><span class="na">&#39;Valid</span><span class="o">)</span><span class="p">;</span>
         <span class="n">Input_Value</span> <span class="o">:=</span> <span class="n">Second_Read</span><span class="p">;</span>
      <span class="kr">else</span><span class="p"></span>
         <span class="n">Input_Value</span> <span class="o">:=</span> <span class="n">First_Read</span><span class="p">;</span>
      <span class="k">end if</span><span class="p">;</span>
      <span class="kr">pragma</span><span class="p"> </span><span class="n">Assert</span> <span class="o">((</span><span class="n">First_Read</span> <span class="o">=</span> <span class="mi">0</span> <span class="kr">and</span><span class="p"> </span><span class="kr">then</span><span class="p"> </span><span class="n">Input_Value</span> <span class="o">=</span> <span class="n">Second_Read</span><span class="o">)</span>
                     <span class="kr">or</span><span class="p"> </span><span class="kr">else</span><span class="p"> </span><span class="o">(</span><span class="n">Input_Value</span> <span class="o">=</span> <span class="n">First_Read</span><span class="o">))</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Read_From_Port</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Input_Port_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="output-driver-using-append-in-a-contract">
<span id="ms-external-variables-output-append-tail-label"></span><h4>Output driver using &#8216;Append in a contract<a class="headerlink" href="#output-driver-using-append-in-a-contract" title="Permalink to this headline">¶</a></h4>
<p>This example uses the Output package from section <a class="reference internal" href="#basic-input-and-output-device-drivers">Basic Input and Output Device Drivers</a>
and adds a contract using the &#8216;Append attribute.</p>
<p>SPARK 2014 does not have the attribute &#8216;Append but, often, an equivalent proof can
be achieved using assert pragmas.</p>
<p>Specification in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Output_Port</span>
  <span class="c">--# own out Outputs : Integer;</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Write_To_Port</span><span class="o">(</span><span class="n">Output_Value</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--# global out Outputs;</span>
   <span class="c">--# derives Outputs from Output_Value;</span>
   <span class="c">--# post ((Output_Value = -1) -&gt;</span>
   <span class="c">--#        (Outputs =</span>
   <span class="c">--#           Outputs&#39;Append (Outputs&#39;Append (Outputs~, 0), Output_Value)))</span>
   <span class="c">--#  and</span>
   <span class="c">--#      ((Output_Value /= -1) -&gt;</span>
   <span class="c">--#         (Outputs =</span>
   <span class="c">--#           Outputs&#39;Append (Outputs~, Output_Value)));</span>
<span class="k">end </span><span class="nf">Output_Port</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Output_Port</span>
<span class="kr">is</span><span class="p"></span>

   <span class="n">Outputs</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="kr">for</span><span class="p"> </span><span class="n">Outputs</span><span class="na">&#39;Address</span> <span class="kr">use</span><span class="p"> </span><span class="n">System.Storage_Elements.To_Address</span> <span class="o">(</span><span class="mi">16#ACECAF10#</span><span class="o">)</span><span class="p">;</span>
   <span class="kr">pragma</span><span class="p"> </span><span class="n">Volatile</span> <span class="o">(</span><span class="n">Outputs</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Write_To_Port</span><span class="o">(</span><span class="n">Output_Value</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="kr">if</span><span class="p"> </span><span class="n">Output_Value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="kr">then</span><span class="p"></span>
         <span class="n">Outputs</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">end if</span><span class="p">;</span>

      <span class="n">Outputs</span> <span class="o">:=</span> <span class="n">Output_Value</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Write_To_Port</span><span class="p">;</span>

<span class="k">end </span><span class="nf">Output_Port</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specification in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Output_Port_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Outputs</span> <span class="kr">with</span><span class="p"> </span><span class="n">External</span> <span class="o">=&gt;</span> <span class="n">Async_Readers</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Write_To_Port</span><span class="o">(</span><span class="n">Output_Value</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">Outputs</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Outputs</span> <span class="o">=&gt;</span> <span class="n">Output_Value</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Output_Port_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">System.Storage_Elements</span><span class="p">;</span>

<span class="k">package body </span><span class="nf">Output_Port_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Outputs</span> <span class="o">=&gt;</span> <span class="n">Output_Port</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">Output_Port</span> <span class="o">:</span> <span class="n">Integer</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Volatile</span><span class="p">,</span>
          <span class="n">Async_Readers</span><span class="p">,</span>
          <span class="n">Address</span> <span class="o">=&gt;</span> <span class="n">System.Storage_Elements.To_Address</span> <span class="o">(</span><span class="mi">16#ACECAF10#</span><span class="o">)</span><span class="p">;</span>

   <span class="c">-- This is a simple subprogram that always updates the Output_Shadow with</span>
   <span class="c">-- the single value which is written to the output port.</span>
   <span class="k">procedure </span><span class="nf">Write_It</span> <span class="o">(</span><span class="n">Output_Value</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span> <span class="n">Output_Shadow</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">Output_Port</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">((</span><span class="n">Output_Port</span><span class="p">,</span> <span class="n">Output_Shadow</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">Output_Value</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Post</span>    <span class="o">=&gt;</span> <span class="n">Output_Shadow</span> <span class="o">=</span> <span class="n">Output_Value</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Output_Shadow</span> <span class="o">:=</span> <span class="n">Output_Value</span><span class="p">;</span>
      <span class="n">Output_Port</span> <span class="o">:=</span> <span class="n">Output_Shadow</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Write_It</span><span class="p">;</span>


   <span class="k">procedure </span><span class="nf">Write_To_Port</span><span class="o">(</span><span class="n">Output_Value</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">Output_Port</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Refined_Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output_Port</span> <span class="o">=&gt;</span> <span class="n">Output_Value</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
      <span class="n">Out_1</span><span class="p">,</span> <span class="n">Out_2</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="kr">if</span><span class="p"> </span><span class="n">Output_Value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="kr">then</span><span class="p"></span>
         <span class="n">Write_It</span> <span class="o">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Out_1</span><span class="o">)</span><span class="p">;</span>
         <span class="n">Write_It</span> <span class="o">(</span><span class="n">Output_Value</span><span class="p">,</span> <span class="n">Out_2</span><span class="o">)</span><span class="p">;</span>
      <span class="kr">else</span><span class="p"></span>
         <span class="n">Write_It</span> <span class="o">(</span><span class="n">Output_Value</span><span class="p">,</span> <span class="n">Out_1</span><span class="o">)</span><span class="p">;</span>
         <span class="n">Out_2</span> <span class="o">:=</span> <span class="n">Out_1</span><span class="p">;</span>  <span class="c">-- Avoids flow error.</span>
      <span class="k">end if</span><span class="p">;</span>

      <span class="kr">pragma</span><span class="p"> </span><span class="n">Assert</span> <span class="o">(</span><span class="kr">if</span><span class="p"> </span><span class="n">Output_Value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="kr">then</span><span class="p"></span>
                        <span class="n">Out_1</span> <span class="o">=</span> <span class="mi">0</span> <span class="kr">and</span><span class="p"> </span><span class="n">Out_2</span> <span class="o">=</span> <span class="n">Output_Value</span>
                     <span class="kr">else</span><span class="p"></span>
                        <span class="n">Out_1</span> <span class="o">=</span> <span class="n">Output_Value</span><span class="o">)</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Write_To_Port</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Output_Port_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="refinement-of-external-state-voting-input-switch">
<span id="ms-external-variables-refinement-voting-input-switch-label"></span><h4>Refinement of external state - voting input switch<a class="headerlink" href="#refinement-of-external-state-voting-input-switch" title="Permalink to this headline">¶</a></h4>
<p>The following example presents an abstract view of the reading of 3 individual
switches and the voting performed on the values read.</p>
<p>Abstract Switch specification in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Switch</span>
<span class="c">--# own in State;</span>
<span class="kr">is</span><span class="p"></span>

   <span class="kr">type</span><span class="p"> </span><span class="n">Reading</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">on</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">unknown</span><span class="o">)</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">ReadValue</span> <span class="kr">return</span><span class="p"> </span><span class="n">Reading</span><span class="p">;</span>
   <span class="c">--# global in State;</span>

<span class="k">end </span><span class="nf">Switch</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Component Switch specifications in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">--# inherit Switch;</span>
<span class="kr">private</span><span class="p"> </span><span class="k">package </span><span class="nf">Switch.Val1</span>
<span class="c">--# own in State;</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">Read</span> <span class="kr">return</span><span class="p"> </span><span class="n">Switch.Reading</span><span class="p">;</span>
   <span class="c">--# global in State;</span>

<span class="k">end </span><span class="nf">Switch.Val1</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">--# inherit Switch;</span>
<span class="kr">private</span><span class="p"> </span><span class="k">package </span><span class="nf">Switch.Val2</span>
<span class="c">--# own in State;</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">Read</span> <span class="kr">return</span><span class="p"> </span><span class="n">Switch.Reading</span><span class="p">;</span>
   <span class="c">--# global in State;</span>

<span class="k">end </span><span class="nf">Switch.Val2</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">--# inherit Switch;</span>
<span class="kr">private</span><span class="p"> </span><span class="k">package </span><span class="nf">Switch.Val3</span>
<span class="c">--# own in State;</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">Read</span> <span class="kr">return</span><span class="p"> </span><span class="n">Switch.Reading</span><span class="p">;</span>
   <span class="c">--# global in State;</span>

<span class="k">end </span><span class="nf">Switch.Val3</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Switch body in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">Switch.Val1</span><span class="p">;</span>
<span class="kr">with</span><span class="nn"> Switch.Val2;</span><span class="p"></span>
<span class="kr">with</span><span class="nn"> Switch.Val3;</span>
<span class="k">package body </span><span class="nf">Switch</span>
<span class="c">--# own State is in Switch.Val1.State,</span>
<span class="c">--#              in Switch.Val2.State,</span>
<span class="c">--#              in Switch.Val3.State;</span>
<span class="kr">is</span><span class="p"></span>

   <span class="kr">subtype</span><span class="p"> </span><span class="n">Value</span> <span class="kr">is</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">range</span><span class="p"> </span><span class="o">-</span><span class="mi">1</span> <span class="o">..</span> <span class="mi">1</span><span class="p">;</span>
   <span class="kr">subtype</span><span class="p"> </span><span class="n">Score</span> <span class="kr">is</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">range</span><span class="p"> </span><span class="o">-</span><span class="mi">3</span> <span class="o">..</span> <span class="mi">3</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span><span class="n">ConvertToValueArray</span> <span class="kr">is</span><span class="p"> </span><span class="kr">array</span><span class="p"> </span><span class="o">(</span><span class="n">Reading</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Value</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span><span class="n">ConvertToReadingArray</span> <span class="kr">is</span><span class="p"> </span><span class="kr">array</span><span class="p"> </span><span class="o">(</span><span class="n">Score</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Reading</span><span class="p">;</span>

   <span class="n">ConvertToValue</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="n">ConvertToValueArray</span> <span class="o">:=</span> <span class="n">ConvertToValueArray</span><span class="o">&#39;(</span><span class="n">on</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span>
                                                                         <span class="n">unknown</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">,</span>
                                                                         <span class="n">off</span> <span class="o">=&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span><span class="p">;</span>
   <span class="n">ConvertToReading</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="n">ConvertToReadingArray</span> <span class="o">:=</span>
                                      <span class="n">ConvertToReadingArray</span><span class="o">&#39;(-</span><span class="mi">3</span> <span class="o">..</span> <span class="o">-</span><span class="mi">2</span> <span class="o">=&gt;</span> <span class="n">off</span><span class="p">,</span>
                                                             <span class="o">-</span><span class="mi">1</span> <span class="o">..</span> <span class="mi">1</span> <span class="o">=&gt;</span> <span class="n">unknown</span><span class="p">,</span>
                                                             <span class="mi">2</span> <span class="o">..</span><span class="mi">3</span> <span class="o">=&gt;</span> <span class="n">on</span><span class="o">)</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">ReadValue</span> <span class="kr">return</span><span class="p"> </span><span class="n">Reading</span>
   <span class="c">--# global in Val1.State;</span>
   <span class="c">--#        in Val2.State;</span>
   <span class="c">--#        in Val3.State;</span>
   <span class="kr">is</span><span class="p"></span>
      <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Reading</span><span class="p">;</span>
   <span class="kr">begin</span><span class="p"></span>
       <span class="n">A</span> <span class="o">:=</span> <span class="n">Val1.Read</span><span class="p">;</span>
       <span class="n">B</span> <span class="o">:=</span> <span class="n">Val2.Read</span><span class="p">;</span>
       <span class="n">C</span> <span class="o">:=</span> <span class="n">Val3.Read</span><span class="p">;</span>
       <span class="kr">return</span><span class="p"> </span><span class="n">ConvertToReading</span> <span class="o">(</span><span class="n">ConvertToValue</span> <span class="o">(</span><span class="n">A</span><span class="o">)</span> <span class="o">+</span>
          <span class="n">ConvertToValue</span> <span class="o">(</span><span class="n">B</span><span class="o">)</span> <span class="o">+</span> <span class="n">ConvertToValue</span> <span class="o">(</span><span class="n">C</span><span class="o">))</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">ReadValue</span><span class="p">;</span>

<span class="k">end </span><span class="nf">Switch</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Abstract Switch specification in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Switch</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State</span> <span class="kr">with</span><span class="p"> </span><span class="n">External</span> <span class="o">=&gt;</span> <span class="n">Async_Writers</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="kr">type</span><span class="p"> </span><span class="n">Reading</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">on</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">unknown</span><span class="o">)</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">ReadValue</span> <span class="kr">return</span><span class="p"> </span><span class="n">Reading</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Volatile_Function</span><span class="p">,</span>
          <span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Switch</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Component Switch specifications in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">private</span><span class="p"> </span><span class="k">package </span><span class="nf">Switch.Val1</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State</span> <span class="kr">with</span><span class="p"> </span><span class="n">External</span> <span class="o">=&gt;</span> <span class="n">Async_Writers</span><span class="p">,</span>
                                     <span class="n">Part_Of</span>  <span class="o">=&gt;</span> <span class="n">Switch.State</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">Read</span> <span class="kr">return</span><span class="p"> </span><span class="n">Switch.Reading</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Volatile_Function</span><span class="p">,</span>
          <span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Switch.Val1</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">private</span><span class="p"> </span><span class="k">package </span><span class="nf">Switch.Val2</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State</span> <span class="kr">with</span><span class="p"> </span><span class="n">External</span> <span class="o">=&gt;</span> <span class="n">Async_Writers</span><span class="p">,</span>
                                     <span class="n">Part_Of</span>  <span class="o">=&gt;</span> <span class="n">Switch.State</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">Read</span> <span class="kr">return</span><span class="p"> </span><span class="n">Switch.Reading</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Volatile_Function</span><span class="p">,</span>
          <span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Switch.Val2</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">private</span><span class="p"> </span><span class="k">package </span><span class="nf">Switch.Val3</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State</span> <span class="kr">with</span><span class="p"> </span><span class="n">External</span> <span class="o">=&gt;</span> <span class="n">Async_Writers</span><span class="p">,</span>
                                     <span class="n">Part_Of</span>  <span class="o">=&gt;</span> <span class="n">Switch.State</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">Read</span> <span class="kr">return</span><span class="p"> </span><span class="n">Switch.Reading</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Volatile_Function</span><span class="p">,</span>
          <span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Switch.Val3</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Switch body in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">Switch.Val1</span><span class="p">,</span>
     <span class="n">Switch.Val2</span><span class="p">,</span>
     <span class="n">Switch.Val3</span><span class="p">;</span>

<span class="k">package body </span><span class="nf">Switch</span>
   <span class="c">-- State is refined onto three states, each of which has properties</span>
   <span class="c">--  Volatile and Input</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Switch.Val1.State</span><span class="p">,</span>
                                   <span class="n">Switch.Val2.State</span><span class="p">,</span>
                                   <span class="n">Switch.Val3.State</span><span class="o">))</span>
<span class="kr">is</span><span class="p"></span>
   <span class="kr">subtype</span><span class="p"> </span><span class="n">Value</span> <span class="kr">is</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">range</span><span class="p"> </span><span class="o">-</span><span class="mi">1</span> <span class="o">..</span> <span class="mi">1</span><span class="p">;</span>
   <span class="kr">subtype</span><span class="p"> </span><span class="n">Score</span> <span class="kr">is</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">range</span><span class="p"> </span><span class="o">-</span><span class="mi">3</span> <span class="o">..</span> <span class="mi">3</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span><span class="n">ConvertToValueArray</span> <span class="kr">is</span><span class="p"> </span><span class="kr">array</span><span class="p"> </span><span class="o">(</span><span class="n">Reading</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Value</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span><span class="n">ConvertToReadingArray</span> <span class="kr">is</span><span class="p"> </span><span class="kr">array</span><span class="p"> </span><span class="o">(</span><span class="n">Score</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Reading</span><span class="p">;</span>

   <span class="n">ConvertToValue</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="n">ConvertToValueArray</span> <span class="o">:=</span>
     <span class="n">ConvertToValueArray</span><span class="o">&#39;(</span><span class="n">on</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span>
                          <span class="n">unknown</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">,</span>
                          <span class="n">off</span> <span class="o">=&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span><span class="p">;</span>
   <span class="n">ConvertToReading</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="n">ConvertToReadingArray</span> <span class="o">:=</span>
     <span class="n">ConvertToReadingArray</span><span class="o">&#39;(-</span><span class="mi">3</span> <span class="o">..</span> <span class="o">-</span><span class="mi">2</span> <span class="o">=&gt;</span> <span class="n">off</span><span class="p">,</span>
                            <span class="o">-</span><span class="mi">1</span> <span class="o">..</span> <span class="mi">1</span>  <span class="o">=&gt;</span> <span class="n">unknown</span><span class="p">,</span>
                             <span class="mi">2</span> <span class="o">..</span> <span class="mi">3</span>  <span class="o">=&gt;</span> <span class="n">on</span><span class="o">)</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">ReadValue</span> <span class="kr">return</span><span class="p"> </span><span class="n">Reading</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Val1.State</span><span class="p">,</span> <span class="n">Val2.State</span><span class="p">,</span> <span class="n">Val3.State</span><span class="o">))</span>
   <span class="kr">is</span><span class="p"></span>
      <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Reading</span><span class="p">;</span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">A</span> <span class="o">:=</span> <span class="n">Val1.Read</span><span class="p">;</span>
      <span class="n">B</span> <span class="o">:=</span> <span class="n">Val2.Read</span><span class="p">;</span>
      <span class="n">C</span> <span class="o">:=</span> <span class="n">Val3.Read</span><span class="p">;</span>
      <span class="kr">return</span><span class="p"> </span><span class="n">ConvertToReading</span> <span class="o">(</span><span class="n">ConvertToValue</span> <span class="o">(</span><span class="n">A</span><span class="o">)</span> <span class="o">+</span>
        <span class="n">ConvertToValue</span> <span class="o">(</span><span class="n">B</span><span class="o">)</span> <span class="o">+</span> <span class="n">ConvertToValue</span> <span class="o">(</span><span class="n">C</span><span class="o">))</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">ReadValue</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Switch</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="complex-i-o-device">
<span id="ms-external-variables-complex-io-device-label"></span><h4>Complex I/O Device<a class="headerlink" href="#complex-i-o-device" title="Permalink to this headline">¶</a></h4>
<p>The following example illustrates a more complex I/O device: the device is fundamentally
an output device but an acknowledgement has to be read from it. In addition, a local register
stores the last value written to avoid writes that would just re-send the same value.
The own variable is then refined into a normal variable, an input external variable
and an output external variable.</p>
<p>Specification in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Device</span>
<span class="c">--# own State;</span>
<span class="c">--# initializes State;</span>
<span class="kr">is</span><span class="p"></span>
  <span class="k">procedure </span><span class="nf">Write</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
  <span class="c">--# global in out State;</span>
  <span class="c">--# derives State from State, X;</span>
<span class="k">end </span><span class="nf">Device</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Device</span>
<span class="c">--# own State is        OldX,</span>
<span class="c">--#              in     StatusPort,</span>
<span class="c">--#                 out Register;</span>
<span class="c">-- refinement on to mix of external and ordinary variables</span>
<span class="kr">is</span><span class="p"></span>
   <span class="kr">type</span><span class="p"> </span><span class="n">Status_Port_Type</span> <span class="kr">is</span><span class="p"> </span><span class="kr">mod</span><span class="p"> </span><span class="mi">2</span><span class="o">**</span><span class="mi">32</span><span class="p">;</span>

  <span class="n">OldX</span> <span class="o">:</span> <span class="n">Integer</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="c">-- only component that needs initialization</span>
  <span class="n">StatusPort</span> <span class="o">:</span> <span class="n">Status_Port_Type</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Volatile</span> <span class="o">(</span><span class="n">StatusPort</span><span class="o">)</span><span class="p">;</span>
  <span class="c">-- address clause would be added here</span>

  <span class="n">Register</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Volatile</span> <span class="o">(</span><span class="n">Register</span><span class="o">)</span><span class="p">;</span>
  <span class="c">-- address clause would be added here</span>

  <span class="k">procedure </span><span class="nf">WriteReg</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
  <span class="c">--# global out Register;</span>
  <span class="c">--# derives Register from X;</span>
  <span class="kr">is</span><span class="p"></span>
  <span class="kr">begin</span><span class="p"></span>
    <span class="n">Register</span> <span class="o">:=</span> <span class="n">X</span><span class="p">;</span>
  <span class="k">end </span><span class="nf">WriteReg</span><span class="p">;</span>

  <span class="k">procedure </span><span class="nf">ReadAck</span> <span class="o">(</span><span class="n">OK</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Boolean</span><span class="o">)</span>
  <span class="c">--# global in StatusPort;</span>
  <span class="c">--# derives OK from StatusPort;</span>
  <span class="kr">is</span><span class="p"></span>
    <span class="n">RawValue</span> <span class="o">:</span> <span class="n">Status_Port_Type</span><span class="p">;</span>
  <span class="kr">begin</span><span class="p"></span>
    <span class="n">RawValue</span> <span class="o">:=</span> <span class="n">StatusPort</span><span class="p">;</span> <span class="c">-- only assignment allowed here</span>
    <span class="n">OK</span> <span class="o">:=</span> <span class="n">RawValue</span> <span class="o">=</span> <span class="mi">16#FFFF_FFFF#</span><span class="p">;</span>
  <span class="k">end </span><span class="nf">ReadAck</span><span class="p">;</span>

  <span class="k">procedure </span><span class="nf">Write</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
  <span class="c">--# global in out OldX;</span>
  <span class="c">--#           out Register;</span>
  <span class="c">--#        in     StatusPort;</span>
  <span class="c">--# derives OldX,Register from OldX, X &amp;</span>
  <span class="c">--#         null          from StatusPort;</span>
  <span class="kr">is</span><span class="p"></span>
    <span class="n">OK</span> <span class="o">:</span> <span class="n">Boolean</span><span class="p">;</span>
  <span class="kr">begin</span><span class="p"></span>
    <span class="kr">if</span><span class="p"> </span><span class="n">X</span> <span class="o">/=</span> <span class="n">OldX</span> <span class="kr">then</span><span class="p"></span>
      <span class="n">OldX</span> <span class="o">:=</span> <span class="n">X</span><span class="p">;</span>
      <span class="n">WriteReg</span> <span class="o">(</span><span class="n">X</span><span class="o">)</span><span class="p">;</span>
      <span class="kr">loop</span><span class="p"></span>
        <span class="n">ReadAck</span> <span class="o">(</span><span class="n">OK</span><span class="o">)</span><span class="p">;</span>
        <span class="kr">exit</span><span class="p"> </span><span class="kr">when</span><span class="p"> </span><span class="n">OK</span><span class="p">;</span>
      <span class="k">end loop</span><span class="p">;</span>
    <span class="k">end if</span><span class="p">;</span>
  <span class="k">end </span><span class="nf">Write</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Device</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specification in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Device</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State</span> <span class="kr">with</span><span class="p"> </span><span class="n">External</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Async_Readers</span><span class="p">,</span>
                                                  <span class="n">Async_Writers</span><span class="o">))</span><span class="p">,</span>
       <span class="n">Initializes</span>    <span class="o">=&gt;</span> <span class="n">State</span>
<span class="kr">is</span><span class="p"></span>
  <span class="k">procedure </span><span class="nf">Write</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
    <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">,</span>
         <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State</span> <span class="o">=&gt;+</span> <span class="n">X</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Device</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Device</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">OldX</span><span class="p">,</span>
                                   <span class="n">StatusPort</span><span class="p">,</span>
                                   <span class="n">Register</span><span class="o">))</span>
   <span class="c">-- refinement on to mix of external and ordinary variables</span>
<span class="kr">is</span><span class="p"></span>
   <span class="kr">type</span><span class="p"> </span><span class="n">Status_Port_Type</span> <span class="kr">is</span><span class="p"> </span><span class="kr">mod</span><span class="p"> </span><span class="mi">2</span><span class="o">**</span><span class="mi">32</span><span class="p">;</span>

   <span class="n">OldX</span> <span class="o">:</span> <span class="n">Integer</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="c">-- only component that needs initialization</span>

   <span class="n">StatusPort</span> <span class="o">:</span> <span class="n">Status_Port_Type</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Volatile</span><span class="p">,</span>
          <span class="n">Async_Writers</span><span class="p">;</span>
   <span class="c">-- address clause would be added here</span>

   <span class="n">Register</span> <span class="o">:</span> <span class="n">Integer</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Volatile</span><span class="p">,</span>
          <span class="n">Async_Readers</span><span class="p">;</span>
   <span class="c">-- address clause would be added here</span>

   <span class="k">procedure </span><span class="nf">WriteReg</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">Register</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Register</span> <span class="o">=&gt;</span> <span class="n">X</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Register</span> <span class="o">:=</span> <span class="n">X</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">WriteReg</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">ReadAck</span> <span class="o">(</span><span class="n">OK</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Boolean</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span> <span class="o">=&gt;</span> <span class="n">StatusPort</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">OK</span> <span class="o">=&gt;</span> <span class="n">StatusPort</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
      <span class="n">RawValue</span> <span class="o">:</span> <span class="n">Status_Port_Type</span><span class="p">;</span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">RawValue</span> <span class="o">:=</span> <span class="n">StatusPort</span><span class="p">;</span> <span class="c">-- only assignment allowed here</span>
      <span class="n">OK</span> <span class="o">:=</span> <span class="n">RawValue</span> <span class="o">=</span> <span class="mi">16#FFFF_FFFF#</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">ReadAck</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Write</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span>  <span class="o">=&gt;</span> <span class="n">StatusPort</span><span class="p">,</span>
                              <span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">Register</span><span class="p">,</span>
                              <span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">OldX</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Refined_Depends</span> <span class="o">=&gt;</span> <span class="o">((</span><span class="n">OldX</span><span class="p">,</span>
                               <span class="n">Register</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">OldX</span><span class="p">,</span>
                                             <span class="n">X</span><span class="o">)</span><span class="p">,</span>
                               <span class="kr">null</span><span class="p"> </span><span class="o">=&gt;</span> <span class="n">StatusPort</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
      <span class="n">OK</span> <span class="o">:</span> <span class="n">Boolean</span><span class="p">;</span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="kr">if</span><span class="p"> </span><span class="n">X</span> <span class="o">/=</span> <span class="n">OldX</span> <span class="kr">then</span><span class="p"></span>
         <span class="n">OldX</span> <span class="o">:=</span> <span class="n">X</span><span class="p">;</span>
         <span class="n">WriteReg</span> <span class="o">(</span><span class="n">X</span><span class="o">)</span><span class="p">;</span>
         <span class="kr">loop</span><span class="p"></span>
            <span class="n">ReadAck</span> <span class="o">(</span><span class="n">OK</span><span class="o">)</span><span class="p">;</span>
            <span class="kr">exit</span><span class="p"> </span><span class="kr">when</span><span class="p"> </span><span class="n">OK</span><span class="p">;</span>
         <span class="k">end loop</span><span class="p">;</span>
      <span class="k">end if</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Write</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Device</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="increasing-values-in-input-stream">
<span id="ms-external-variables-increasing-values-in-input-stream-label"></span><h4>Increasing values in input stream<a class="headerlink" href="#increasing-values-in-input-stream" title="Permalink to this headline">¶</a></h4>
<p>The following example illustrates an input port from which values are
read. According to its postcondition, procedure Increases checks whether
the first values read from the sequence are in ascending order. This example
shows that postconditions can refer to multiple individual elements of the
input stream.</p>
<p>In SPARK 2014 we can use assert pragmas in the subprogram instead of
specifying the action in the postcondition, as was done in
<a class="reference internal" href="#ms-external-variables-input-append-tail-label"><span class="std std-ref">Input driver using &#8216;Tail in a contract</span></a>. Another
alternative, as shown in this example, is to use a formal parameter of
a private type to keep a trace of the values read.</p>
<p>Specification in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span> <span class="k">package </span><span class="nf">Inc</span>
<span class="c">--# own in Sensor : Integer;</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Increases</span> <span class="o">(</span><span class="n">Result</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Boolean</span><span class="p">;</span>
                        <span class="n">Valid</span>  <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Boolean</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--# global in Sensor;</span>
   <span class="c">--# post Valid -&gt; (Result &lt;-&gt; Sensor&#39;Tail (Sensor~) &gt; Sensor~);</span>

<span class="k">end </span><span class="nf">Inc</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">System.Storage_Elements</span><span class="p">;</span>
<span class="k">package body </span><span class="nf">Inc</span>
<span class="c">-- Cannot refine own variable Sensor as it has been given a concrete type.</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">Sensor</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="kr">for</span><span class="p"> </span><span class="n">Sensor</span><span class="na">&#39;Address</span> <span class="kr">use</span><span class="p"> </span><span class="n">System.Storage_Elements.To_Address</span> <span class="o">(</span><span class="mi">16#DEADBEE0#</span><span class="o">)</span><span class="p">;</span>
   <span class="kr">pragma</span><span class="p"> </span><span class="n">Volatile</span> <span class="o">(</span><span class="n">Sensor</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Read</span> <span class="o">(</span><span class="n">V</span>     <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>
                   <span class="n">Valid</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Boolean</span><span class="o">)</span>
   <span class="c">--# global in Sensor;</span>
   <span class="c">--# post (Valid -&gt; V = Sensor~) and</span>
   <span class="c">--#      (Sensor = Sensor&#39;Tail (Sensor~));</span>
   <span class="kr">is</span><span class="p"></span>
      <span class="n">Tmp</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Tmp</span> <span class="o">:=</span> <span class="n">Sensor</span><span class="p">;</span>
      <span class="kr">if</span><span class="p"> </span><span class="n">Tmp</span><span class="na">&#39;Valid</span> <span class="kr">then</span><span class="p"></span>
         <span class="n">V</span> <span class="o">:=</span> <span class="n">Tmp</span><span class="p">;</span>
         <span class="n">Valid</span> <span class="o">:=</span> <span class="kc">True</span><span class="p">;</span>
         <span class="c">--# check Sensor = Sensor&#39;Tail (Sensor~);</span>
      <span class="kr">else</span><span class="p"></span>
         <span class="n">V</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
         <span class="n">Valid</span> <span class="o">:=</span> <span class="kc">False</span><span class="p">;</span>
      <span class="k">end if</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Read</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Increases</span> <span class="o">(</span><span class="n">Result</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Boolean</span><span class="p">;</span>
                        <span class="n">Valid</span>  <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Boolean</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
      <span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Result</span> <span class="o">:=</span> <span class="kc">False</span><span class="p">;</span>
      <span class="n">Read</span> <span class="o">(</span><span class="n">A</span><span class="p">,</span> <span class="n">Valid</span><span class="o">)</span><span class="p">;</span>
      <span class="kr">if</span><span class="p"> </span><span class="n">Valid</span> <span class="kr">then</span><span class="p"></span>
         <span class="n">Read</span> <span class="o">(</span><span class="n">B</span><span class="p">,</span> <span class="n">Valid</span><span class="o">)</span><span class="p">;</span>
         <span class="kr">if</span><span class="p"> </span><span class="n">Valid</span> <span class="kr">then</span><span class="p"></span>
            <span class="n">Result</span> <span class="o">:=</span> <span class="n">B</span> <span class="o">&gt;</span> <span class="n">A</span><span class="p">;</span>
         <span class="k">end if</span><span class="p">;</span>
      <span class="k">end if</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Increases</span><span class="p">;</span>

<span class="k">end </span><span class="nf">Inc</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specification in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Inc</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Sensor</span> <span class="kr">with</span><span class="p"> </span><span class="n">External</span> <span class="o">=&gt;</span> <span class="n">Async_Writers</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="c">-- Declare a private type which will keep a trace of the</span>
   <span class="c">-- values read.</span>
   <span class="kr">type</span><span class="p"> </span><span class="n">Increasing_Indicator</span> <span class="kr">is</span><span class="p"> </span><span class="kr">private</span><span class="p">;</span>

   <span class="c">-- Access (ghost) functions for the private type only intended for</span>
   <span class="c">-- use in pre and post conditions or other assertion expressions</span>
   <span class="k">function </span><span class="nf">First</span> <span class="o">(</span><span class="n">Indicator</span> <span class="o">:</span> <span class="n">Increasing_Indicator</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span><span class="p"></span>
<span class="p">     </span><span class="kr">with</span><span class="nn"> Ghost;</span>

   <span class="k">function </span><span class="nf">Second</span> <span class="o">(</span><span class="n">Indicator</span> <span class="o">:</span> <span class="n">Increasing_Indicator</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span><span class="p"></span>
<span class="p">     </span><span class="kr">with</span><span class="nn"> Ghost;</span>

   <span class="c">-- Used to check that the value returned by procedure Increases</span>
   <span class="c">-- is valid (Invalid values have not been read from the Sensor).</span>
   <span class="k">function </span><span class="nf">Is_Valid</span> <span class="o">(</span><span class="n">Indicator</span> <span class="o">:</span> <span class="n">Increasing_Indicator</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span><span class="p">;</span>

   <span class="c">-- Use this function to determine whether the result of the procedure</span>
   <span class="c">-- Increases indicates an increasing value.</span>
   <span class="c">-- It can only be called if Is_Valid (Indicator)</span>
   <span class="k">function </span><span class="nf">Is_Increasing</span> <span class="o">(</span><span class="n">Indicator</span> <span class="o">:</span> <span class="n">Increasing_Indicator</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Pre</span> <span class="o">=&gt;</span> <span class="n">Is_Valid</span> <span class="o">(</span><span class="n">Indicator</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Increases</span> <span class="o">(</span><span class="n">Result</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Increasing_Indicator</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="n">Sensor</span><span class="p">,</span>
          <span class="n">Post</span>   <span class="o">=&gt;</span> <span class="o">(</span><span class="kr">if</span><span class="p"> </span><span class="n">Is_Valid</span> <span class="o">(</span><span class="n">Result</span><span class="o">)</span> <span class="kr">then</span><span class="p"> </span><span class="n">Is_Increasing</span> <span class="o">(</span><span class="n">Result</span><span class="o">)=</span>
                       <span class="o">(</span><span class="n">Second</span> <span class="o">(</span><span class="n">Result</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">First</span> <span class="o">(</span><span class="n">Result</span><span class="o">)))</span><span class="p">;</span>

<span class="kr">private</span><span class="p"></span>
   <span class="kr">type</span><span class="p"> </span><span class="n">Increasing_Indicator</span> <span class="kr">is</span><span class="p"> </span><span class="kr">record</span><span class="p"></span>
      <span class="n">Valid</span> <span class="o">:</span> <span class="n">Boolean</span><span class="p">;</span>
      <span class="n">First</span><span class="p">,</span> <span class="n">Second</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="k">end record</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Inc</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">System.Storage_Elements</span><span class="p">;</span>

<span class="k">package body </span><span class="nf">Inc</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Sensor</span> <span class="o">=&gt;</span> <span class="n">S</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="kr">pragma</span><span class="p"> </span><span class="n">Warnings</span> <span class="o">(</span><span class="n">Off</span><span class="o">)</span><span class="p">;</span>
   <span class="n">S</span> <span class="o">:</span> <span class="n">Integer</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Volatile</span><span class="p">,</span>
          <span class="n">Async_Writers</span><span class="p">,</span>
          <span class="n">Address</span> <span class="o">=&gt;</span> <span class="n">System.Storage_Elements.To_Address</span> <span class="o">(</span><span class="mi">16#DEADBEE0#</span><span class="o">)</span><span class="p">;</span>
   <span class="kr">pragma</span><span class="p"> </span><span class="n">Warnings</span> <span class="o">(</span><span class="n">On</span><span class="o">)</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">First</span> <span class="o">(</span><span class="n">Indicator</span> <span class="o">:</span> <span class="n">Increasing_Indicator</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">is</span><span class="p"></span>
     <span class="o">(</span><span class="n">Indicator.First</span><span class="o">)</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Second</span> <span class="o">(</span><span class="n">Indicator</span> <span class="o">:</span> <span class="n">Increasing_Indicator</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">is</span><span class="p"></span>
     <span class="o">(</span><span class="n">Indicator.Second</span><span class="o">)</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Is_Valid</span> <span class="o">(</span><span class="n">Indicator</span> <span class="o">:</span> <span class="n">Increasing_Indicator</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span> <span class="kr">is</span><span class="p"></span>
     <span class="o">(</span><span class="n">Indicator.Valid</span><span class="o">)</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Is_Increasing</span> <span class="o">(</span><span class="n">Indicator</span> <span class="o">:</span> <span class="n">Increasing_Indicator</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span> <span class="kr">is</span><span class="p"></span>
     <span class="o">(</span><span class="n">Indicator.Second</span> <span class="o">&gt;</span> <span class="n">Indicator.First</span><span class="o">)</span><span class="p">;</span>

   <span class="kr">pragma</span><span class="p"> </span><span class="n">Warnings</span> <span class="o">(</span><span class="n">Off</span><span class="o">)</span><span class="p">;</span>
   <span class="k">procedure </span><span class="nf">Read</span> <span class="o">(</span><span class="n">V</span>     <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>
                   <span class="n">Valid</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Boolean</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="n">S</span><span class="p">,</span>
          <span class="n">Post</span>   <span class="o">=&gt;</span> <span class="o">(</span><span class="kr">if</span><span class="p"> </span><span class="n">Valid</span> <span class="kr">then</span><span class="p"> </span><span class="n">V</span><span class="na">&#39;Valid</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
      <span class="n">Tmp</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="kr">pragma</span><span class="p"> </span><span class="n">Warnings</span> <span class="o">(</span><span class="n">On</span><span class="o">)</span><span class="p">;</span>
      <span class="n">Tmp</span> <span class="o">:=</span> <span class="n">S</span><span class="p">;</span>
      <span class="kr">pragma</span><span class="p"> </span><span class="n">Warnings</span> <span class="o">(</span><span class="n">Off</span><span class="o">)</span><span class="p">;</span>
      <span class="kr">if</span><span class="p"> </span><span class="n">Tmp</span><span class="na">&#39;Valid</span> <span class="kr">then</span><span class="p"></span>
      <span class="kr">pragma</span><span class="p"> </span><span class="n">Warnings</span> <span class="o">(</span><span class="n">On</span><span class="o">)</span><span class="p">;</span>
         <span class="n">V</span> <span class="o">:=</span> <span class="n">Tmp</span><span class="p">;</span>
         <span class="n">Valid</span> <span class="o">:=</span> <span class="kc">True</span><span class="p">;</span>
      <span class="kr">else</span><span class="p"></span>
         <span class="n">V</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
         <span class="n">Valid</span> <span class="o">:=</span> <span class="kc">False</span><span class="p">;</span>
      <span class="k">end if</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Read</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Increases</span> <span class="o">(</span><span class="n">Result</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Increasing_Indicator</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="n">S</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Read</span> <span class="o">(</span><span class="n">Result.First</span><span class="p">,</span> <span class="n">Result.Valid</span><span class="o">)</span><span class="p">;</span>
      <span class="kr">if</span><span class="p"> </span><span class="n">Result.Valid</span> <span class="kr">then</span><span class="p"></span>
         <span class="n">Read</span> <span class="o">(</span><span class="n">Result.Second</span><span class="p">,</span> <span class="n">Result.Valid</span><span class="o">)</span><span class="p">;</span>
      <span class="kr">else</span><span class="p"></span>
         <span class="n">Result.Second</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">end if</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Increases</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Inc</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
</div>
<div class="section" id="package-inheritance">
<span id="ms-package-inheritance-label"></span><h3>Package Inheritance<a class="headerlink" href="#package-inheritance" title="Permalink to this headline">¶</a></h3>
<p>SPARK 2014 does not have the SPARK 2005 concept of package
inheritance.  It has the same package visibility rules as Ada 2012.</p>
<div class="section" id="contracts-with-remote-state">
<span id="ms-contracts-with-remote-state-label"></span><h4>Contracts with remote state<a class="headerlink" href="#contracts-with-remote-state" title="Permalink to this headline">¶</a></h4>
<p>The following example illustrates indirect access to the state of one package
by another via an intermediary. Raw_Data stores some data, which has preprocessing
performed on it by Processing and on which Calculate performs some further processing
(although the corresponding bodies are not given, Read_Calculated_Value in Calculate
calls through to Read_Processed_Data in Processing, which calls through to Read in Raw_Data).</p>
<p>Specifications in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Raw_Data</span>
<span class="c">--# own State;</span>
<span class="c">--# Initializes State;</span>
<span class="kr">is</span><span class="p"></span>

   <span class="k">function </span><span class="nf">Data_Is_Valid</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span><span class="p">;</span>
   <span class="c">--# global State;</span>

   <span class="k">function </span><span class="nf">Get_Value</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>
   <span class="c">--# global State;</span>

   <span class="k">procedure </span><span class="nf">Read_Next</span><span class="p">;</span>
   <span class="c">--# global in out State;</span>
   <span class="c">--# derives State from State;</span>


<span class="k">end </span><span class="nf">Raw_Data</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">Raw_Data</span><span class="p">;</span>
<span class="c">--# inherit Raw_Data;</span>
<span class="k">package </span><span class="nf">Processing</span>
<span class="c">--# own State;</span>
<span class="c">--# Initializes State;</span>
<span class="kr">is</span><span class="p"></span>

   <span class="k">procedure </span><span class="nf">Get_Processed_Data</span> <span class="o">(</span><span class="n">Value</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--# global in     Raw_Data.State;</span>
   <span class="c">--#        in out State;</span>
   <span class="c">--# derives Value, State  from State, Raw_Data.State;</span>
   <span class="c">--# pre Raw_Data.Data_Is_Valid (Raw_Data.State);</span>

<span class="k">end </span><span class="nf">Processing</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">Processing</span><span class="p">;</span>
<span class="c">--# inherit Processing, Raw_Data;</span>
<span class="k">package </span><span class="nf">Calculate</span>
<span class="kr">is</span><span class="p"></span>

   <span class="k">procedure </span><span class="nf">Read_Calculated_Value</span> <span class="o">(</span><span class="n">Value</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--# global in out Processing.State;</span>
   <span class="c">--#        in     Raw_Data.State;</span>
   <span class="c">--# derives Value, Processing.State from Processing.State, Raw_Data.State;</span>
   <span class="c">--# pre Raw_Data.Data_Is_Valid (Raw_Data.State);</span>

<span class="k">end </span><span class="nf">Calculate</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specifications in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Raw_Data</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State</span> <span class="kr">with</span><span class="p"> </span><span class="n">External</span> <span class="o">=&gt;</span> <span class="n">Async_Writers</span><span class="o">)</span><span class="p">,</span>
       <span class="n">Initializes</span>    <span class="o">=&gt;</span> <span class="n">State</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">Data_Is_Valid</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Volatile_Function</span><span class="p">,</span>
          <span class="n">Global</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Get_Value</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Volatile_Function</span><span class="p">,</span>
          <span class="n">Global</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Read_Next</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Raw_Data</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">Raw_Data</span><span class="p">;</span>

<span class="k">package </span><span class="nf">Processing</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="n">State</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Get_Processed_Data</span> <span class="o">(</span><span class="n">Value</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span>  <span class="o">=&gt;</span> <span class="n">Raw_Data.State</span><span class="p">,</span>
                      <span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">((</span><span class="n">Value</span><span class="p">,</span>
                       <span class="n">State</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State</span><span class="p">,</span>
                                  <span class="n">Raw_Data.State</span><span class="o">))</span><span class="p">,</span>
          <span class="n">Pre</span>     <span class="o">=&gt;</span> <span class="n">Raw_Data.Data_Is_Valid</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Processing</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">Processing</span><span class="p">,</span>
     <span class="n">Raw_Data</span><span class="p">;</span>

<span class="k">package </span><span class="nf">Calculate</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Read_Calculated_Value</span> <span class="o">(</span><span class="n">Value</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">Processing.State</span><span class="p">,</span>
                      <span class="n">Input</span>  <span class="o">=&gt;</span> <span class="n">Raw_Data.State</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">((</span><span class="n">Value</span><span class="p">,</span>
                       <span class="n">Processing.State</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Processing.State</span><span class="p">,</span>
                                             <span class="n">Raw_Data.State</span><span class="o">))</span><span class="p">,</span>
          <span class="n">Pre</span>     <span class="o">=&gt;</span> <span class="n">Raw_Data.Data_Is_Valid</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Calculate</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="package-nested-inside-package">
<span id="ms-package-nested-inside-package-label"></span><h4>Package nested inside package<a class="headerlink" href="#package-nested-inside-package" title="Permalink to this headline">¶</a></h4>
<p>See section <a class="reference internal" href="#private-abstract-state-refining-onto-concrete-state-of-embedded-package">Private, abstract state, refining onto concrete state of embedded package</a>.</p>
</div>
<div class="section" id="package-nested-inside-subprogram">
<span id="ms-package-nested-inside-subprogram-label"></span><h4>Package nested inside subprogram<a class="headerlink" href="#package-nested-inside-subprogram" title="Permalink to this headline">¶</a></h4>
<p>This example is a modified version of that given in section
<a class="reference internal" href="#refinement-of-external-state-voting-input-switch">Refinement of external state - voting input switch</a>. It illustrates the
use of a package nested within a subprogram.</p>
<p>Abstract Switch specification in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Switch</span>
<span class="c">--# own in State;</span>
<span class="kr">is</span><span class="p"></span>

   <span class="kr">type</span><span class="p"> </span><span class="n">Reading</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">on</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">unknown</span><span class="o">)</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">ReadValue</span> <span class="kr">return</span><span class="p"> </span><span class="n">Reading</span><span class="p">;</span>
   <span class="c">--# global in State;</span>

<span class="k">end </span><span class="nf">Switch</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Component Switch specifications in SPARK 2005:</p>
<p>As in <a class="reference internal" href="#refinement-of-external-state-voting-input-switch">Refinement of external state - voting input switch</a></p>
<p>Switch body in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">Switch.Val1</span><span class="p">;</span>
<span class="kr">with</span><span class="nn"> Switch.Val2;</span><span class="p"></span>
<span class="kr">with</span><span class="nn"> Switch.Val3;</span>
<span class="k">package body </span><span class="nf">Switch</span>
<span class="c">--# own State is in Switch.Val1.State,</span>
<span class="c">--#              in Switch.Val2.State,</span>
<span class="c">--#              in Switch.Val3.State;</span>
<span class="kr">is</span><span class="p"></span>

   <span class="kr">subtype</span><span class="p"> </span><span class="n">Value</span> <span class="kr">is</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">range</span><span class="p"> </span><span class="o">-</span><span class="mi">1</span> <span class="o">..</span> <span class="mi">1</span><span class="p">;</span>
   <span class="kr">subtype</span><span class="p"> </span><span class="n">Score</span> <span class="kr">is</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">range</span><span class="p"> </span><span class="o">-</span><span class="mi">3</span> <span class="o">..</span> <span class="mi">3</span><span class="p">;</span>


   <span class="k">function </span><span class="nf">ReadValue</span> <span class="kr">return</span><span class="p"> </span><span class="n">Reading</span>
   <span class="c">--# global in Val1.State;</span>
   <span class="c">--#        in Val2.State;</span>
   <span class="c">--#        in Val3.State;</span>
   <span class="kr">is</span><span class="p"></span>
      <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Reading</span><span class="p">;</span>

      <span class="c">--  Embedded package to provide the capability to synthesize three inputs</span>
      <span class="c">--  into one.</span>
      <span class="c">--# inherit Switch;</span>
      <span class="k">package </span><span class="nf">Conversion</span>
      <span class="kr">is</span><span class="p"></span>

         <span class="k">function </span><span class="nf">Convert_To_Reading</span>
            <span class="o">(</span><span class="n">Val_A</span> <span class="o">:</span> <span class="n">Switch.Reading</span><span class="p">;</span>
             <span class="n">Val_B</span> <span class="o">:</span> <span class="n">Switch.Reading</span><span class="p">;</span>
             <span class="n">Val_C</span> <span class="o">:</span> <span class="n">Switch.Reading</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Switch.Reading</span><span class="p">;</span>

      <span class="k">end </span><span class="nf">Conversion</span><span class="p">;</span>

      <span class="k">package body </span><span class="nf">Conversion</span>
      <span class="kr">is</span><span class="p"></span>

         <span class="kr">type</span><span class="p"> </span><span class="n">ConvertToValueArray</span> <span class="kr">is</span><span class="p"> </span><span class="kr">array</span><span class="p"> </span><span class="o">(</span><span class="n">Switch.Reading</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Switch.Value</span><span class="p">;</span>
         <span class="kr">type</span><span class="p"> </span><span class="n">ConvertToReadingArray</span> <span class="kr">is</span><span class="p"> </span><span class="kr">array</span><span class="p"> </span><span class="o">(</span><span class="n">Switch.Score</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Switch.Reading</span><span class="p">;</span>
         <span class="n">ConvertToValue</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="n">ConvertToValueArray</span> <span class="o">:=</span> <span class="n">ConvertToValueArray</span><span class="o">&#39;(</span><span class="n">Switch.on</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span>
                                                                         <span class="n">Switch.unknown</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">,</span>
                                                                         <span class="n">Switch.off</span> <span class="o">=&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span><span class="p">;</span>

         <span class="n">ConvertToReading</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="n">ConvertToReadingArray</span> <span class="o">:=</span>
                                      <span class="n">ConvertToReadingArray</span><span class="o">&#39;(-</span><span class="mi">3</span> <span class="o">..</span> <span class="o">-</span><span class="mi">2</span> <span class="o">=&gt;</span> <span class="n">Switch.off</span><span class="p">,</span>
                                                             <span class="o">-</span><span class="mi">1</span> <span class="o">..</span> <span class="mi">1</span>  <span class="o">=&gt;</span> <span class="n">Switch.unknown</span><span class="p">,</span>
                                                             <span class="mi">2</span> <span class="o">..</span><span class="mi">3</span>    <span class="o">=&gt;</span> <span class="n">Switch.on</span><span class="o">)</span><span class="p">;</span>

         <span class="k">function </span><span class="nf">Convert_To_Reading</span>
            <span class="o">(</span><span class="n">Val_A</span> <span class="o">:</span> <span class="n">Switch.Reading</span><span class="p">;</span>
             <span class="n">Val_B</span> <span class="o">:</span> <span class="n">Switch.Reading</span><span class="p">;</span>
             <span class="n">Val_C</span> <span class="o">:</span> <span class="n">Switch.Reading</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Switch.Reading</span>
         <span class="kr">is</span><span class="p"></span>
         <span class="kr">begin</span><span class="p"></span>

            <span class="kr">return</span><span class="p"> </span><span class="n">ConvertToReading</span> <span class="o">(</span><span class="n">ConvertToValue</span> <span class="o">(</span><span class="n">Val_A</span><span class="o">)</span> <span class="o">+</span>
                   <span class="n">ConvertToValue</span> <span class="o">(</span><span class="n">Val_B</span><span class="o">)</span> <span class="o">+</span> <span class="n">ConvertToValue</span> <span class="o">(</span><span class="n">Val_C</span><span class="o">))</span><span class="p">;</span>
         <span class="k">end </span><span class="nf">Convert_To_Reading</span><span class="p">;</span>

      <span class="k">end </span><span class="nf">Conversion</span><span class="p">;</span>

   <span class="kr">begin</span><span class="p"></span>
       <span class="n">A</span> <span class="o">:=</span> <span class="n">Val1.Read</span><span class="p">;</span>
       <span class="n">B</span> <span class="o">:=</span> <span class="n">Val2.Read</span><span class="p">;</span>
       <span class="n">C</span> <span class="o">:=</span> <span class="n">Val3.Read</span><span class="p">;</span>
       <span class="kr">return</span><span class="p"> </span><span class="n">Conversion.Convert_To_Reading</span>
                <span class="o">(</span><span class="n">Val_A</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="p">,</span>
                 <span class="n">Val_B</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="p">,</span>
                 <span class="n">Val_C</span> <span class="o">=&gt;</span> <span class="n">C</span><span class="o">)</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">ReadValue</span><span class="p">;</span>

<span class="k">end </span><span class="nf">Switch</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Abstract Switch specification in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Switch</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State</span> <span class="kr">with</span><span class="p"> </span><span class="n">External</span> <span class="o">=&gt;</span> <span class="n">Async_Writers</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="kr">type</span><span class="p"> </span><span class="n">Reading</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">on</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">unknown</span><span class="o">)</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">ReadValue</span> <span class="kr">return</span><span class="p"> </span><span class="n">Reading</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Volatile_Function</span><span class="p">,</span>
          <span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Switch</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Component Switch specification in SPARK 2014:</p>
<p>As in <a class="reference internal" href="#refinement-of-external-state-voting-input-switch">Refinement of external state - voting input switch</a></p>
<p>Switch body in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">Switch.Val1</span><span class="p">,</span>
     <span class="n">Switch.Val2</span><span class="p">,</span>
     <span class="n">Switch.Val3</span><span class="p">;</span>

<span class="k">package body </span><span class="nf">Switch</span>
  <span class="c">--  State is refined onto three states, each of which has properties</span>
  <span class="c">--  Volatile and Input.</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Switch.Val1.State</span><span class="p">,</span>
                                   <span class="n">Switch.Val2.State</span><span class="p">,</span>
                                   <span class="n">Switch.Val3.State</span><span class="o">))</span>
<span class="kr">is</span><span class="p"></span>
   <span class="kr">subtype</span><span class="p"> </span><span class="n">Value</span> <span class="kr">is</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">range</span><span class="p"> </span><span class="o">-</span><span class="mi">1</span> <span class="o">..</span> <span class="mi">1</span><span class="p">;</span>
   <span class="kr">subtype</span><span class="p"> </span><span class="n">Score</span> <span class="kr">is</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">range</span><span class="p"> </span><span class="o">-</span><span class="mi">3</span> <span class="o">..</span> <span class="mi">3</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">ReadValue</span> <span class="kr">return</span><span class="p"> </span><span class="n">Reading</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Val1.State</span><span class="p">,</span> <span class="n">Val2.State</span><span class="p">,</span> <span class="n">Val3.State</span><span class="o">))</span>
   <span class="kr">is</span><span class="p"></span>
      <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Reading</span><span class="p">;</span>

      <span class="c">--  Embedded package to provide the capability to synthesize three inputs</span>
      <span class="c">--  into one.</span>
      <span class="k">package </span><span class="nf">Conversion</span> <span class="kr">is</span><span class="p"></span>
         <span class="k">function </span><span class="nf">Convert_To_Reading</span>
           <span class="o">(</span><span class="n">Val_A</span> <span class="o">:</span> <span class="n">Switch.Reading</span><span class="p">;</span>
            <span class="n">Val_B</span> <span class="o">:</span> <span class="n">Switch.Reading</span><span class="p">;</span>
            <span class="n">Val_C</span> <span class="o">:</span> <span class="n">Switch.Reading</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Switch.Reading</span><span class="p">;</span>
      <span class="k">end </span><span class="nf">Conversion</span><span class="p">;</span>

      <span class="k">package body </span><span class="nf">Conversion</span> <span class="kr">is</span><span class="p"></span>
         <span class="kr">type</span><span class="p"> </span><span class="n">ConvertToValueArray</span> <span class="kr">is</span><span class="p"> </span><span class="kr">array</span><span class="p"> </span><span class="o">(</span><span class="n">Switch.Reading</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Switch.Value</span><span class="p">;</span>
         <span class="kr">type</span><span class="p"> </span><span class="n">ConvertToReadingArray</span> <span class="kr">is</span><span class="p"> </span><span class="kr">array</span><span class="p"> </span><span class="o">(</span><span class="n">Switch.Score</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Switch.Reading</span><span class="p">;</span>
         <span class="n">ConvertToValue</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="n">ConvertToValueArray</span> <span class="o">:=</span>
           <span class="n">ConvertToValueArray</span><span class="o">&#39;(</span><span class="n">Switch.on</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span>
                                <span class="n">Switch.unknown</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">,</span>
                                <span class="n">Switch.off</span> <span class="o">=&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span><span class="p">;</span>

         <span class="n">ConvertToReading</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="n">ConvertToReadingArray</span> <span class="o">:=</span>
           <span class="n">ConvertToReadingArray</span><span class="o">&#39;(-</span><span class="mi">3</span> <span class="o">..</span> <span class="o">-</span><span class="mi">2</span> <span class="o">=&gt;</span> <span class="n">Switch.off</span><span class="p">,</span>
                                  <span class="o">-</span><span class="mi">1</span> <span class="o">..</span> <span class="mi">1</span>  <span class="o">=&gt;</span> <span class="n">Switch.unknown</span><span class="p">,</span>
                                   <span class="mi">2</span> <span class="o">..</span> <span class="mi">3</span>  <span class="o">=&gt;</span> <span class="n">Switch.on</span><span class="o">)</span><span class="p">;</span>

         <span class="k">function </span><span class="nf">Convert_To_Reading</span>
            <span class="o">(</span><span class="n">Val_A</span> <span class="o">:</span> <span class="n">Switch.Reading</span><span class="p">;</span>
             <span class="n">Val_B</span> <span class="o">:</span> <span class="n">Switch.Reading</span><span class="p">;</span>
             <span class="n">Val_C</span> <span class="o">:</span> <span class="n">Switch.Reading</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Switch.Reading</span> <span class="kr">is</span><span class="p"></span>
           <span class="o">(</span><span class="n">ConvertToReading</span> <span class="o">(</span><span class="n">ConvertToValue</span> <span class="o">(</span><span class="n">Val_A</span><span class="o">)</span> <span class="o">+</span>
                              <span class="n">ConvertToValue</span> <span class="o">(</span><span class="n">Val_B</span><span class="o">)</span> <span class="o">+</span>
                              <span class="n">ConvertToValue</span> <span class="o">(</span><span class="n">Val_C</span><span class="o">)))</span><span class="p">;</span>
      <span class="k">end </span><span class="nf">Conversion</span><span class="p">;</span>
   <span class="kr">begin</span><span class="p"> </span> <span class="c">--  begin statement of ReadValue function</span>
      <span class="n">A</span> <span class="o">:=</span> <span class="n">Val1.Read</span><span class="p">;</span>
      <span class="n">B</span> <span class="o">:=</span> <span class="n">Val2.Read</span><span class="p">;</span>
      <span class="n">C</span> <span class="o">:=</span> <span class="n">Val3.Read</span><span class="p">;</span>
      <span class="kr">return</span><span class="p"> </span><span class="n">Conversion.Convert_To_Reading</span>
               <span class="o">(</span><span class="n">Val_A</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="p">,</span>
                <span class="n">Val_B</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="p">,</span>
                <span class="n">Val_C</span> <span class="o">=&gt;</span> <span class="n">C</span><span class="o">)</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">ReadValue</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Switch</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="circular-dependence-and-elaboration-order">
<span id="ms-circular-dependence-and-elaboration-order-label"></span><h4>Circular dependence and elaboration order<a class="headerlink" href="#circular-dependence-and-elaboration-order" title="Permalink to this headline">¶</a></h4>
<p>SPARK 2005 avoided issues of circular dependence and elaboration order
dependencies through a combination of the inherit annotation and the
restrictions that initialization expressions are constant, user
defined subprograms cannot be called in the sequence of statements of
a package body and a package can only initialize variables declared in
its delarative part.</p>
<p>SPARK 2014 does not have the inherit annotation and only enforces the
restriction that a package can only initialize an object declared in
its declarative region. Hence, in SPARK 2014 two package bodies that
depend on each other&#8217;s specification may be legal, as is calling a user
defined suprogram.</p>
<p>Instead of the elaboration restrictions of SPARK 2005 a set of rules
is applied in SPARK 2014 which determines when elaboration order control
pragmas such as Elaborate_Body or Elaborate_All are required.  These
rules ensure the absence of elaboration order dependencies.</p>
<p>Examples of the features of SPARK 2014 elaboration order rules are given
below. In the example described below the partial elaboration order
would be either of P_14 or Q_14 specifications first followed by P_14
body because of the Elaborate_All on the specification of R_14
specification and the body of Q_14, then the elaboration of Q_14 body
or the specification of R_14 and the body of R_14 after the
elaboration of Q_14. Elaboration order dependencies are avoided by
the (required) use of elaboration control pragmas.</p>
<p>Package Specifications in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">P_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="n">P_State</span><span class="p">,</span>
       <span class="n">Initializes</span>    <span class="o">=&gt;</span> <span class="o">(</span><span class="n">P_State</span><span class="p">,</span> <span class="n">Global_Var</span><span class="o">)</span><span class="p">,</span>
       <span class="n">Elaborate_Body</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">Global_Var</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Init</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">P_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Q_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="n">Q_State</span><span class="p">,</span>
       <span class="n">Initializes</span>    <span class="o">=&gt;</span> <span class="n">Q_State</span>
<span class="kr">is</span><span class="p"></span>
   <span class="kr">type</span><span class="p"> </span><span class="n">T</span> <span class="kr">is</span><span class="p"> </span><span class="kr">new</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Init</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">T</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Q_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">P_14</span><span class="p">;</span>
<span class="kr">pragma</span><span class="p"> </span><span class="n">Elaborate_All</span> <span class="o">(</span><span class="n">P_14</span><span class="o">)</span><span class="p">;</span> <span class="c">-- Required because P_14.Global_Var</span>
                             <span class="c">-- Is mentioned as input in the Initializes aspect</span>
<span class="k">package </span><span class="nf">R_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="p">,</span>
       <span class="n">Initializes</span>    <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State</span> <span class="o">=&gt;</span> <span class="n">P_14.Global_Var</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Op</span> <span class="o">(</span> <span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Positive</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">R_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Package Bodies in SPARK 2014</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">Q_14</span><span class="p">;</span>

<span class="k">package body </span><span class="nf">P_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">P_State</span> <span class="o">=&gt;</span> <span class="n">P_S</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">P_S</span> <span class="o">:</span> <span class="n">Q_14.T</span><span class="p">;</span>  <span class="c">-- The use of type Q.T does not require</span>
                  <span class="c">-- the body of Q to be elaborated.</span>

   <span class="k">procedure </span><span class="nf">Init</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span> <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">S</span> <span class="o">:=</span> <span class="mi">5</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Init</span><span class="p">;</span>
<span class="kr">begin</span><span class="p"></span>
   <span class="c">-- Cannot call Q_14.Init here beacuse</span>
   <span class="c">-- this would require an Elaborate_All for Q_14</span>
   <span class="c">-- and would be detected as a circularity</span>
   <span class="n">Init</span> <span class="o">(</span><span class="n">Global_Var</span><span class="o">)</span><span class="p">;</span>
   <span class="n">P_S</span> <span class="o">:=</span> <span class="n">Q_14.T</span> <span class="o">(</span><span class="n">Global_Var</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">P_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">P_14</span><span class="p">;</span>
<span class="kr">pragma</span><span class="p"> </span><span class="n">Elaborate_All</span> <span class="o">(</span><span class="n">P_14</span><span class="o">)</span><span class="p">;</span> <span class="c">-- Required because the elaboration of the</span>
                             <span class="c">-- body of Q_14 (indirectly) calls P_14.Init</span>
<span class="k">package body </span><span class="nf">Q_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Q_State</span> <span class="o">=&gt;</span> <span class="n">Q_S</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">Q_S</span> <span class="o">:</span> <span class="n">T</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Init</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">T</span><span class="o">)</span> <span class="kr">is</span><span class="p"></span>
      <span class="n">V</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">P_14.Init</span> <span class="o">(</span><span class="n">V</span><span class="o">)</span><span class="p">;</span>
      <span class="kr">if</span><span class="p"> </span><span class="n">V</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="kr">and</span><span class="p"> </span><span class="kr">then</span><span class="p"> </span> <span class="n">V</span> <span class="o">&lt;=</span> <span class="n">Integer</span><span class="na">&#39;Last</span> <span class="o">-</span> <span class="mi">5</span> <span class="kr">then</span><span class="p"></span>
         <span class="n">S</span> <span class="o">:=</span> <span class="n">T</span><span class="o">(</span><span class="n">V</span> <span class="o">+</span> <span class="mi">5</span><span class="o">)</span><span class="p">;</span>
      <span class="kr">else</span><span class="p"></span>
         <span class="n">S</span> <span class="o">:=</span> <span class="mi">5</span><span class="p">;</span>
      <span class="k">end if</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Init</span><span class="p">;</span>
<span class="kr">begin</span><span class="p"></span>
   <span class="n">Init</span> <span class="o">(</span><span class="n">Q_S</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Q_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">Q_14</span><span class="p">;</span>
<span class="kr">pragma</span><span class="p"> </span><span class="n">Elaborate_All</span> <span class="o">(</span><span class="n">Q_14</span><span class="o">)</span><span class="p">;</span> <span class="c">-- Required because Q_14.Init is called</span>
                             <span class="c">-- in the elaboration of the body of R_14</span>
<span class="kr">use</span><span class="p"> </span><span class="kr">type</span><span class="p"> </span><span class="n">Q_14.T</span><span class="p">;</span>

<span class="k">package body </span><span class="nf">R_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State</span> <span class="o">=&gt;</span> <span class="n">R_S</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">R_S</span> <span class="o">:</span> <span class="n">Q_14.T</span><span class="p">;</span>
   <span class="k">procedure </span><span class="nf">Op</span> <span class="o">(</span> <span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Positive</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">R_S</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="kr">if</span><span class="p"> </span><span class="n">R_S</span> <span class="o">&lt;=</span> <span class="n">Q_14.T</span><span class="na">&#39;Last</span> <span class="o">-</span> <span class="n">Q_14.T</span> <span class="o">(</span><span class="n">X</span><span class="o">)</span> <span class="kr">then</span><span class="p"></span>
         <span class="n">R_S</span> <span class="o">:=</span> <span class="n">R_S</span> <span class="o">+</span> <span class="n">Q_14.T</span> <span class="o">(</span><span class="n">X</span><span class="o">)</span><span class="p">;</span>
      <span class="kr">else</span><span class="p"></span>
         <span class="n">R_S</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">end if</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Op</span><span class="p">;</span>
<span class="kr">begin</span><span class="p"></span>
   <span class="n">Q_14.Init</span> <span class="o">(</span><span class="n">R_S</span><span class="o">)</span><span class="p">;</span>
   <span class="kr">if</span><span class="p"> </span><span class="n">P_14.Global_Var</span> <span class="o">&gt;</span> <span class="mi">0</span>
     <span class="kr">and</span><span class="p"> </span><span class="kr">then</span><span class="p"> </span><span class="n">R_S</span> <span class="o">&lt;=</span> <span class="n">Q_14.T</span><span class="na">&#39;Last</span> <span class="o">-</span> <span class="n">Q_14.T</span> <span class="o">(</span><span class="n">P_14.Global_Var</span><span class="o">)</span>
   <span class="kr">then</span><span class="p"></span>
      <span class="n">R_S</span> <span class="o">:=</span> <span class="n">R_S</span> <span class="o">+</span> <span class="n">Q_14.T</span> <span class="o">(</span><span class="n">P_14.Global_Var</span><span class="o">)</span><span class="p">;</span>
   <span class="kr">else</span><span class="p"></span>
      <span class="n">R_S</span> <span class="o">:=</span> <span class="n">Q_14.T</span> <span class="o">(</span><span class="n">P_14.Global_Var</span><span class="o">)</span><span class="p">;</span>
   <span class="k">end if</span><span class="p">;</span>
<span class="k">end </span><span class="nf">R_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
</div>
</div>
<div class="section" id="bodies-and-proof">
<h2>Bodies and Proof<a class="headerlink" href="#bodies-and-proof" title="Permalink to this headline">¶</a></h2>
<div class="section" id="assert-assume-check-contracts">
<h3>Assert, Assume, Check contracts<a class="headerlink" href="#assert-assume-check-contracts" title="Permalink to this headline">¶</a></h3>
<div class="section" id="assert-in-loop-contract">
<span id="ms-assert-loop-contract-label"></span><h4>Assert (in loop) contract<a class="headerlink" href="#assert-in-loop-contract" title="Permalink to this headline">¶</a></h4>
<p>The following example demonstrates how the SPARK 2005 <cite>assert</cite>
annotation is used inside a loop as a loop invariant. It cuts the loop
and on each iteration of the loop the list of existing hypotheses
for the path is cleared. A verification condition is generated to prove
that the assert expression is True, and the expression is the basis of
the new hypotheses.</p>
<p>SPARK 2014 has a specific pragma for defining a loop invariant, <cite>pragma
Loop_Invariant</cite> which is more sophisticated than the SPARK 2005 assert
annotation and often requires less conditions in the invariant
expression than in SPARK 2005. As in SPARK 2005 a default loop
invariant will be used if one is not provided which, often, may be
sufficient to prove absence of run-time exceptions. Like all
SPARK 2014 assertion expressions the loop invariant is executable.</p>
<p>Note in the example below the SPARK 2014 version proves absence of
run-time exceptions without an explicit loop invariant being provided.</p>
<p>Specification in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Assert_Loop_05</span>
<span class="kr">is</span><span class="p"></span>
   <span class="kr">subtype</span><span class="p"> </span><span class="n">Index</span> <span class="kr">is</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">range</span><span class="p"> </span><span class="mi">1</span> <span class="o">..</span> <span class="mi">10</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span><span class="n">A_Type</span> <span class="kr">is</span><span class="p"> </span><span class="kr">Array</span><span class="p"> </span><span class="o">(</span><span class="n">Index</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Value_present</span> <span class="o">(</span><span class="n">A</span><span class="o">:</span> <span class="n">A_Type</span><span class="p">;</span> <span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span><span class="p">;</span>
   <span class="c">--# return for some M in Index =&gt; (A (M) = X);</span>
<span class="k">end </span><span class="nf">Assert_Loop_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Assert_Loop_05</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">Value_Present</span> <span class="o">(</span><span class="n">A</span><span class="o">:</span> <span class="n">A_Type</span><span class="p">;</span> <span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span>
   <span class="kr">is</span><span class="p"></span>
      <span class="n">I</span> <span class="o">:</span> <span class="n">Index</span> <span class="o">:=</span> <span class="n">Index</span><span class="na">&#39;First</span><span class="p">;</span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="kr">while</span><span class="p"> </span><span class="n">A</span> <span class="o">(</span><span class="n">I</span><span class="o">)</span> <span class="o">/=</span> <span class="n">X</span> <span class="kr">and</span><span class="p"> </span><span class="n">I</span> <span class="o">&lt;</span> <span class="n">Index</span><span class="na">&#39;Last</span> <span class="kr">loop</span><span class="p"></span>
         <span class="c">--# assert I &lt; Index&#39;Last and</span>
         <span class="c">--#        (for all M in Index range Index&#39;First .. I =&gt; (A (M) /= X));</span>
         <span class="n">I</span> <span class="o">:=</span> <span class="n">I</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">end loop</span><span class="p">;</span>
      <span class="kr">return</span><span class="p"> </span><span class="n">A</span> <span class="o">(</span><span class="n">I</span><span class="o">)</span> <span class="o">=</span> <span class="n">X</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Value_Present</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Assert_Loop_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specification in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Assert_Loop_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span>
<span class="kr">is</span><span class="p"></span>
   <span class="kr">subtype</span><span class="p"> </span><span class="n">Index</span> <span class="kr">is</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">range</span><span class="p"> </span><span class="mi">1</span> <span class="o">..</span> <span class="mi">10</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span><span class="n">A_Type</span> <span class="kr">is</span><span class="p"> </span><span class="kr">Array</span><span class="p"> </span><span class="o">(</span><span class="n">Index</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Value_present</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">A_Type</span><span class="p">;</span> <span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Post</span> <span class="o">=&gt;</span> <span class="n">Value_present</span><span class="na">&#39;Result</span> <span class="o">=</span> <span class="o">(</span><span class="kr">for</span><span class="p"> </span><span class="kr">some</span><span class="p"> </span><span class="n">M</span> <span class="kr">in</span><span class="p"> </span><span class="n">Index</span> <span class="o">=&gt;</span> <span class="n">A</span> <span class="o">(</span><span class="n">M</span><span class="o">)</span> <span class="o">=</span> <span class="n">X</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Assert_Loop_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Assert_Loop_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">Value_Present</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">A_Type</span><span class="p">;</span> <span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span> <span class="kr">is</span><span class="p"></span>
      <span class="n">I</span> <span class="o">:</span> <span class="n">Index</span> <span class="o">:=</span> <span class="n">Index</span><span class="na">&#39;First</span><span class="p">;</span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="kr">while</span><span class="p"> </span><span class="n">A</span> <span class="o">(</span><span class="n">I</span><span class="o">)</span> <span class="o">/=</span> <span class="n">X</span> <span class="kr">and</span><span class="p"> </span><span class="n">I</span> <span class="o">&lt;</span> <span class="n">Index</span><span class="na">&#39;Last</span> <span class="kr">loop</span><span class="p"></span>
         <span class="kr">pragma</span><span class="p"> </span><span class="n">Loop_Invariant</span>
           <span class="o">(</span><span class="n">I</span> <span class="o">&lt;</span> <span class="n">Index</span><span class="na">&#39;Last</span>
            <span class="kr">and</span><span class="p"> </span><span class="o">(</span><span class="kr">for</span><span class="p"> </span><span class="kr">all</span><span class="p"> </span><span class="n">M</span> <span class="kr">in</span><span class="p"> </span><span class="n">Index</span><span class="na">&#39;First</span> <span class="o">..</span> <span class="n">I</span> <span class="o">=&gt;</span> <span class="n">A</span> <span class="o">(</span><span class="n">M</span><span class="o">)</span> <span class="o">/=</span> <span class="n">X</span><span class="o">))</span><span class="p">;</span>
         <span class="n">I</span> <span class="o">:=</span> <span class="n">I</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">end loop</span><span class="p">;</span>

      <span class="kr">return</span><span class="p"> </span><span class="n">A</span> <span class="o">(</span><span class="n">I</span><span class="o">)</span> <span class="o">=</span> <span class="n">X</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Value_Present</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Assert_Loop_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="assert-no-loop-contract">
<span id="ms-assert-no-loop-contract-label"></span><h4>Assert (no loop) contract<a class="headerlink" href="#assert-no-loop-contract" title="Permalink to this headline">¶</a></h4>
<p>While not in a loop, the SPARK 2005 <cite>assert</cite> annotation maps to
<cite>pragma Assert_And_Cut</cite> in SPARK 2014. Both the assert annotation and
pragma assert clear the list of hypotheses on the path, generate a
verification condition to prove the assertion expression and use the
assertion expression as the basis of the new hypotheses.</p>
</div>
<div class="section" id="assume-contract">
<span id="ms-proof-assume-contract-label"></span><h4>Assume contract<a class="headerlink" href="#assume-contract" title="Permalink to this headline">¶</a></h4>
<p>The following example illustrates use of an Assume annotation.  The
assumed expression does not generate a verification condition and is
not proved (although it is executed in SPARK 2014 if assertion
expressions are not ignored at run-time).</p>
<p>In this example, the Assume annotation is effectively being used to
implement the SPARK 2005 Always_Valid attribute.</p>
<p>Specification for Assume annotation in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Input_Port</span>
  <span class="c">--# own in Inputs;</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Read_From_Port</span><span class="o">(</span><span class="n">Input_Value</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--# global in Inputs;</span>
   <span class="c">--# derives Input_Value from Inputs;</span>

<span class="k">end </span><span class="nf">Input_Port</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body for Assume annotation in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">System.Storage_Elements</span><span class="p">;</span>
<span class="k">package body </span><span class="nf">Input_Port</span>
<span class="kr">is</span><span class="p"></span>

   <span class="n">Inputs</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="kr">for</span><span class="p"> </span><span class="n">Inputs</span><span class="na">&#39;Address</span> <span class="kr">use</span><span class="p"> </span><span class="n">System.Storage_Elements.To_Address</span> <span class="o">(</span><span class="mi">16#CAFE0#</span><span class="o">)</span><span class="p">;</span>
   <span class="kr">pragma</span><span class="p"> </span><span class="n">Volatile</span> <span class="o">(</span><span class="n">Inputs</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Read_From_Port</span><span class="o">(</span><span class="n">Input_Value</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="c">--# assume Inputs in Integer;</span>
      <span class="n">Input_Value</span> <span class="o">:=</span> <span class="n">Inputs</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Read_From_Port</span><span class="p">;</span>

<span class="k">end </span><span class="nf">Input_Port</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specification for Assume annotation in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Input_Port</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State_Inputs</span> <span class="kr">with</span><span class="p"> </span><span class="n">External</span> <span class="o">=&gt;</span> <span class="n">Async_Writers</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Read_From_Port</span><span class="o">(</span><span class="n">Input_Value</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span> <span class="o">=&gt;</span> <span class="n">State_Inputs</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input_Value</span> <span class="o">=&gt;</span> <span class="n">State_Inputs</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Input_Port</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body for Assume annotation in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">System.Storage_Elements</span><span class="p">;</span>

<span class="k">package body </span><span class="nf">Input_Port</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State_Inputs</span> <span class="o">=&gt;</span> <span class="n">Inputs</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">Inputs</span> <span class="o">:</span> <span class="n">Integer</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Volatile</span><span class="p">,</span>
          <span class="n">Async_Writers</span><span class="p">,</span>
          <span class="n">Address</span> <span class="o">=&gt;</span> <span class="n">System.Storage_Elements.To_Address</span> <span class="o">(</span><span class="mi">16#CAFE0#</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Read_From_Port</span><span class="o">(</span><span class="n">Input_Value</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span> <span class="o">=&gt;</span> <span class="n">Inputs</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Refined_Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input_Value</span> <span class="o">=&gt;</span> <span class="n">Inputs</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Input_Value</span> <span class="o">:=</span> <span class="n">Inputs</span><span class="p">;</span>
      <span class="kr">pragma</span><span class="p"> </span><span class="n">Assume</span><span class="o">(</span><span class="n">Input_Value</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Read_From_Port</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Input_Port</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="check-contract">
<span id="ms-check-contract-label"></span><h4>Check contract<a class="headerlink" href="#check-contract" title="Permalink to this headline">¶</a></h4>
<p>The SPARK 2005 <cite>check</cite> annotation is replaced by <cite>pragma assert</cite> in
SPARK 2014. This annotation generates a verification condition to prove
the checked expression and adds the expression as a new hypothesis to
the list of existing hypotheses.</p>
<p>Specification for Check annotation in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Check_05</span>
<span class="kr">is</span><span class="p"></span>
   <span class="kr">subtype</span><span class="p"> </span><span class="n">Small</span> <span class="kr">is</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">range</span><span class="p"> </span><span class="mi">1</span> <span class="o">..</span> <span class="mi">10</span><span class="p">;</span>
   <span class="kr">subtype</span><span class="p"> </span><span class="n">Big</span>   <span class="kr">is</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">range</span><span class="p"> </span><span class="mi">1</span> <span class="o">..</span> <span class="mi">21</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Compare</span><span class="o">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Small</span><span class="p">;</span> <span class="n">C</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Big</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Check_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body for Check annotation in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Check_05</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Compare</span><span class="o">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Small</span><span class="p">;</span> <span class="n">C</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Big</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="kr">if</span><span class="p"> </span><span class="o">(</span><span class="n">A</span> <span class="o">+</span> <span class="n">B</span> <span class="o">&gt;=</span> <span class="n">C</span><span class="o">)</span> <span class="kr">then</span><span class="p"></span>
	 <span class="n">C</span> <span class="o">:=</span> <span class="n">A</span><span class="p">;</span>
	 <span class="n">C</span> <span class="o">:=</span> <span class="n">C</span> <span class="o">+</span> <span class="n">B</span><span class="p">;</span>
	 <span class="n">C</span> <span class="o">:=</span> <span class="n">C</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">end if</span><span class="p">;</span>
      <span class="c">--# check A + B &lt; C;</span>
   <span class="k">end </span><span class="nf">Compare</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Check_05</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specification for Check annotation in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Check_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span>
<span class="kr">is</span><span class="p"></span>
   <span class="kr">subtype</span><span class="p"> </span><span class="n">Small</span> <span class="kr">is</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">range</span><span class="p"> </span><span class="mi">1</span> <span class="o">..</span> <span class="mi">10</span><span class="p">;</span>
   <span class="kr">subtype</span><span class="p"> </span><span class="n">Big</span>   <span class="kr">is</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">range</span><span class="p"> </span><span class="mi">1</span> <span class="o">..</span> <span class="mi">21</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Compare</span> <span class="o">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Small</span><span class="p">;</span> <span class="n">C</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Big</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Check_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body for Check annotation in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Check_14</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Compare</span><span class="o">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Small</span><span class="p">;</span> <span class="n">C</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Big</span><span class="o">)</span> <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="kr">if</span><span class="p"> </span><span class="n">A</span> <span class="o">+</span> <span class="n">B</span> <span class="o">&gt;=</span> <span class="n">C</span> <span class="kr">then</span><span class="p"></span>
	 <span class="n">C</span> <span class="o">:=</span> <span class="n">A</span><span class="p">;</span>
	 <span class="n">C</span> <span class="o">:=</span> <span class="n">C</span> <span class="o">+</span> <span class="n">B</span><span class="p">;</span>
	 <span class="n">C</span> <span class="o">:=</span> <span class="n">C</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">end if</span><span class="p">;</span>
      <span class="kr">pragma</span><span class="p"> </span><span class="n">Assert</span> <span class="o">(</span><span class="n">A</span> <span class="o">+</span> <span class="n">B</span> <span class="o">&lt;</span> <span class="n">C</span><span class="o">)</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Compare</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Check_14</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
</div>
<div class="section" id="assert-used-to-control-path-explosion">
<h3>Assert used to control path explosion<a class="headerlink" href="#assert-used-to-control-path-explosion" title="Permalink to this headline">¶</a></h3>
<p>This capability is in general not needed with the SPARK 2014 toolset where
path explosion is handled automatically. In the rare cases where this is
needed you can use <cite>pragma Assert_And_Cut</cite>.</p>
</div>
</div>
<div class="section" id="other-contracts-and-annotations">
<h2>Other Contracts and Annotations<a class="headerlink" href="#other-contracts-and-annotations" title="Permalink to this headline">¶</a></h2>
<div class="section" id="always-valid-assertion">
<h3>Always_Valid assertion<a class="headerlink" href="#always-valid-assertion" title="Permalink to this headline">¶</a></h3>
<p>See section <a class="reference internal" href="#input-driver-using-tail-in-a-contract">Input driver using &#8216;Tail in a contract</a> for use of an assertion involving
the Always_Valid attribute.</p>
</div>
<div class="section" id="rule-declaration-annotation">
<h3>Rule declaration annotation<a class="headerlink" href="#rule-declaration-annotation" title="Permalink to this headline">¶</a></h3>
<p>See section <a class="reference internal" href="#proof-types-and-proof-functions">Proof types and proof functions</a>.</p>
</div>
<div class="section" id="proof-types-and-proof-functions">
<span id="ms-proof-types-and-proof-functions-label"></span><h3>Proof types and proof functions<a class="headerlink" href="#proof-types-and-proof-functions" title="Permalink to this headline">¶</a></h3>
<p>The following example gives pre- and postconditions on operations that
act upon the concrete representation of an abstract own variable. This
means that proof functions and proof types are needed to state those
pre- and postconditions. In addition, it gives an example of the use
of a rule declaration annotation - in the body of procedure
Initialize - to introduce a rule related to the components of a
constant record value.</p>
<p>SPARK 2014 does not have a direct equivalent of proof types and proof
functions. State abstractions cannot have a type and all functions in
SPARK 2014 are Ada functions.  Functions may be defined to be ghost functions
which means that they can only be called within an
assertion expression such as a pre or postcondition. Assertion
expressions may be executed or ignored at run-time and if they are
ignored Ghost functions behave much like SPARK 2005 proof functions.</p>
<p>Rule declaration annotations for structured constants are not required in SPARK 2014.</p>
<p>The SPARK 2005 version of the example given below will require user
defined proof rules to discharge the proofs because refined
definitions of some of the proof functions cannot be provided as they
would have different formal parameters. The SPARK 2014 version does not
suffer from this problem as functions called within assertion expressions
may have global items.</p>
<p>Specification in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Stack</span>
<span class="c">--# own State : Abstract_Stack;</span>
<span class="kr">is</span><span class="p"></span>
   <span class="c">--  It is not possible to specify that the stack will be</span>
   <span class="c">--  initialized to empty except by having an initialization</span>
   <span class="c">--  subprogram called during program execution (as opposed to</span>
   <span class="c">--  package elaboration).</span>

   <span class="c">--  Proof functions to indicate whether or not the Stack is empty</span>
   <span class="c">--  and whether or not it is full.</span>
   <span class="c">--# type Abstract_Stack is abstract;</span>

   <span class="c">--# function Max_Stack_Size return Natural;</span>

   <span class="c">--  Proof function to give the number of elements on the stack.</span>
   <span class="c">--# function Count(Input : Abstract_Stack) return Natural;</span>

   <span class="c">--  Proof function returns the Nth entry on the stack.</span>
   <span class="c">--  Stack_Entry (Count (State)) is the top of stack</span>
   <span class="c">--# function Stack_Entry (N : Natural; S : Abstract_Stack) return Integer;</span>
   <span class="c">--# pre N in 1 .. Count (S);</span>
   <span class="c">--  A refined version of this function cannot be written because</span>
   <span class="c">--  the abstract view has a formal parameter of type Abstract_Stack</span>
   <span class="c">--  whereas the refined view would not have this parameter but use</span>
   <span class="c">--  a global. A user defined proof rule would be required to define</span>
   <span class="c">--  this function. Alternatively, it could be written as an Ada</span>
   <span class="c">--  function where the the global and formal parameter views would</span>
   <span class="c">--  be available. However, the function would then be callable and</span>
   <span class="c">--  generate implementation code.</span>

   <span class="c">--# function Is_Empty(Input : Abstract_Stack) return Boolean;</span>
   <span class="c">--# return Count (Input) = 0;</span>

   <span class="c">--# function Is_Full(Input : Abstract_Stack) return Boolean;</span>
   <span class="c">--# return Count (Input) = Max_Stack_Size;</span>

   <span class="c">--  The precondition requires the stack is not full when a value, X,</span>
   <span class="c">--  is pushed onto it.</span>
   <span class="c">--  The postcondition indicates that the count of the stack will be</span>
   <span class="c">--  incremented after a push and therefore the stack will be non-empty.</span>
   <span class="c">--  The item X is now the top of the stack.</span>
   <span class="k">procedure </span><span class="nf">Push</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--# global in out State;</span>
   <span class="c">--# pre  not Is_Full(State);</span>
   <span class="c">--# post Count (State) = Count (State~) + 1 and</span>
   <span class="c">--#      Count (State) &lt;= Max_Stack_Size and</span>
   <span class="c">--#      Stack_Entry (Count (State), State) = X;</span>

   <span class="c">--  The precondition requires the stack is not empty when we</span>
   <span class="c">--  pull a value from it.</span>
   <span class="c">--  The postcondition indicates the stack count is decremented.</span>
   <span class="k">procedure </span><span class="nf">Pop</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--# global in out State;</span>
   <span class="c">--# pre not Is_Empty (State);</span>
   <span class="c">--# post Count (State) = Count (State~) - 1;</span>

   <span class="c">--  Procedure that swaps the first two elements in a stack.</span>
   <span class="k">procedure </span><span class="nf">Swap2</span><span class="p">;</span>
   <span class="c">--# global in out State;</span>
   <span class="c">--# pre  Count(State) &gt;= 2;</span>
   <span class="c">--# post Count(State) =  Count(State~) and</span>
   <span class="c">--#      Stack_Entry (Count (State), State) =</span>
   <span class="c">--#         Stack_Entry (Count (State) - 1, State~) and</span>
   <span class="c">--#      Stack_Entry (Count (State) - 1, State) =</span>
   <span class="c">--#         Stack_Entry (Count (State), State~);</span>

   <span class="c">--  Initializes the Stack.</span>
   <span class="k">procedure </span><span class="nf">Initialize</span><span class="p">;</span>
   <span class="c">--# global out State;</span>
   <span class="c">--# post Is_Empty (State);</span>
<span class="k">end </span><span class="nf">Stack</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Stack</span>
<span class="c">--# own State is My_Stack;</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">Stack_Size</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="o">:=</span> <span class="mi">100</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Pointer_Range</span> <span class="kr">is</span><span class="p"> </span><span class="kr">range</span><span class="p"> </span><span class="mi">0</span> <span class="o">..</span> <span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">subtype</span><span class="p"> </span><span class="n">Index_Range</span>   <span class="kr">is</span><span class="p"> </span><span class="n">Pointer_Range</span> <span class="kr">range</span><span class="p"> </span><span class="mi">1</span><span class="o">..</span><span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Vector</span>        <span class="kr">is</span><span class="p"> </span><span class="n">array</span><span class="o">(</span><span class="n">Index_Range</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>

   <span class="kr">type</span><span class="p"> </span><span class="n">Stack_Type</span> <span class="kr">is</span><span class="p"> </span><span class="kr">record</span><span class="p"></span>
      <span class="n">S</span> <span class="o">:</span> <span class="n">Vector</span><span class="p">;</span>
      <span class="n">Pointer</span> <span class="o">:</span> <span class="n">Pointer_Range</span><span class="p">;</span>
   <span class="k">end record</span><span class="p">;</span>

   <span class="n">Initial_Stack</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="n">Stack_Type</span> <span class="o">:=</span>
      <span class="n">Stack_Type</span><span class="o">&#39;(</span><span class="n">S</span>       <span class="o">=&gt;</span> <span class="n">Vector</span><span class="o">&#39;(</span><span class="kr">others</span><span class="p"> </span><span class="o">=&gt;</span> <span class="mi">0</span><span class="o">)</span><span class="p">,</span>
                  <span class="n">Pointer</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">)</span><span class="p">;</span>

   <span class="n">My_Stack</span> <span class="o">:</span> <span class="n">Stack_Type</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Push</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
   <span class="c">--# global in out My_Stack;</span>
   <span class="c">--# pre My_Stack.Pointer &lt; Stack_Size;</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">My_Stack.Pointer</span> <span class="o">:=</span> <span class="n">My_Stack.Pointer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">My_Stack.S</span><span class="o">(</span><span class="n">My_Stack.Pointer</span><span class="o">)</span> <span class="o">:=</span> <span class="n">X</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Push</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Pop</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
   <span class="c">--# global in out My_Stack;</span>
   <span class="c">--# pre My_Stack.Pointer &gt;= 1;</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">X</span> <span class="o">:=</span> <span class="n">My_Stack.S</span> <span class="o">(</span><span class="n">My_Stack.Pointer</span><span class="o">)</span><span class="p">;</span>
      <span class="n">My_Stack.Pointer</span> <span class="o">:=</span> <span class="n">My_Stack.Pointer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Pop</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Swap2</span>
   <span class="c">--# global in out My_Stack;</span>
   <span class="c">--# post My_Stack.Pointer = My_Stack~.Pointer;</span>
   <span class="kr">is</span><span class="p"></span>
      <span class="n">Temp</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Temp</span> <span class="o">:=</span> <span class="n">My_Stack.S</span> <span class="o">(</span><span class="mi">1</span><span class="o">)</span><span class="p">;</span>
      <span class="n">My_Stack.S</span> <span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">My_Stack.S</span> <span class="o">(</span><span class="mi">2</span><span class="o">)</span><span class="p">;</span>
      <span class="n">My_Stack.S</span> <span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Temp</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Swap2</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Initialize</span>
   <span class="c">--# global out My_Stack;</span>
   <span class="c">--# post My_Stack.Pointer = 0;</span>
   <span class="kr">is</span><span class="p"></span>
      <span class="c">--# for Initial_Stack declare Rule;</span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">My_Stack</span> <span class="o">:=</span> <span class="n">Initial_Stack</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Initialize</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Stack</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specification in SPARK 2014</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Stack</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span>    <span class="o">=&gt;</span> <span class="n">State</span><span class="p">,</span>
       <span class="n">Initializes</span>       <span class="o">=&gt;</span> <span class="n">State</span><span class="p">,</span>
       <span class="n">Initial_Condition</span> <span class="o">=&gt;</span> <span class="n">Is_Empty</span>
<span class="kr">is</span><span class="p"></span>
   <span class="c">--  In SPARK 2014 we can specify an initial condition for the</span>
   <span class="c">--  elaboration of a package and so initialization may be done</span>
   <span class="c">--  during the elaboration of the package Stack, rendering the need</span>
   <span class="c">--  for an initialization procedure unnecessary.</span>

   <span class="c">--  Abstract states do not have types in SPARK 2014 they can only</span>
   <span class="c">--  be directly referenced in Global and Depends aspects.</span>

   <span class="c">--  Proof functions are actual functions but they may have the</span>
   <span class="c">--  convention Ghost meaning that they can only be called from</span>
   <span class="c">--  assertion expressions, e.g., pre and postconditions</span>
   <span class="k">function </span><span class="nf">Max_Stack_Size</span> <span class="kr">return</span><span class="p"> </span><span class="n">Natural</span><span class="p"></span>
<span class="p">     </span><span class="kr">with</span><span class="nn"> Ghost;</span>

   <span class="c">-- Returns the number of elements on the stack</span>
   <span class="k">function </span><span class="nf">Count</span> <span class="kr">return</span><span class="p"> </span><span class="n">Natural</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>     <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Ghost</span><span class="p">;</span>

   <span class="c">--  Returns the Nth entry on the stack. Stack_Entry (Count) is the</span>
   <span class="c">--  top of stack</span>
   <span class="k">function </span><span class="nf">Stack_Entry</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">Natural</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>     <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Pre</span>        <span class="o">=&gt;</span> <span class="n">N</span> <span class="kr">in</span><span class="p"> </span><span class="mi">1</span> <span class="o">..</span> <span class="n">Count</span><span class="p">,</span>
          <span class="n">Ghost</span><span class="p">;</span>
   <span class="c">--  A body (refined) version of this function can (must) be</span>
   <span class="c">--  provided in the body of the package.</span>

   <span class="k">function </span><span class="nf">Is_Empty</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">Count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>     <span class="o">=&gt;</span> <span class="n">State</span><span class="p">,</span>
          <span class="n">Ghost</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Is_Full</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">Count</span> <span class="o">=</span> <span class="n">Max_Stack_Size</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>     <span class="o">=&gt;</span> <span class="n">State</span><span class="p">,</span>
          <span class="n">Ghost</span><span class="p">;</span>

   <span class="c">--  The precondition requires the stack is not full when a value,</span>
   <span class="c">--  X, is pushed onto it. Functions with global items (Is_Full</span>
   <span class="c">--  with global State in this case) can be called in an assertion</span>
   <span class="c">--  expression such as the precondition here.  The postcondition</span>
   <span class="c">--  indicates that the count of the stack will be incremented after</span>
   <span class="c">--  a push and therefore the stack will be non-empty.  The item X</span>
   <span class="c">--  is now the top of the stack.</span>
   <span class="k">procedure </span><span class="nf">Push</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Pre</span>    <span class="o">=&gt;</span> <span class="kr">not</span><span class="p"> </span><span class="n">Is_Full</span><span class="p">,</span>
          <span class="n">Post</span>   <span class="o">=&gt;</span> <span class="n">Count</span> <span class="o">=</span> <span class="n">Count</span><span class="na">&#39;Old</span> <span class="o">+</span> <span class="mi">1</span> <span class="kr">and</span><span class="p"></span>
                    <span class="n">Count</span> <span class="o">&lt;=</span> <span class="n">Max_Stack_Size</span> <span class="kr">and</span><span class="p"></span>
                    <span class="n">Stack_Entry</span> <span class="o">(</span><span class="n">Count</span><span class="o">)</span> <span class="o">=</span> <span class="n">X</span><span class="p">;</span>

   <span class="c">--  The precondition requires the stack is not empty when we pull a</span>
   <span class="c">--  value from it. The postcondition indicates the stack count is</span>
   <span class="c">--  decremented.</span>
   <span class="k">procedure </span><span class="nf">Pop</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Pre</span>    <span class="o">=&gt;</span> <span class="kr">not</span><span class="p"> </span><span class="n">Is_Empty</span><span class="p">,</span>
          <span class="n">Post</span>   <span class="o">=&gt;</span> <span class="n">Count</span> <span class="o">=</span> <span class="n">Count</span><span class="na">&#39;Old</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

   <span class="c">--  Procedure that swaps the top two elements in a stack.</span>
   <span class="k">procedure </span><span class="nf">Swap2</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Pre</span>    <span class="o">=&gt;</span> <span class="n">Count</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">,</span>
          <span class="n">Post</span>   <span class="o">=&gt;</span> <span class="n">Count</span> <span class="o">=</span> <span class="n">Count</span><span class="na">&#39;Old</span> <span class="kr">and</span><span class="p"></span>
                    <span class="n">Stack_Entry</span> <span class="o">(</span><span class="n">Count</span><span class="o">)</span> <span class="o">=</span> <span class="n">Stack_Entry</span> <span class="o">(</span><span class="n">Count</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span><span class="na">&#39;Old</span> <span class="kr">and</span><span class="p"></span>
                    <span class="n">Stack_Entry</span> <span class="o">(</span><span class="n">Count</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">=</span> <span class="n">Stack_Entry</span> <span class="o">(</span><span class="n">Count</span><span class="o">)</span><span class="na">&#39;Old</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Stack</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Stack</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State</span> <span class="o">=&gt;</span> <span class="n">My_Stack</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">Stack_Size</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="o">:=</span> <span class="mi">100</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Pointer_Range</span> <span class="kr">is</span><span class="p"> </span><span class="kr">range</span><span class="p"> </span><span class="mi">0</span> <span class="o">..</span> <span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">subtype</span><span class="p"> </span><span class="n">Index_Range</span>   <span class="kr">is</span><span class="p"> </span><span class="n">Pointer_Range</span> <span class="kr">range</span><span class="p"> </span><span class="mi">1</span> <span class="o">..</span> <span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Vector</span>        <span class="kr">is</span><span class="p"> </span><span class="n">array</span><span class="o">(</span><span class="n">Index_Range</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>

   <span class="kr">type</span><span class="p"> </span><span class="n">Stack_Type</span> <span class="kr">is</span><span class="p"> </span><span class="kr">record</span><span class="p"></span>
      <span class="n">S</span> <span class="o">:</span> <span class="n">Vector</span><span class="p">;</span>
      <span class="n">Pointer</span> <span class="o">:</span> <span class="n">Pointer_Range</span><span class="p">;</span>
   <span class="k">end record</span><span class="p">;</span>

   <span class="n">Initial_Stack</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="n">Stack_Type</span> <span class="o">:=</span>
     <span class="n">Stack_Type</span><span class="o">&#39;(</span><span class="n">S</span>       <span class="o">=&gt;</span> <span class="n">Vector</span><span class="o">&#39;(</span><span class="kr">others</span><span class="p"> </span><span class="o">=&gt;</span> <span class="mi">0</span><span class="o">)</span><span class="p">,</span>
                 <span class="n">Pointer</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">)</span><span class="p">;</span>
   <span class="n">My_Stack</span> <span class="o">:</span> <span class="n">Stack_Type</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Max_Stack_Size</span> <span class="kr">return</span><span class="p"> </span><span class="n">Natural</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">Stack_Size</span><span class="o">)</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Count</span> <span class="kr">return</span><span class="p"> </span><span class="n">Natural</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">Natural</span> <span class="o">(</span><span class="n">My_Stack.Pointer</span><span class="o">))</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="n">My_Stack</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Stack_Entry</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">Natural</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">is</span><span class="p"></span>
     <span class="o">(</span><span class="n">My_Stack.S</span> <span class="o">(</span><span class="n">Index_Range</span> <span class="o">(</span><span class="n">N</span><span class="o">)))</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="n">My_Stack</span><span class="p">;</span>


   <span class="k">procedure </span><span class="nf">Push</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">My_Stack</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">My_Stack.Pointer</span> <span class="o">:=</span> <span class="n">My_Stack.Pointer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">My_Stack.S</span><span class="o">(</span><span class="n">My_Stack.Pointer</span><span class="o">)</span> <span class="o">:=</span> <span class="n">X</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Push</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Pop</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">My_Stack</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">X</span> <span class="o">:=</span> <span class="n">My_Stack.S</span> <span class="o">(</span><span class="n">My_Stack.Pointer</span><span class="o">)</span><span class="p">;</span>
      <span class="n">My_Stack.Pointer</span> <span class="o">:=</span> <span class="n">My_Stack.Pointer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Pop</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Swap2</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">My_Stack</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
      <span class="n">Temp</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Temp</span> <span class="o">:=</span> <span class="n">My_Stack.S</span> <span class="o">(</span><span class="n">My_Stack.Pointer</span><span class="o">)</span><span class="p">;</span>
      <span class="n">My_Stack.S</span> <span class="o">(</span><span class="n">My_Stack.Pointer</span><span class="o">)</span> <span class="o">:=</span> <span class="n">My_Stack.S</span> <span class="o">(</span><span class="n">My_Stack.Pointer</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span><span class="p">;</span>
      <span class="n">My_Stack.S</span> <span class="o">(</span><span class="n">My_Stack.Pointer</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Temp</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Swap2</span><span class="p">;</span>
<span class="kr">begin</span><span class="p"></span>
   <span class="n">My_Stack</span> <span class="o">:=</span> <span class="n">Initial_Stack</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Stack</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="using-an-external-prover">
<h3>Using an External Prover<a class="headerlink" href="#using-an-external-prover" title="Permalink to this headline">¶</a></h3>
<p>One may wish to use an external prover such as Isabelle, with rules
defining a ghost function written in the prover input language. This
can be done in SPARK 2014 by denoting the ghost function as an Import in
lieu of providing a body for it. Of course such ghost functions cannot
be executed.</p>
<p>Specification in SPARK 2014 using an external prover:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Stack_External_Prover</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span>    <span class="o">=&gt;</span> <span class="n">State</span><span class="p">,</span>
       <span class="n">Initializes</span>       <span class="o">=&gt;</span> <span class="n">State</span><span class="p">,</span>
       <span class="n">Initial_Condition</span> <span class="o">=&gt;</span> <span class="n">Is_Empty</span>
<span class="kr">is</span><span class="p"></span>
   <span class="c">--  A Ghost function may be an Import which means that no body is</span>
   <span class="c">--  given in the SPARK 2014 code and the proof has to be discharged</span>
   <span class="c">--  by an external prover. Of course, such functions are not</span>
   <span class="c">--  executable.</span>
   <span class="k">function </span><span class="nf">Max_Stack_Size</span> <span class="kr">return</span><span class="p"> </span><span class="n">Natural</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="kr">null</span><span class="p">,</span>
          <span class="n">Ghost</span><span class="p">,</span>
          <span class="n">Import</span><span class="p">;</span>

   <span class="c">--  Returns the number of elements on the stack</span>
   <span class="k">function </span><span class="nf">Count</span> <span class="kr">return</span><span class="p"> </span><span class="n">Natural</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Ghost</span><span class="p">,</span>
          <span class="n">Import</span><span class="p">;</span>

   <span class="c">--  Returns the Nth entry on the stack. Stack_Entry (Count) is the</span>
   <span class="c">--  top of stack</span>
   <span class="k">function </span><span class="nf">Stack_Entry</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">Natural</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Ghost</span><span class="p">,</span>
          <span class="n">Import</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Is_Empty</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="p">,</span>
          <span class="n">Ghost</span><span class="p">,</span>
          <span class="n">Import</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Is_Full</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="p">,</span>
          <span class="n">Ghost</span><span class="p">,</span>
          <span class="n">Import</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Push</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Pre</span>    <span class="o">=&gt;</span> <span class="kr">not</span><span class="p"> </span><span class="n">Is_Full</span><span class="p">,</span>
          <span class="n">Post</span>   <span class="o">=&gt;</span> <span class="n">Count</span> <span class="o">=</span> <span class="n">Count</span><span class="na">&#39;Old</span> <span class="o">+</span> <span class="mi">1</span> <span class="kr">and</span><span class="p"> </span><span class="n">Count</span> <span class="o">&lt;=</span> <span class="n">Max_Stack_Size</span> <span class="kr">and</span><span class="p"></span>
                    <span class="n">Stack_Entry</span> <span class="o">(</span><span class="n">Count</span><span class="o">)</span> <span class="o">=</span> <span class="n">X</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Pop</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Pre</span>    <span class="o">=&gt;</span> <span class="kr">not</span><span class="p"> </span><span class="n">Is_Empty</span><span class="p">,</span>
          <span class="n">Post</span>   <span class="o">=&gt;</span> <span class="n">Count</span> <span class="o">=</span> <span class="n">Count</span><span class="na">&#39;Old</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Swap2</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Pre</span>    <span class="o">=&gt;</span> <span class="n">Count</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">,</span>
          <span class="n">Post</span>   <span class="o">=&gt;</span> <span class="n">Count</span> <span class="o">=</span> <span class="n">Count</span><span class="na">&#39;Old</span> <span class="kr">and</span><span class="p"></span>
                    <span class="n">Stack_Entry</span> <span class="o">(</span><span class="n">Count</span><span class="o">)</span> <span class="o">=</span> <span class="n">Stack_Entry</span> <span class="o">(</span><span class="n">Count</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span><span class="na">&#39;Old</span> <span class="kr">and</span><span class="p"></span>
                    <span class="n">Stack_Entry</span> <span class="o">(</span><span class="n">Count</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">=</span> <span class="n">Stack_Entry</span> <span class="o">(</span><span class="n">Count</span><span class="o">)</span><span class="na">&#39;Old</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Stack_External_Prover</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="quoting-an-own-variable-in-a-contract">
<span id="ms-quote-own-variable-in-contract-label"></span><h3>Quoting an Own Variable in a Contract<a class="headerlink" href="#quoting-an-own-variable-in-a-contract" title="Permalink to this headline">¶</a></h3>
<p>Sometimes it is necessary to reference an own variable (a state
abstraction) in a contract. In SPARK 2005 this was achieved by
declaring the own variable with a type, either concrete or
abstract. As seen in <a class="reference internal" href="#ms-proof-types-and-proof-functions-label"><span class="std std-ref">Proof types and proof functions</span></a>.
Once the own variable has a type it can be used in a SPARK 2005 proof
context.</p>
<p>A state abstraction in SPARK 2014 does not have a type. Instead, an Ada
type to represent the abstract state is declared. A function
which has the state abstraction as a global item is then declared
which returns an object of the type. This function may have the same
name as the state abstraction (the name is overloaded). References
which appear to be the abstract state in an assertion expression are
in fact calls to the overloaded function.</p>
<p>An example of this technique is given in the following example which
is a version of the stack example given in
<a class="reference internal" href="#ms-proof-types-and-proof-functions-label"><span class="std std-ref">Proof types and proof functions</span></a> but with the post
conditions extended to express the functional properties of the stack.</p>
<p>The extension requires the quoting of the own variable/state
abstraction in the postcondition in order to state that the contents
of the stack other than the top entries are not changed.</p>
<p>Specification in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Stack_Functional_Spec</span>
<span class="c">--# own State : Abstract_Stack;</span>
<span class="kr">is</span><span class="p"></span>
   <span class="c">--  It is not possible to specify that the stack will be</span>
   <span class="c">--  initialized to empty except by having an initialization</span>
   <span class="c">--  subprogram called during program execution (as opposed to</span>
   <span class="c">--  package elaboration).</span>

   <span class="c">--  Proof functions to indicate whether or not the Stack is empty</span>
   <span class="c">--  and whether or not it is full.</span>
   <span class="c">--# type Abstract_Stack is abstract;</span>

   <span class="c">--# function Max_Stack_Size return Natural;</span>

   <span class="c">--  Proof function to give the number of elements on the stack.</span>
   <span class="c">--# function Count(Input : Abstract_Stack) return Natural;</span>

   <span class="c">--  Proof function returns the Nth entry on the stack.</span>
   <span class="c">--  Stack_Entry (Count (State)) is the top of stack</span>
   <span class="c">--# function Stack_Entry (S : Abstract_Stack; N : Natural) return Integer;</span>
   <span class="c">--# pre N in 1 .. Count (S);</span>
   <span class="c">--  A refined version of this function cannot be written because</span>
   <span class="c">--  the abstract view has a formal parameter of type Abstract_Stack</span>
   <span class="c">--  whereas the refined view would not have this parameter but use</span>
   <span class="c">--  a global. A user defined proof rule would be required to</span>
   <span class="c">--  define this function. Alternatively, it could be written as an</span>
   <span class="c">--  Ada function where the the global and formal parameter views</span>
   <span class="c">--  would be available. However, the function would then be</span>
   <span class="c">--  callable and generate implementation code.</span>

   <span class="c">--# function Is_Empty(Input : Abstract_Stack) return Boolean;</span>
   <span class="c">--# return Count (Input) = 0;</span>

   <span class="c">--# function Is_Full(Input : Abstract_Stack) return Boolean;</span>
   <span class="c">--# return Count (Input) = Max_Stack_Size;</span>

   <span class="c">--  The precondition requires the stack is not full when a value, X,</span>
   <span class="c">--  is pushed onto it.</span>
   <span class="c">--  Functions with global items (Is_Full with global State in this case)</span>
   <span class="c">--  can be called in an assertion expression such as the precondition here.</span>
   <span class="c">--  The postcondition indicates that the count of the stack will be</span>
   <span class="c">--  incremented after a push and therefore the stack will be non-empty.</span>
   <span class="c">--  The item X is now the top of the stack and the contents of the rest of</span>
   <span class="c">--  the stack are unchanged.</span>
   <span class="k">procedure </span><span class="nf">Push</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--# global in out State;</span>
   <span class="c">--# pre  not Is_Full(State);</span>
   <span class="c">--# post Count (State) = Count (State~) + 1 and</span>
   <span class="c">--#      Count (State) &lt;= Max_Stack_Size and</span>
   <span class="c">--#      Stack_Entry (State, Count (State)) = X and</span>
   <span class="c">--#      (for all I in Natural range 1 .. Count (State~) =&gt;</span>
   <span class="c">--#          (Stack_Entry (State, I) = Stack_Entry (State~, I)));</span>

   <span class="c">--  The precondition requires the stack is not empty when we</span>
   <span class="c">--  pull a value from it.</span>
   <span class="c">--  The postcondition indicates that the X = the old top of stack,</span>
   <span class="c">--  the stack count is decremented, and the contents of the stack excluding</span>
   <span class="c">--  the old top of stack are unchanged.</span>
   <span class="k">procedure </span><span class="nf">Pop</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--# global in out State;</span>
   <span class="c">--# pre not Is_Empty (State);</span>
   <span class="c">--# post Count (State) = Count (State~) - 1 and</span>
   <span class="c">--#      X = Stack_Entry (State~, Count (State~)) and</span>
   <span class="c">--#      (for all I in Natural range 1 .. Count (State) =&gt;</span>
   <span class="c">--#          (Stack_Entry (State, I) = Stack_Entry (State~, I)));</span>

   <span class="c">--  The precondition requires that the stack has at least 2 entries</span>
   <span class="c">--  (Count &gt;= 2).</span>
   <span class="c">--  The postcondition states that the top two elements of the stack are</span>
   <span class="c">--  transposed but the remainder of the stack is unchanged.</span>
   <span class="k">procedure </span><span class="nf">Swap2</span><span class="p">;</span>
   <span class="c">--# global in out State;</span>
   <span class="c">--# pre  Count(State) &gt;= 2;</span>
   <span class="c">--# post Count(State) =  Count(State~) and</span>
   <span class="c">--#      Stack_Entry (State, Count (State)) =</span>
   <span class="c">--#         Stack_Entry (State~, Count (State) - 1) and</span>
   <span class="c">--#      Stack_Entry (State, Count (State) - 1) =</span>
   <span class="c">--#         Stack_Entry (State~, Count (State)) and</span>
   <span class="c">--#      (for all I in Natural range 1 .. Count (State) =&gt;</span>
   <span class="c">--#          (Stack_Entry (State, I) = Stack_Entry (State~, I)));</span>

   <span class="c">--  Initializes the Stack.</span>
   <span class="k">procedure </span><span class="nf">Initialize</span><span class="p">;</span>
   <span class="c">--# global out State;</span>
   <span class="c">--# post Is_Empty (State);</span>
<span class="k">end </span><span class="nf">Stack_Functional_Spec</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Stack_Functional_Spec</span>
<span class="c">--# own State is My_Stack;</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">Stack_Size</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="o">:=</span> <span class="mi">100</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Pointer_Range</span> <span class="kr">is</span><span class="p"> </span><span class="kr">range</span><span class="p"> </span><span class="mi">0</span> <span class="o">..</span> <span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">subtype</span><span class="p"> </span><span class="n">Index_Range</span>   <span class="kr">is</span><span class="p"> </span><span class="n">Pointer_Range</span> <span class="kr">range</span><span class="p"> </span><span class="mi">1</span><span class="o">..</span><span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Vector</span>        <span class="kr">is</span><span class="p"> </span><span class="n">array</span><span class="o">(</span><span class="n">Index_Range</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>

   <span class="kr">type</span><span class="p"> </span><span class="n">Stack_Type</span> <span class="kr">is</span><span class="p"></span>
      <span class="kr">record</span><span class="p"></span>
         <span class="n">S</span> <span class="o">:</span> <span class="n">Vector</span><span class="p">;</span>
         <span class="n">Pointer</span> <span class="o">:</span> <span class="n">Pointer_Range</span><span class="p">;</span>
      <span class="k">end record</span><span class="p">;</span>

   <span class="n">Initial_Stack</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="n">Stack_Type</span> <span class="o">:=</span>
      <span class="n">Stack_Type</span><span class="o">&#39;(</span><span class="n">S</span>       <span class="o">=&gt;</span> <span class="n">Vector</span><span class="o">&#39;(</span><span class="kr">others</span><span class="p"> </span><span class="o">=&gt;</span> <span class="mi">0</span><span class="o">)</span><span class="p">,</span>
                  <span class="n">Pointer</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">)</span><span class="p">;</span>

   <span class="n">My_Stack</span> <span class="o">:</span> <span class="n">Stack_Type</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Push</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
   <span class="c">--# global in out My_Stack;</span>
   <span class="c">--# pre My_Stack.Pointer &lt; Stack_Size;</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">My_Stack.Pointer</span> <span class="o">:=</span> <span class="n">My_Stack.Pointer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">My_Stack.S</span><span class="o">(</span><span class="n">My_Stack.Pointer</span><span class="o">)</span> <span class="o">:=</span> <span class="n">X</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Push</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Pop</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
   <span class="c">--# global in out My_Stack;</span>
   <span class="c">--# pre My_Stack.Pointer &gt;= 1;</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">X</span> <span class="o">:=</span> <span class="n">My_Stack.S</span> <span class="o">(</span><span class="n">My_Stack.Pointer</span><span class="o">)</span><span class="p">;</span>
      <span class="n">My_Stack.Pointer</span> <span class="o">:=</span> <span class="n">My_Stack.Pointer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Pop</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Swap2</span>
   <span class="c">--# global in out My_Stack;</span>
   <span class="c">--# post My_Stack.Pointer = My_Stack~.Pointer;</span>
   <span class="kr">is</span><span class="p"></span>
      <span class="n">Temp</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Temp</span> <span class="o">:=</span> <span class="n">My_Stack.S</span> <span class="o">(</span><span class="mi">1</span><span class="o">)</span><span class="p">;</span>
      <span class="n">My_Stack.S</span> <span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">My_Stack.S</span> <span class="o">(</span><span class="mi">2</span><span class="o">)</span><span class="p">;</span>
      <span class="n">My_Stack.S</span> <span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Temp</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Swap2</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Initialize</span>
   <span class="c">--# global out My_Stack;</span>
   <span class="c">--# post My_Stack.Pointer = 0;</span>
   <span class="kr">is</span><span class="p"></span>
      <span class="c">--# for Initial_Stack declare Rule;</span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">My_Stack</span> <span class="o">:=</span> <span class="n">Initial_Stack</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Initialize</span><span class="p">;</span>

<span class="k">end </span><span class="nf">Stack_Functional_Spec</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specification in SPARK 2014</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Unevaluated_Use_Of_Old</span><span class="o">(</span><span class="n">Allow</span><span class="o">)</span><span class="p">;</span>
<span class="k">package </span><span class="nf">Stack_Functional_Spec</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span>    <span class="o">=&gt;</span> <span class="n">State</span><span class="p">,</span>
       <span class="n">Initializes</span>       <span class="o">=&gt;</span> <span class="n">State</span><span class="p">,</span>
       <span class="n">Initial_Condition</span> <span class="o">=&gt;</span> <span class="n">Is_Empty</span>
<span class="kr">is</span><span class="p"></span>
   <span class="c">--  Abstract states do not have types in SPARK 2014 but to provide</span>
   <span class="c">--  functional specifications it is sometimes necessary to refer to</span>
   <span class="c">--  the abstract state in an assertion expression such as a post</span>
   <span class="c">--  condition. To do this in SPARK 2014 an Ada type declaration is</span>
   <span class="c">--  required to represent the type of the abstract state, then a</span>
   <span class="c">--  function applied to the abstract state (as a global) can be</span>
   <span class="c">--  written which returns an object of the declared type.</span>
   <span class="kr">type</span><span class="p"> </span><span class="n">Stack_Type</span> <span class="kr">is</span><span class="p"> </span><span class="kr">private</span><span class="p">;</span>

   <span class="c">--  The Abstract_State name may be overloaded by the function which</span>
   <span class="c">--  represents it in assertion expressions.</span>
   <span class="k">function </span><span class="nf">State</span> <span class="kr">return</span><span class="p"> </span><span class="n">Stack_Type</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Max_Stack_Size</span> <span class="kr">return</span><span class="p"> </span><span class="n">Natural</span><span class="p"></span>
<span class="p">     </span><span class="kr">with</span><span class="nn"> Ghost;</span>

   <span class="c">--  Returns the number of elements on the stack</span>
   <span class="c">--  A function may have a formal parameter (or return a value)</span>
   <span class="c">--  of the abstract state.</span>
   <span class="k">function </span><span class="nf">Count</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Stack_Type</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Natural</span><span class="p"></span>
<span class="p">     </span><span class="kr">with</span><span class="nn"> Ghost;</span>

   <span class="c">-- Returns the Nth entry on the stack.</span>
   <span class="c">-- Stack_Entry (S, Count (S)) is the top of stack</span>
   <span class="k">function </span><span class="nf">Stack_Entry</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Stack_Type</span><span class="p">;</span> <span class="n">N</span> <span class="o">:</span> <span class="n">Natural</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Pre</span>        <span class="o">=&gt;</span> <span class="n">N</span> <span class="kr">in</span><span class="p"> </span><span class="mi">1</span> <span class="o">..</span> <span class="n">Count</span> <span class="o">(</span><span class="n">S</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Ghost</span><span class="p">;</span>

   <span class="c">-- The ghost function Count can be called in the function</span>
   <span class="c">-- expression because Is_Empty is also a ghost function.</span>
   <span class="k">function </span><span class="nf">Is_Empty</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">Count</span> <span class="o">(</span><span class="n">State</span><span class="o">)</span> <span class="o">=</span> <span class="mi">0</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>     <span class="o">=&gt;</span> <span class="n">State</span><span class="p">,</span>
          <span class="n">Ghost</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Is_Full</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">Count</span><span class="o">(</span><span class="n">State</span><span class="o">)</span> <span class="o">=</span> <span class="n">Max_Stack_Size</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>     <span class="o">=&gt;</span> <span class="n">State</span><span class="p">,</span>
          <span class="n">Ghost</span><span class="p">;</span>

   <span class="c">--  The precondition requires the stack is not full when a value, X,</span>
   <span class="c">--  is pushed onto it.</span>
   <span class="c">--  Functions with global items (Is_Full with global State in this case)</span>
   <span class="c">--  can be called in an assertion expression such as the precondition here.</span>
   <span class="c">--  The postcondition indicates that the count of the stack will be</span>
   <span class="c">--  incremented after a push and therefore the stack will be non-empty.</span>
   <span class="c">--  The item X is now the top of the stack and the contents of the rest of</span>
   <span class="c">--  the stack are unchanged.</span>
   <span class="k">procedure </span><span class="nf">Push</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Pre</span>    <span class="o">=&gt;</span> <span class="kr">not</span><span class="p"> </span><span class="n">Is_Full</span><span class="p">,</span>
          <span class="n">Post</span>   <span class="o">=&gt;</span> <span class="n">Count</span> <span class="o">(</span><span class="n">State</span><span class="o">)</span> <span class="o">=</span> <span class="n">Count</span> <span class="o">(</span><span class="n">State</span><span class="na">&#39;Old</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="kr">and</span><span class="p"></span>
                    <span class="n">Count</span> <span class="o">(</span><span class="n">State</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="n">Max_Stack_Size</span> <span class="kr">and</span><span class="p"></span>
                    <span class="n">Stack_Entry</span> <span class="o">(</span><span class="n">State</span><span class="p">,</span> <span class="n">Count</span> <span class="o">(</span><span class="n">State</span><span class="o">))</span> <span class="o">=</span> <span class="n">X</span> <span class="kr">and</span><span class="p"></span>
                    <span class="o">(</span><span class="kr">for</span><span class="p"> </span><span class="kr">all</span><span class="p"> </span><span class="n">I</span> <span class="kr">in</span><span class="p"> </span><span class="mi">1</span> <span class="o">..</span> <span class="n">Count</span> <span class="o">(</span><span class="n">State</span><span class="na">&#39;Old</span><span class="o">)</span> <span class="o">=&gt;</span>
                        <span class="n">Stack_Entry</span> <span class="o">(</span><span class="n">State</span><span class="p">,</span> <span class="n">I</span><span class="o">)</span> <span class="o">=</span> <span class="n">Stack_Entry</span> <span class="o">(</span><span class="n">State</span><span class="na">&#39;Old</span><span class="p">,</span> <span class="n">I</span><span class="o">))</span><span class="p">;</span>

   <span class="c">--  The precondition requires the stack is not empty when we</span>
   <span class="c">--  pull a value from it.</span>
   <span class="c">--  The postcondition indicates that the X = the old top of stack,</span>
   <span class="c">--  the stack count is decremented, and the contents of the stack excluding</span>
   <span class="c">--  the old top of stack are unchanged.</span>
   <span class="k">procedure </span><span class="nf">Pop</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Pre</span>    <span class="o">=&gt;</span> <span class="kr">not</span><span class="p"> </span><span class="n">Is_Empty</span><span class="p">,</span>
          <span class="n">Post</span>   <span class="o">=&gt;</span> <span class="n">Count</span> <span class="o">(</span><span class="n">State</span><span class="o">)</span> <span class="o">=</span> <span class="n">Count</span> <span class="o">(</span><span class="n">State</span><span class="na">&#39;Old</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="kr">and</span><span class="p"></span>
                    <span class="n">X</span> <span class="o">=</span> <span class="n">Stack_Entry</span> <span class="o">(</span><span class="n">State</span><span class="na">&#39;Old</span><span class="p">,</span> <span class="n">Count</span> <span class="o">(</span><span class="n">State</span><span class="na">&#39;Old</span><span class="o">))</span> <span class="kr">and</span><span class="p"></span>
                   <span class="o">(</span><span class="kr">for</span><span class="p"> </span><span class="kr">all</span><span class="p"> </span><span class="n">I</span> <span class="kr">in</span><span class="p"> </span><span class="mi">1</span> <span class="o">..</span> <span class="n">Count</span> <span class="o">(</span><span class="n">State</span><span class="o">)</span> <span class="o">=&gt;</span>
                       <span class="n">Stack_Entry</span> <span class="o">(</span><span class="n">State</span><span class="p">,</span> <span class="n">I</span><span class="o">)</span> <span class="o">=</span> <span class="n">Stack_Entry</span> <span class="o">(</span><span class="n">State</span><span class="na">&#39;Old</span><span class="p">,</span> <span class="n">I</span><span class="o">))</span><span class="p">;</span>

   <span class="c">--  The precondition requires that the stack has at least 2 entries</span>
   <span class="c">--  (Count &gt;= 2).</span>
   <span class="c">--  The postcondition states that the top two elements of the stack are</span>
   <span class="c">--  transposed but the remainder of the stack is unchanged.</span>
   <span class="k">procedure </span><span class="nf">Swap2</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Pre</span>    <span class="o">=&gt;</span> <span class="n">Count</span> <span class="o">(</span><span class="n">State</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">,</span>
          <span class="n">Post</span>   <span class="o">=&gt;</span> <span class="n">Count</span><span class="o">(</span><span class="n">State</span><span class="o">)</span> <span class="o">=</span> <span class="n">Count</span> <span class="o">(</span><span class="n">State</span><span class="na">&#39;Old</span><span class="o">)</span> <span class="kr">and</span><span class="p"></span>
                    <span class="n">Stack_Entry</span> <span class="o">(</span><span class="n">State</span><span class="p">,</span> <span class="n">Count</span> <span class="o">(</span><span class="n">State</span><span class="o">))</span> <span class="o">=</span>
                       <span class="n">Stack_Entry</span> <span class="o">(</span><span class="n">State</span><span class="na">&#39;Old</span><span class="p">,</span> <span class="n">Count</span> <span class="o">(</span><span class="n">State</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="kr">and</span><span class="p"></span>
                    <span class="n">Stack_Entry</span> <span class="o">(</span><span class="n">State</span><span class="p">,</span> <span class="n">Count</span> <span class="o">(</span><span class="n">State</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">=</span>
                       <span class="n">Stack_Entry</span> <span class="o">(</span><span class="n">State</span><span class="na">&#39;Old</span><span class="p">,</span> <span class="n">Count</span> <span class="o">(</span><span class="n">State</span><span class="o">))</span> <span class="kr">and</span><span class="p"></span>
                    <span class="o">(</span><span class="kr">for</span><span class="p"> </span><span class="kr">all</span><span class="p"> </span><span class="n">I</span> <span class="kr">in</span><span class="p"> </span><span class="mi">1</span> <span class="o">..</span> <span class="n">Count</span> <span class="o">(</span><span class="n">State</span><span class="o">)</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">=&gt;</span>
                        <span class="n">Stack_Entry</span> <span class="o">(</span><span class="n">State</span><span class="p">,</span> <span class="n">I</span><span class="o">)</span> <span class="o">=</span> <span class="n">Stack_Entry</span> <span class="o">(</span><span class="n">State</span><span class="na">&#39;Old</span><span class="p">,</span> <span class="n">I</span><span class="o">))</span><span class="p">;</span>

<span class="kr">private</span><span class="p"></span>
   <span class="c">-- The full type declarion used to represent the abstract state.</span>
   <span class="n">Stack_Size</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="o">:=</span> <span class="mi">100</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Pointer_Range</span> <span class="kr">is</span><span class="p"> </span><span class="kr">range</span><span class="p"> </span><span class="mi">0</span> <span class="o">..</span> <span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">subtype</span><span class="p"> </span><span class="n">Index_Range</span>   <span class="kr">is</span><span class="p"> </span><span class="n">Pointer_Range</span> <span class="kr">range</span><span class="p"> </span><span class="mi">1</span> <span class="o">..</span> <span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span>   <span class="n">Vector</span>        <span class="kr">is</span><span class="p"> </span><span class="n">array</span><span class="o">(</span><span class="n">Index_Range</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>

   <span class="kr">type</span><span class="p"> </span><span class="n">Stack_Type</span> <span class="kr">is</span><span class="p"> </span><span class="kr">record</span><span class="p"></span>
      <span class="n">S</span> <span class="o">:</span> <span class="n">Vector</span><span class="p">;</span>
      <span class="n">Pointer</span> <span class="o">:</span> <span class="n">Pointer_Range</span><span class="p">;</span>
   <span class="k">end record</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Stack_Functional_Spec</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Stack_Functional_Spec</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State</span> <span class="o">=&gt;</span> <span class="n">My_Stack</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">Initial_Stack</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="n">Stack_Type</span> <span class="o">:=</span>
     <span class="n">Stack_Type</span><span class="o">&#39;(</span><span class="n">S</span>       <span class="o">=&gt;</span> <span class="n">Vector</span><span class="o">&#39;(</span><span class="kr">others</span><span class="p"> </span><span class="o">=&gt;</span> <span class="mi">0</span><span class="o">)</span><span class="p">,</span>
                 <span class="n">Pointer</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">)</span><span class="p">;</span>

   <span class="c">--  In this example the type used to represent the state</span>
   <span class="c">--  abstraction and the actual type used in the implementation are</span>
   <span class="c">--  the same, but they need not be. For instance S and Pointer</span>
   <span class="c">--  could have been declared as distinct objects rather than</span>
   <span class="c">--  composed into a record. Where the type representing the</span>
   <span class="c">--  abstract state and the implementation of that state are</span>
   <span class="c">--  different the function representing the abstract state has to</span>
   <span class="c">--  convert implementation representation into the abstract</span>
   <span class="c">--  representation. For instance, if S and Pointer were distinct</span>
   <span class="c">--  objects the function State would have to return (S =&gt; S,</span>
   <span class="c">--  Pointer =&gt; Pointer).</span>
   <span class="n">My_Stack</span> <span class="o">:</span> <span class="n">Stack_Type</span><span class="p">;</span>

   <span class="c">--  No convertion necessary as the abstract and implementation type</span>
   <span class="c">--  is the same.</span>
   <span class="k">function </span><span class="nf">State</span> <span class="kr">return</span><span class="p"> </span><span class="n">Stack_Type</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">My_Stack</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="n">My_Stack</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Max_Stack_Size</span> <span class="kr">return</span><span class="p"> </span><span class="n">Natural</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">Stack_Size</span><span class="o">)</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Count</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Stack_Type</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Natural</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">Natural</span> <span class="o">(</span><span class="n">S.Pointer</span><span class="o">))</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Stack_Entry</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Stack_Type</span><span class="p">;</span> <span class="n">N</span> <span class="o">:</span> <span class="n">Natural</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">is</span><span class="p"></span>
     <span class="o">(</span><span class="n">S.S</span> <span class="o">(</span><span class="n">Index_Range</span> <span class="o">(</span><span class="n">N</span><span class="o">)))</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Push</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">My_Stack</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">My_Stack.Pointer</span> <span class="o">:=</span> <span class="n">My_Stack.Pointer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">My_Stack.S</span><span class="o">(</span><span class="n">My_Stack.Pointer</span><span class="o">)</span> <span class="o">:=</span> <span class="n">X</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Push</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Pop</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">My_Stack</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">X</span> <span class="o">:=</span> <span class="n">My_Stack.S</span> <span class="o">(</span><span class="n">My_Stack.Pointer</span><span class="o">)</span><span class="p">;</span>
      <span class="n">My_Stack.Pointer</span> <span class="o">:=</span> <span class="n">My_Stack.Pointer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Pop</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Swap2</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">My_Stack</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
      <span class="n">Temp</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Temp</span> <span class="o">:=</span> <span class="n">My_Stack.S</span> <span class="o">(</span><span class="n">My_Stack.Pointer</span><span class="o">)</span><span class="p">;</span>
      <span class="n">My_Stack.S</span> <span class="o">(</span><span class="n">My_Stack.Pointer</span><span class="o">)</span> <span class="o">:=</span> <span class="n">My_Stack.S</span> <span class="o">(</span><span class="n">My_Stack.Pointer</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span><span class="p">;</span>
      <span class="n">My_Stack.S</span> <span class="o">(</span><span class="n">My_Stack.Pointer</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Temp</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Swap2</span><span class="p">;</span>
<span class="kr">begin</span><span class="p"></span>
   <span class="n">My_Stack</span> <span class="o">:=</span> <span class="n">Initial_Stack</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Stack_Functional_Spec</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="main-program-annotation">
<h3>Main_Program annotation<a class="headerlink" href="#main-program-annotation" title="Permalink to this headline">¶</a></h3>
<p>This annotation isn&#8217;t needed.  Currently any parameterless procedure
declared at library-level is considered as a potential main program
and analyzed as such.</p>
</div>
</div>
<div class="section" id="update-expressions">
<span id="ms-update-expressions-label"></span><h2>Update Expressions<a class="headerlink" href="#update-expressions" title="Permalink to this headline">¶</a></h2>
<p>SPARK 2005 has update expressions for updating records and arrays.
They can only be used in SPARK 2005 proof contexts.</p>
<p>The equivalent in SPARK 2014 is the &#8216;<em>Update</em> attribute.  This can be
used in any Ada expression.</p>
<p>Specification in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Update_Examples</span>
<span class="kr">is</span><span class="p"></span>
   <span class="kr">type</span><span class="p"> </span><span class="n">Rec</span> <span class="kr">is</span><span class="p"> </span><span class="kr">record</span><span class="p"></span>
      <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="k">end record</span><span class="p">;</span>

   <span class="kr">type</span><span class="p"> </span><span class="n">Index</span> <span class="kr">is</span><span class="p"> </span><span class="kr">range</span><span class="p"> </span><span class="mi">1</span> <span class="o">..</span><span class="mi">3</span><span class="p">;</span>

   <span class="kr">type</span><span class="p"> </span><span class="n">Arr</span> <span class="kr">is</span><span class="p"> </span><span class="kr">array</span><span class="p"> </span><span class="o">(</span><span class="n">Index</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>

   <span class="kr">type</span><span class="p"> </span><span class="n">Arr_2D</span> <span class="kr">is</span><span class="p"> </span><span class="kr">array</span><span class="p"> </span><span class="o">(</span><span class="n">Index</span><span class="p">,</span> <span class="n">Index</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>

   <span class="kr">type</span><span class="p"> </span><span class="n">Nested_Rec</span> <span class="kr">is</span><span class="p"> </span><span class="kr">record</span><span class="p"></span>
      <span class="n">A</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
      <span class="n">B</span> <span class="o">:</span> <span class="n">Rec</span><span class="p">;</span>
      <span class="n">C</span> <span class="o">:</span> <span class="n">Arr</span><span class="p">;</span>
      <span class="n">D</span> <span class="o">:</span> <span class="n">Arr_2D</span><span class="p">;</span>
   <span class="k">end record</span><span class="p">;</span>

   <span class="kr">type</span><span class="p"> </span><span class="n">Nested_Arr</span> <span class="kr">is</span><span class="p"> </span><span class="kr">array</span><span class="p"> </span><span class="o">(</span><span class="n">Index</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Nested_Rec</span><span class="p">;</span>

   <span class="c">-- Simple record update</span>
   <span class="k">procedure </span><span class="nf">P1</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Rec</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--# post R = R~ [X =&gt; 1];</span>

   <span class="c">-- Simple 1D array update</span>
   <span class="k">procedure </span><span class="nf">P2</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Arr</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--# post A = A~ [1 =&gt; 2];</span>

   <span class="c">-- 2D array update</span>
   <span class="k">procedure </span><span class="nf">P3</span> <span class="o">(</span><span class="n">A2D</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Arr_2D</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--# post A2D = A2D~ [1, 1 =&gt; 1;</span>
   <span class="c">--#                  2, 2 =&gt; 2;</span>
   <span class="c">--#                  3, 3 =&gt; 3];</span>

   <span class="c">-- Nested record update</span>
   <span class="k">procedure </span><span class="nf">P4</span> <span class="o">(</span><span class="n">NR</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Nested_Rec</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--# post NR = NR~ [A =&gt; 1;</span>
   <span class="c">--#                B =&gt; NR~.B [X =&gt; 1];</span>
   <span class="c">--#                C =&gt; NR~.C [1 =&gt; 5]];</span>

   <span class="c">-- Nested array update</span>
   <span class="k">procedure </span><span class="nf">P5</span> <span class="o">(</span><span class="n">NA</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Nested_Arr</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--# post NA = NA~ [1 =&gt; NA~ (1) [A =&gt; 1;</span>
   <span class="c">--#                              D =&gt; NA~ (1).D [2, 2 =&gt; 0]];</span>
   <span class="c">--#                2 =&gt; NA~ (2) [B =&gt; NA~ (2).B [X =&gt; 2]];</span>
   <span class="c">--#                3 =&gt; NA~ (3) [C =&gt; NA~ (3).C [1 =&gt; 5]]];</span>
<span class="k">end </span><span class="nf">Update_Examples</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specification in SPARK 2014</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Update_Examples</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span>
<span class="kr">is</span><span class="p"></span>
   <span class="kr">type</span><span class="p"> </span><span class="n">Rec</span> <span class="kr">is</span><span class="p"> </span><span class="kr">record</span><span class="p"></span>
      <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="k">end record</span><span class="p">;</span>

   <span class="kr">type</span><span class="p"> </span><span class="n">Arr</span> <span class="kr">is</span><span class="p"> </span><span class="kr">array</span><span class="p"> </span><span class="o">(</span><span class="mi">1</span> <span class="o">..</span> <span class="mi">3</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>

   <span class="kr">type</span><span class="p"> </span><span class="n">Arr_2D</span> <span class="kr">is</span><span class="p"> </span><span class="kr">array</span><span class="p"> </span><span class="o">(</span><span class="mi">1</span> <span class="o">..</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span> <span class="o">..</span> <span class="mi">3</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>

   <span class="kr">type</span><span class="p"> </span><span class="n">Nested_Rec</span> <span class="kr">is</span><span class="p"> </span><span class="kr">record</span><span class="p"></span>
      <span class="n">A</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
      <span class="n">B</span> <span class="o">:</span> <span class="n">Rec</span><span class="p">;</span>
      <span class="n">C</span> <span class="o">:</span> <span class="n">Arr</span><span class="p">;</span>
      <span class="n">D</span> <span class="o">:</span> <span class="n">Arr_2D</span><span class="p">;</span>
   <span class="k">end record</span><span class="p">;</span>

   <span class="kr">type</span><span class="p"> </span><span class="n">Nested_Arr</span> <span class="kr">is</span><span class="p"> </span><span class="kr">array</span><span class="p"> </span><span class="o">(</span><span class="mi">1</span> <span class="o">..</span> <span class="mi">3</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Nested_Rec</span><span class="p">;</span>

   <span class="c">-- Simple record update</span>
   <span class="k">procedure </span><span class="nf">P1</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Rec</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Post</span> <span class="o">=&gt;</span> <span class="n">R</span> <span class="o">=</span> <span class="n">R</span><span class="na">&#39;Old&#39;Update</span> <span class="o">(</span><span class="n">X</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="o">)</span><span class="p">;</span>
   <span class="c">-- this is equivalent to:</span>
   <span class="c">--   R = (X =&gt; 1,</span>
   <span class="c">--        Y =&gt; R&#39;Old.Y)</span>

   <span class="c">-- Simple 1D array update</span>
   <span class="k">procedure </span><span class="nf">P2</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Arr</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Post</span> <span class="o">=&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="na">&#39;Old&#39;Update</span> <span class="o">(</span><span class="mi">1</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="o">)</span><span class="p">;</span>
   <span class="c">-- this is equivalent to:</span>
   <span class="c">--   A = (1 =&gt; 2,</span>
   <span class="c">--        2 =&gt; A&#39;Old (2),</span>
   <span class="c">--        3 =&gt; A&#39;Old (3));</span>

   <span class="c">-- 2D array update</span>
   <span class="k">procedure </span><span class="nf">P3</span> <span class="o">(</span><span class="n">A2D</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Arr_2D</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Post</span> <span class="o">=&gt;</span> <span class="n">A2D</span> <span class="o">=</span> <span class="n">A2D</span><span class="na">&#39;Old&#39;Update</span> <span class="o">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span>
                                        <span class="o">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">,</span>
                                        <span class="o">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="o">)</span><span class="p">;</span>
   <span class="c">-- this is equivalent to:</span>
   <span class="c">--   A2D = (1 =&gt; (1 =&gt; 1,</span>
   <span class="c">--                2 =&gt; A2D&#39;Old (1, 2),</span>
   <span class="c">--                3 =&gt; A2D&#39;Old (1, 3)),</span>
   <span class="c">--          2 =&gt; (2 =&gt; 2,</span>
   <span class="c">--                1 =&gt; A2D&#39;Old (2, 1),</span>
   <span class="c">--                3 =&gt; A2D&#39;Old (2, 3)),</span>
   <span class="c">--          3 =&gt; (3 =&gt; 3,</span>
   <span class="c">--                1 =&gt; A2D&#39;Old (3, 1),</span>
   <span class="c">--                2 =&gt; A2D&#39;Old (3, 2)));</span>

   <span class="c">-- Nested record update</span>
   <span class="k">procedure </span><span class="nf">P4</span> <span class="o">(</span><span class="n">NR</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Nested_Rec</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Post</span> <span class="o">=&gt;</span> <span class="n">NR</span> <span class="o">=</span> <span class="n">NR</span><span class="na">&#39;Old&#39;Update</span> <span class="o">(</span><span class="n">A</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span>
                                      <span class="n">B</span> <span class="o">=&gt;</span> <span class="n">NR</span><span class="na">&#39;Old</span><span class="o">.</span><span class="n">B</span><span class="na">&#39;Update</span> <span class="o">(</span><span class="n">X</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="o">)</span><span class="p">,</span>
                                      <span class="n">C</span> <span class="o">=&gt;</span> <span class="n">NR</span><span class="na">&#39;Old</span><span class="o">.</span><span class="n">C</span><span class="na">&#39;Update</span> <span class="o">(</span><span class="mi">1</span> <span class="o">=&gt;</span> <span class="mi">5</span><span class="o">))</span><span class="p">;</span>
   <span class="c">-- this is equivalent to:</span>
   <span class="c">--   NR = (A =&gt; 1,</span>
   <span class="c">--         B.X =&gt; 1,</span>
   <span class="c">--         B.Y =&gt; NR&#39;Old.B.Y,</span>
   <span class="c">--         C (1) =&gt; 5,</span>
   <span class="c">--         C (2) =&gt; NR&#39;Old.C (2),</span>
   <span class="c">--         C (3) =&gt; NR&#39;Old.C (3),</span>
   <span class="c">--         D =&gt; NR&#39;Old.D)</span>

   <span class="c">-- Nested array update</span>
   <span class="k">procedure </span><span class="nf">P5</span> <span class="o">(</span><span class="n">NA</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Nested_Arr</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Post</span> <span class="o">=&gt;</span>
       <span class="n">NA</span> <span class="o">=</span> <span class="n">NA</span><span class="na">&#39;Old&#39;Update</span> <span class="o">(</span><span class="mi">1</span> <span class="o">=&gt;</span> <span class="n">NA</span><span class="na">&#39;Old</span> <span class="o">(</span><span class="mi">1</span><span class="o">)</span><span class="na">&#39;Update</span>
                                  <span class="o">(</span><span class="n">A</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span>
                                   <span class="n">D</span> <span class="o">=&gt;</span> <span class="n">NA</span><span class="na">&#39;Old</span> <span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="n">D</span><span class="na">&#39;Update</span> <span class="o">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">))</span><span class="p">,</span>
                           <span class="mi">2</span> <span class="o">=&gt;</span> <span class="n">NA</span><span class="na">&#39;Old</span> <span class="o">(</span><span class="mi">2</span><span class="o">)</span><span class="na">&#39;Update</span>
                                  <span class="o">(</span><span class="n">B</span> <span class="o">=&gt;</span> <span class="n">NA</span><span class="na">&#39;Old</span> <span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="n">B</span><span class="na">&#39;Update</span> <span class="o">(</span><span class="n">X</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="o">))</span><span class="p">,</span>
                           <span class="mi">3</span> <span class="o">=&gt;</span> <span class="n">NA</span><span class="na">&#39;Old</span> <span class="o">(</span><span class="mi">3</span><span class="o">)</span><span class="na">&#39;Update</span>
                                  <span class="o">(</span><span class="n">C</span> <span class="o">=&gt;</span> <span class="n">NA</span><span class="na">&#39;Old</span> <span class="o">(</span><span class="mi">3</span><span class="o">).</span><span class="n">C</span><span class="na">&#39;Update</span> <span class="o">(</span><span class="mi">1</span> <span class="o">=&gt;</span> <span class="mi">5</span><span class="o">)))</span><span class="p">;</span>
   <span class="c">-- this is equivalent to:</span>
   <span class="c">--   NA = (1 =&gt; (A =&gt; 1,</span>
   <span class="c">--               B =&gt; NA&#39;Old (1).B,</span>
   <span class="c">--               C =&gt; NA&#39;Old (1).C,</span>
   <span class="c">--               D =&gt; NA&#39;Old (1).D),</span>
   <span class="c">--         2 =&gt; (B.X =&gt; 2,</span>
   <span class="c">--               B.Y =&gt; NA&#39;Old (2).B.Y,</span>
   <span class="c">--               A =&gt; NA&#39;Old (2).A,</span>
   <span class="c">--               C =&gt; NA&#39;Old (2).C,</span>
   <span class="c">--               D =&gt; NA&#39;Old (2).D),</span>
   <span class="c">--         3 =&gt; (C =&gt; (1 =&gt; 5,</span>
   <span class="c">--                     2 =&gt; NA&#39;Old (3).C (2),</span>
   <span class="c">--                     3 =&gt; NA&#39;Old (3).C (3)),</span>
   <span class="c">--               A =&gt; NA&#39;Old (3).A,</span>
   <span class="c">--               B =&gt; NA&#39;Old (3).B,</span>
   <span class="c">--               D =&gt; NA&#39;Old (3).D));</span>

<span class="k">end </span><span class="nf">Update_Examples</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="value-of-variable-on-entry-to-a-loop">
<span id="ms-value-of-variable-on-entry-to-a-loop-label"></span><h2>Value of Variable on Entry to a Loop<a class="headerlink" href="#value-of-variable-on-entry-to-a-loop" title="Permalink to this headline">¶</a></h2>
<p>In SPARK 2005 the entry value of a for loop variable variable, X, can
be referenced using the notation X%.  This notation is required
frequently when the variable is referenced in a proof context within
the loop.  Often it is needed to state that the value of X is not
changed within the loop by stating X = X%.  This notation is
restricted to a variable which defines the lower or upper range of a
for loop.</p>
<p>SPARK 2014 has a more general scheme whereby the loop entry value of any
variable can be denoted within any sort of loop using the
&#8216;<em>Loop_Entry</em> attribute.  However, its main use is not for showing
that the value of a for loop variable has not changed as the SPARK 2014
tools are able to determine this automatically.  Rather it is used
instead of ~ in loops because the attribute &#8216;Old is only permitted in
postconditions (including Contract_Cases).</p>
<p>Specification in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Loop_Entry</span>
<span class="kr">is</span><span class="p"></span>

  <span class="kr">subtype</span><span class="p"> </span><span class="n">ElementType</span> <span class="kr">is</span><span class="p"> </span><span class="n">Natural</span> <span class="kr">range</span><span class="p"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">1000</span><span class="p">;</span>
  <span class="kr">subtype</span><span class="p"> </span><span class="n">IndexType</span> <span class="kr">is</span><span class="p"> </span><span class="n">Positive</span> <span class="kr">range</span><span class="p"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">;</span>
  <span class="kr">type</span><span class="p"> </span><span class="n">ArrayType</span> <span class="kr">is</span><span class="p"> </span><span class="kr">array</span><span class="p"> </span><span class="o">(</span><span class="n">IndexType</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">ElementType</span><span class="p">;</span>

  <span class="k">procedure </span><span class="nf">Clear</span> <span class="o">(</span><span class="n">A</span><span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">ArrayType</span><span class="p">;</span> <span class="n">L</span><span class="p">,</span><span class="n">U</span><span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">IndexType</span><span class="o">)</span><span class="p">;</span>
  <span class="c">--# derives A from A, L, U;</span>
  <span class="c">--# post (for all N in IndexType range L..U =&gt; (A(N) = 0)) and</span>
  <span class="c">--#      (for all N in IndexType =&gt; ((N&lt;L or N&gt;U) -&gt; A(N) = A~(N)));</span>

<span class="k">end Loop</span><span class="n">_Entry</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body in SPARK 2005:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Loop_Entry</span>
<span class="kr">is</span><span class="p"></span>

  <span class="k">procedure </span><span class="nf">Clear</span> <span class="o">(</span><span class="n">A</span><span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">ArrayType</span><span class="p">;</span> <span class="n">L</span><span class="p">,</span><span class="n">U</span><span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">IndexType</span><span class="o">)</span>
  <span class="kr">is</span><span class="p"></span>
  <span class="kr">begin</span><span class="p"></span>
    <span class="kr">for</span><span class="p"> </span><span class="n">I</span> <span class="kr">in</span><span class="p"> </span><span class="n">IndexType</span> <span class="kr">range</span><span class="p"> </span><span class="n">L..U</span> <span class="kr">loop</span><span class="p"></span>
      <span class="n">A</span><span class="o">(</span><span class="n">I</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="c">--# assert (for all N in IndexType range L..I =&gt; (A(N) = 0)) and</span>
      <span class="c">--#        (for all N in IndexType =&gt; ((N&lt;L or N&gt;I) -&gt; A(N) = A~(N))) and</span>
      <span class="c">--#        U = U% and L &lt;= I;</span>
      <span class="c">-- Note U = U% is required to show that the vaule of U does not change</span>
      <span class="c">-- within the loop.</span>
    <span class="k">end loop</span><span class="p">;</span>
  <span class="k">end </span><span class="nf">Clear</span><span class="p">;</span>

<span class="k">end Loop</span><span class="n">_Entry</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Specification in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">SPARK_Mode</span> <span class="o">(</span><span class="n">On</span><span class="o">)</span><span class="p">;</span>
<span class="k">package </span><span class="nf">Loop_Entry</span>
<span class="kr">is</span><span class="p"></span>

  <span class="kr">subtype</span><span class="p"> </span><span class="n">ElementType</span> <span class="kr">is</span><span class="p"> </span><span class="n">Natural</span> <span class="kr">range</span><span class="p"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">1000</span><span class="p">;</span>
  <span class="kr">subtype</span><span class="p"> </span><span class="n">IndexType</span> <span class="kr">is</span><span class="p"> </span><span class="n">Positive</span> <span class="kr">range</span><span class="p"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">;</span>
  <span class="kr">type</span><span class="p"> </span><span class="n">ArrayType</span> <span class="kr">is</span><span class="p"> </span><span class="kr">array</span><span class="p"> </span><span class="o">(</span><span class="n">IndexType</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">ElementType</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Clear</span> <span class="o">(</span><span class="n">A</span><span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">ArrayType</span><span class="p">;</span> <span class="n">L</span><span class="p">,</span><span class="n">U</span><span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">IndexType</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">U</span><span class="o">))</span><span class="p">,</span>
          <span class="n">Post</span>    <span class="o">=&gt;</span> <span class="o">(</span><span class="kr">for</span><span class="p"> </span><span class="kr">all</span><span class="p"> </span><span class="n">N</span> <span class="kr">in</span><span class="p"> </span><span class="n">L..U</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">(</span><span class="n">N</span><span class="o">)</span> <span class="o">=</span> <span class="mi">0</span><span class="o">)</span> <span class="kr">and</span><span class="p"></span>
                     <span class="o">(</span><span class="kr">for</span><span class="p"> </span><span class="kr">all</span><span class="p"> </span><span class="n">N</span> <span class="kr">in</span><span class="p"> </span><span class="n">IndexType</span> <span class="o">=&gt;</span>
                         <span class="o">(</span><span class="kr">if</span><span class="p"> </span><span class="n">N</span><span class="o">&lt;</span><span class="n">L</span> <span class="kr">or</span><span class="p"> </span><span class="n">N</span><span class="o">&gt;</span><span class="n">U</span> <span class="kr">then</span><span class="p"> </span><span class="n">A</span><span class="o">(</span><span class="n">N</span><span class="o">)</span> <span class="o">=</span> <span class="n">A</span><span class="na">&#39;Old</span><span class="o">(</span><span class="n">N</span><span class="o">)))</span><span class="p">;</span>

<span class="k">end Loop</span><span class="n">_Entry</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Body in SPARK 2014:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">SPARK_Mode</span> <span class="o">(</span><span class="n">On</span><span class="o">)</span><span class="p">;</span>
<span class="k">package body </span><span class="nf">Loop_Entry</span>
<span class="kr">is</span><span class="p"></span>

  <span class="k">procedure </span><span class="nf">Clear</span> <span class="o">(</span><span class="n">A</span><span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">ArrayType</span><span class="p">;</span> <span class="n">L</span><span class="p">,</span><span class="n">U</span><span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">IndexType</span><span class="o">)</span>
  <span class="kr">is</span><span class="p"></span>
  <span class="kr">begin</span><span class="p"></span>
    <span class="kr">for</span><span class="p"> </span><span class="n">I</span> <span class="kr">in</span><span class="p"> </span><span class="n">IndexType</span> <span class="kr">range</span><span class="p"> </span><span class="n">L..U</span> <span class="kr">loop</span><span class="p"></span>
      <span class="n">A</span><span class="o">(</span><span class="n">I</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
         <span class="kr">pragma</span><span class="p"> </span><span class="n">Loop_Invariant</span> <span class="o">((</span><span class="kr">for</span><span class="p"> </span><span class="kr">all</span><span class="p"> </span><span class="n">N</span> <span class="kr">in</span><span class="p"> </span><span class="n">L..I</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A</span><span class="o">(</span><span class="n">N</span><span class="o">)</span> <span class="o">=</span> <span class="mi">0</span><span class="o">))</span> <span class="kr">and</span><span class="p"></span>
           <span class="o">(</span><span class="kr">for</span><span class="p"> </span><span class="kr">all</span><span class="p"> </span><span class="n">N</span> <span class="kr">in</span><span class="p"> </span><span class="n">IndexType</span> <span class="o">=&gt;</span>
              <span class="o">(</span><span class="kr">if</span><span class="p"> </span><span class="n">N</span> <span class="o">&lt;</span> <span class="n">L</span> <span class="kr">or</span><span class="p"> </span><span class="n">N</span> <span class="o">&gt;</span> <span class="n">I</span> <span class="kr">then</span><span class="p"> </span><span class="n">A</span><span class="o">(</span><span class="n">N</span><span class="o">)</span> <span class="o">=</span> <span class="n">A</span><span class="na">&#39;Loop_Entry</span><span class="o">(</span><span class="n">N</span><span class="o">))))</span><span class="p">;</span>
      <span class="c">-- Note it is not necessary to show that the vaule of U does not change</span>
      <span class="c">-- within the loop.</span>
      <span class="c">-- However &#39;Loop_Entry must be used rather than &#39;Old.</span>
    <span class="k">end loop</span><span class="p">;</span>
  <span class="k">end </span><span class="nf">Clear</span><span class="p">;</span>

<span class="k">end Loop</span><span class="n">_Entry</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="gfdl.html" title="GNU Free Documentation License"
             >next</a> |</li>
        <li class="right" >
          <a href="glossary.html" title="17. Glossary"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">SPARK 2014 Reference Manual 2019</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2013-2019, AdaCore and Altran UK Ltd.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.2.
    </div>
  </body>
</html>