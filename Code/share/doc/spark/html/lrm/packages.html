<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>7. Packages &#8212; SPARK 2014 Reference Manual 2019</title>
    
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2019',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="8. Visibility Rules" href="visibility-rules.html" />
    <link rel="prev" title="6. Subprograms" href="subprograms.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="visibility-rules.html" title="8. Visibility Rules"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="subprograms.html" title="6. Subprograms"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">SPARK 2014 Reference Manual 2019</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">7. Packages</a><ul>
<li><a class="reference internal" href="#package-specifications-and-declarations">7.1. Package Specifications and Declarations</a><ul>
<li><a class="reference internal" href="#abstraction-of-state">7.1.1. Abstraction of State</a></li>
<li><a class="reference internal" href="#external-state">7.1.2. External State</a></li>
<li><a class="reference internal" href="#external-state-variables">7.1.3. External State - Variables</a></li>
<li><a class="reference internal" href="#abstract-state-aspects">7.1.4. Abstract_State Aspects</a></li>
<li><a class="reference internal" href="#initializes-aspects">7.1.5. Initializes Aspects</a></li>
<li><a class="reference internal" href="#initial-condition-aspects">7.1.6. Initial_Condition Aspects</a></li>
</ul>
</li>
<li><a class="reference internal" href="#package-bodies">7.2. Package Bodies</a><ul>
<li><a class="reference internal" href="#state-refinement">7.2.1. State Refinement</a></li>
<li><a class="reference internal" href="#refined-state-aspects">7.2.2. Refined_State Aspects</a></li>
<li><a class="reference internal" href="#initialization-issues">7.2.3. Initialization Issues</a></li>
<li><a class="reference internal" href="#refined-global-aspects">7.2.4. Refined_Global Aspects</a></li>
<li><a class="reference internal" href="#refined-depends-aspects">7.2.5. Refined_Depends Aspects</a></li>
<li><a class="reference internal" href="#abstract-state-package-hierarchy-and-part-of">7.2.6. Abstract_State, Package Hierarchy and Part_Of</a></li>
<li><a class="reference internal" href="#refined-postcondition-aspects">7.2.7. Refined Postcondition Aspects</a></li>
<li><a class="reference internal" href="#refined-external-states">7.2.8. Refined External States</a></li>
</ul>
</li>
<li><a class="reference internal" href="#private-types-and-private-extensions">7.3. Private Types and Private Extensions</a><ul>
<li><a class="reference internal" href="#private-operations">7.3.1. Private Operations</a></li>
<li><a class="reference internal" href="#type-invariants">7.3.2. Type Invariants</a></li>
<li><a class="reference internal" href="#default-initial-condition-aspects">7.3.3. Default_Initial_Condition Aspects</a></li>
</ul>
</li>
<li><a class="reference internal" href="#deferred-constants">7.4. Deferred Constants</a></li>
<li><a class="reference internal" href="#limited-types">7.5. Limited Types</a></li>
<li><a class="reference internal" href="#assignment-and-finalization">7.6. Assignment and Finalization</a></li>
<li><a class="reference internal" href="#elaboration-issues">7.7. Elaboration Issues</a><ul>
<li><a class="reference internal" href="#use-of-initial-condition-and-initializes-aspects">7.7.1. Use of Initial_Condition and Initializes Aspects</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="subprograms.html"
                        title="previous chapter">6. Subprograms</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="visibility-rules.html"
                        title="next chapter">8. Visibility Rules</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/packages.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="packages">
<h1>7. Packages<a class="headerlink" href="#packages" title="Permalink to this headline">¶</a></h1>
<p class="centered">
<strong><strong>Verification Rules</strong></strong></p><ol class="arabic simple" id="tu-fa-packages-01">
<li>The elaboration of a package shall not update, directly or
indirectly, a reachable element of a variable that is not declared
immediately within the package. [Roughly speaking, this means that
the outputs of the notional spec and body elaboration subprograms
shall all be objects declared immediately within the package.]</li>
</ol>
<ol class="arabic simple" id="tu-fa-packages-02" start="2">
<li>The elaboration of a package declaration or body shall not leave any
object in the Moved state unless the object was already in the Moved
state at the start of that elaboration.</li>
</ol>
<div class="section" id="package-specifications-and-declarations">
<span id="etu-packages"></span><h2>7.1. Package Specifications and Declarations<a class="headerlink" href="#package-specifications-and-declarations" title="Permalink to this headline">¶</a></h2>
<div class="section" id="abstraction-of-state">
<span id="abstract-state"></span><h3>7.1.1. Abstraction of State<a class="headerlink" href="#abstraction-of-state" title="Permalink to this headline">¶</a></h3>
<p>The variables declared within a package but not within a subprogram body or
block which does not also enclose the given package constitute the <em>persistent
state</em> of the package. A package&#8217;s persistent state is divided into <em>visible
state</em> and <em>hidden state</em>. If a declaration that is part of a package&#8217;s
persistent state is visible outside of the package, then it is a constituent of
the package&#8217;s visible state; otherwise it is a constituent of the package&#8217;s
hidden state.</p>
<p>Though the variables may be hidden they still form part (or all) of
the persistent state of the package and the hidden state cannot be
ignored.  <em>State abstraction</em> is the means by which this hidden state
is represented and managed. A state abstraction represents one or more
declarations which are part of the hidden state of a package.</p>
<p>SPARK 2014 extends the concept of state abstraction to provide hierarchical data
abstraction whereby the state abstraction declared in a package may contain the
persistent state of other packages given certain restrictions described in
<a class="reference internal" href="#package-hierarchy"><span class="std std-ref">Abstract_State, Package Hierarchy and Part_Of</span></a>. This provides data refinement similar to the
refinement available to types whereby a record may contain fields which are
themselves records.</p>
<p class="centered">
<strong><strong>Static Semantics</strong></strong></p><ol class="arabic simple" id="tu-abstract-state-01">
<li>The visible state of a package P consists of:<ul>
<li>any variables, or <em>constants with variable inputs</em>, declared immediately
within the visible part of package P; and</li>
<li>the state abstractions declared by the Abstract_State aspect specification
(if any) of package P; and</li>
<li>the visible state of any packages declared immediately within the visible
part of package P.</li>
</ul>
</li>
<li>The hidden state of a package P consists of:<ul>
<li>any variables, or <em>constants with variable inputs</em>, declared immediately
in the private part or body of P; and</li>
<li>the visible state of any packages declared immediately within
the private part or body of P.</li>
</ul>
</li>
<li>The preceding two rules notwithstanding, an object or state abstraction
whose Part_Of aspect refers to a task or protected unit is not (directly)
part of the visible state or hidden state of any package (see section
<a class="reference internal" href="tasks-and-synchronization.html#tasks-and-synchronization"><span class="std std-ref">Tasks and Synchronization</span></a>).</li>
</ol>
</div>
<div class="section" id="external-state">
<span id="etu-abstract-state"></span><span id="id1"></span><h3>7.1.2. External State<a class="headerlink" href="#external-state" title="Permalink to this headline">¶</a></h3>
<p>External state is a state abstraction or variable representing something
external to a program. For instance, an input or output device, or a
communication channel to another subsystem such as another SPARK 2014 program.</p>
<p>Updating external state might have some external effect. It could be writing
a value to be read by some external device or subsystem which then has a
potential effect on that device or subsystem. Similarly the value read from an
external state might depend on a value provided by some external device or
subsystem.</p>
<p>Ada uses the terms external readers and writers to describe entities external to
a program which interact with the program through reading and writing data. Of
particular concern to SPARK 2014 are external readers and writers which are not
strictly under control of the program. It is not known precisely when a value
will be written or read by an external reader or writer. These are called
<em>asynchronous readers</em> and <em>asynchronous writers</em> in SPARK 2014.</p>
<p>Each read or update of an external state might be significant, for
instance reading or writing a stream of characters to a file, or
individual reads or writes might not be significant, for instance
reading a temperature from a device or writing the same value to a
lamp driver or display. SPARK 2014 provides a mechanism to indicate
whether a read or write is always significant.</p>
<p>A type is said to be <em>effectively volatile</em> if it is either
a volatile type, an array type whose Volatile_Component
aspect is True, or an array type whose component type is
effectively volatile, a protected type, or a descendant of
the type Ada.Synchronous_Task_Control.Suspension_Object.
An <em>effectively volatile object</em> is a volatile object or an object
of an effectively volatile type.</p>
<p>External state is an effectively volatile object or a state abstraction which
represents one or more effectively volatile objects (or it could be a null state
abstraction; see <a class="reference internal" href="#abstract-state-aspect"><span class="std std-ref">Abstract_State Aspects</span></a>). [The term &#8220;external&#8221; does
not necessarily mean that this state is accessed outside of
the SPARK portion of the program (although it might be); it refers to the
state being potentially visible to multiple tasks (as well as to the outside
world), so that it is externally visible from the perspective of any one task.]</p>
<p>Four Boolean valued <em>properties</em> of external states that may be specified are
defined:</p>
<blockquote>
<div><ul class="simple">
<li>Async_Readers - a component of the system external to the program might
read/consume a value written to an external state.</li>
<li>Async_Writers - a component of the system external to the program might
update the value of an external state.</li>
<li>Effective_Writes - every update of the external state is significant.</li>
<li>Effective_Reads - every read of the external state is significant.</li>
</ul>
</div></blockquote>
<p>These properties may be specified for an effectively volatile object
as Boolean aspects or as external properties of an external state abstraction.</p>
<p>The Boolean aspect Volatile_Function may be specified as part of the
(explicit) initial declaration of a function. A function whose
Volatile_Function aspect is True is said to be a <em>volatile function</em>.
A protected function is also defined to be a <em>volatile function</em>, as is
an instance of Unchecked_Conversion where one or both of the actual
Source and Target types are effectively volatile types.
[Unlike nonvolatile functions, two calls to a volatile function with all
inputs equal need not return the same result. However note that the rule
that a function must not have any output still applies; in effect this bans
a volatile function from reading an object with Effective_Reads =&gt; True.]</p>
<p>A protected function whose Volatile_Function aspect is False is said
to be &#8220;nonvolatile for internal calls&#8221;.</p>
<p class="centered">
<strong><strong>Legality Rules</strong></strong></p><ol class="arabic simple" id="tu-fe-external-state-01">
<li>If an external state is declared without any of the external
properties specified then all of the properties default to a value
of True.</li>
</ol>
<ol class="arabic simple" id="tu-fe-external-state-02" start="2">
<li>If just the name of the property is given then its value defaults
to True [for instance Async_Readers defaults to Async_Readers =&gt;
True].</li>
</ol>
<ol class="arabic simple" id="tu-fe-external-state-03" start="3">
<li>A property may be explicitly given the value False [for instance Async_Readers =&gt; False].</li>
</ol>
<ol class="arabic simple" id="tu-fe-external-state-04" start="4">
<li>If any one property is explicitly defined, all undefined properties default to a value of False.</li>
</ol>
<ol class="arabic simple" id="tu-fe-external-state-05" start="5">
<li>The expression defining the Boolean valued property shall be static.</li>
</ol>
<ol class="arabic" id="tu-fe-external-state-06" start="6">
<li><p class="first">Only the following combinations of properties are valid:</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="23%" />
<col width="28%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Async_Readers</th>
<th class="head">Async_Writers</th>
<th class="head">Effective_Writes</th>
<th class="head">Effective_Reads</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>True</td>
<td>&#8211;</td>
<td>True</td>
<td>&#8211;</td>
</tr>
<tr class="row-odd"><td>&#8211;</td>
<td>True</td>
<td>&#8211;</td>
<td>True</td>
</tr>
<tr class="row-even"><td>True</td>
<td>&#8211;</td>
<td>&#8211;</td>
<td>&#8211;</td>
</tr>
<tr class="row-odd"><td>&#8211;</td>
<td>True</td>
<td>&#8211;</td>
<td>&#8211;</td>
</tr>
<tr class="row-even"><td>True</td>
<td>True</td>
<td>True</td>
<td>&#8211;</td>
</tr>
<tr class="row-odd"><td>True</td>
<td>True</td>
<td>&#8211;</td>
<td>True</td>
</tr>
<tr class="row-even"><td>True</td>
<td>True</td>
<td>&#8211;</td>
<td>&#8211;</td>
</tr>
<tr class="row-odd"><td>True</td>
<td>True</td>
<td>True</td>
<td>True</td>
</tr>
</tbody>
</table>
<p>[Another way of expressing this rule is that Effective_Reads can
only be True if Async_Writers is True and Effective_Writes can only
be True if Async_Readers is True.]</p>
</li>
</ol>
<p class="centered" id="etu-external-state-lr">
<strong><strong>Static Semantics</strong></strong></p><ol class="arabic simple" id="tu-fa-external-state-07" start="7">
<li>Every update of an external state is considered to be read by
some external reader if Async_Readers =&gt; True.</li>
</ol>
<ol class="arabic simple" id="tu-pr-external-state-08" start="8">
<li>Each successive read of an external state might have a different
value [written by some external writer] if Async_Writers =&gt; True.</li>
</ol>
<ol class="arabic simple" id="tu-fa-external-state-09" start="9">
<li>If Effective_Writes =&gt; True, then every value written to the
external state is significant. [For instance writing a sequence of
values to a port.]</li>
</ol>
<ol class="arabic simple" id="tu-pr-external-state-10" start="10">
<li>If Effective_Reads =&gt; True, then every value read from the
external state is significant. [For example a value read from a
port might be used in determining how the next value is
processed.]</li>
</ol>
<ol class="arabic simple" id="tu-fa-external-state-11" start="11">
<li>Each update of an external state has no external effect if both
Async_Readers =&gt; False and Effective_Writes =&gt; False.</li>
</ol>
<ol class="arabic simple" id="tu-pr-external-state-12" start="12">
<li>Each successive read of an external state will result in the last
value explicitly written [by the program] if Async_Writers =&gt; False.</li>
</ol>
<ol class="arabic simple" id="tu-fa-external-state-13" start="13">
<li>Every explicit update of an external state might affect the next value
read from the external state even if Async_Writers =&gt; True.</li>
</ol>
<ol class="arabic simple" id="tu-fa-external-state-14" start="14">
<li>An external state which has the property Async_Writers =&gt; True
need not be initialized before being read although explicit
initialization is permitted. [The external state might be
initialized by an external writer.]</li>
</ol>
<ol class="arabic simple" id="tu-fa-external-state-15" start="15">
<li>A subprogram whose Volatile_Function aspect is True shall not override
an inherited primitive operation of a tagged type whose
Volatile_Function aspect is False. [The reverse is allowed.]</li>
</ol>
<ol class="arabic simple" id="tu-fa-external-state-16" start="16">
<li>A protected object has at least the properties Async_Writers =&gt; True
and Async_Readers =&gt; True. If and only if it has at least one Part_Of
component with Effective_Writes =&gt; True or Effective_Reads =&gt; True,
then the protected object also carries this property. [This is
particularly relevant if a protected object is a constituent of an
external state, or if a protected object is an input of a volatile
function.]</li>
</ol>
</div>
<div class="section" id="external-state-variables">
<span id="etu-external-state-ss"></span><span id="id2"></span><h3>7.1.3. External State - Variables<a class="headerlink" href="#external-state-variables" title="Permalink to this headline">¶</a></h3>
<p>In Ada interfacing to an external device or subsystem normally entails
using one or more effectively volatile objects to ensure that writes and reads
to the device are not optimized by the compiler into internal register
reads and writes.</p>
<p>SPARK 2014 refines the specification of volatility by introducing four new Boolean
aspects which may be applied only to effectively volatile objects. The aspects
may be specified in the aspect specification of an object declaration
(this excludes effectively volatile objects that are formal parameters).</p>
<p>The new aspects are:</p>
<blockquote>
<div><ul class="simple">
<li>Async_Readers - as described in <a class="reference internal" href="#external-state"><span class="std std-ref">External State</span></a>.</li>
<li>Async_Writers - as described in <a class="reference internal" href="#external-state"><span class="std std-ref">External State</span></a>.</li>
<li>Effective_Reads - as described in <a class="reference internal" href="#external-state"><span class="std std-ref">External State</span></a>.</li>
<li>Effective_Writes - as described in <a class="reference internal" href="#external-state"><span class="std std-ref">External State</span></a>.</li>
</ul>
</div></blockquote>
<p>These four aspects are said to be the <em>volatility refinement</em> aspects.
Ada&#8217;s notion of volatility corresponds to the case where all four
aspects are True. Specifying a volatility
refinement aspect value of False for an object
grants permission for the SPARK 2014 implementation to make additional
assumptions about how the object in question is accessed;
it is the responsibility of the user to ensure that these assumptions hold.
In contrast, specifying a value of True imposes no such obligation on the user.</p>
<p>For example, consider</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span> <span class="kr">with</span><span class="p"> </span><span class="n">Volatile</span><span class="p">,</span> <span class="n">Async_Readers</span> <span class="o">=&gt;</span> <span class="kc">True</span><span class="p">,</span> <span class="n">Async_Writers</span> <span class="o">=&gt;</span> <span class="kc">False</span><span class="p">,</span>
                           <span class="n">Effective_Reads</span> <span class="o">=&gt;</span> <span class="kc">True</span><span class="p">,</span> <span class="n">Effective_Writes</span> <span class="o">=&gt;</span> <span class="kc">True</span><span class="p">;</span>
<span class="o">...</span>
<span class="k">procedure </span><span class="nf">Proc</span> <span class="kr">with</span><span class="p"> </span><span class="o">...</span> <span class="kr">is</span><span class="p"></span>
  <span class="n">Y</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
<span class="kr">begin</span><span class="p"></span>
  <span class="n">X</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">Y</span> <span class="o">:=</span> <span class="n">X</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Assert</span> <span class="o">(</span><span class="n">Y</span> <span class="o">=</span> <span class="mi">0</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Proc</span><span class="p">;</span>
</pre></div>
</div>
<p>The verification condition associated with the assertion can be
successfully discharged but this success depends on the
Async_Writers aspect specification.</p>
<p class="centered">
<strong><strong>Legality Rules</strong></strong></p><ol class="arabic" id="tu-cbatu-external-state-variables-01">
<li><p class="first">In the absence of an explicit aspect specification, the value of a
volatility refinement aspect of an effectively volatile stand-alone object
other than a formal parameter is True. The Effective_Reads aspect of an
effectively volatile formal parameter of mode <strong>in</strong> is False; in all other
cases, the value of a volatility refinement aspect of an effectively
volatile formal parameter is True.</p>
<p>The volatility refinement aspect values of a subcomponent of an object
are those of the enclosing object.</p>
</li>
</ol>
<ol class="arabic simple" id="tu-fe-external-state-variables-02" start="2">
<li>The value of a volatility refinement aspect shall only be specified
for an effectively volatile stand-alone object. [A formal parameter
is not a stand-alone object; see Ada RM 3.3.1 .]</li>
</ol>
<ol class="arabic simple" id="tu-fe-external-state-variables-03" start="3">
<li>The declaration of an effectively volatile stand-alone object
shall be a library-level declaration. [In particular, it shall not be
declared within a subprogram.]</li>
</ol>
<ol class="arabic simple" id="tu-fe-external-state-variables-04" start="4">
<li>A constant object (other than a formal parameter of mode <strong>in</strong>)
shall not be effectively volatile.</li>
</ol>
<ol class="arabic simple" id="tu-fe-external-state-variables-05" start="5">
<li>An effectively volatile type other than a protected type
shall not have a discriminated part.</li>
</ol>
<ol class="arabic simple" id="tu-fe-external-state-variables-06" start="6">
<li>A type which is not effectively volatile shall not have an
effectively volatile component.</li>
</ol>
<ol class="arabic simple" id="tu-fe-external-state-variables-07" start="7">
<li>An effectively volatile object shall not be used as an actual parameter in a
generic instantiation.</li>
</ol>
<ol class="arabic simple" id="tu-fe-external-state-variables-08" start="8">
<li>A <code class="docutils literal"><span class="pre">global_item</span></code> of a nonvolatile function, or of a function which
is nonvolatile for internal calls, shall not denote either
an effectively volatile object or an external state abstraction.</li>
</ol>
<ol class="arabic simple" id="tu-fe-nt-external-state-variables-09" start="9">
<li>A formal parameter (or result) of a nonvolatile function, or of a
function which is nonvolatile for internal calls, shall not be of
an effectively volatile type. [For a protected function, this rule
does not apply to the notional parameter denoting the current instance of
the associated protected unit described in section <a class="reference internal" href="subprograms.html#global-aspects"><span class="std std-ref">Global Aspects</span></a>.]</li>
</ol>
<ol class="arabic simple" id="tu-fe-external-state-variables-10" start="10">
<li>If a procedure has an <strong>in</strong> mode parameter of an effectively
volatile type, then the Effective_Reads aspect of any corresponding
actual parameter shall be False.
[This is because the parameter is passed by reference and the corresponding
aspect of the formal parameter is False. In the 11 other cases,
corresponding to the combination of a parameter mode and a volatility
refinement aspect, the volatility refinement aspect of the formal parameter
is True and so the aspect of the corresponding actual parameter may be
either True or False.]</li>
</ol>
<ol class="arabic simple" id="tu-fe-nt-external-state-variables-11" start="11">
<li>An effectively volatile object shall only occur as an actual
parameter of a subprogram if the corresponding formal parameter is
of a non-scalar effectively volatile type or as an actual
parameter in a call to an instance of Unchecked_Conversion.</li>
</ol>
<ol class="arabic simple" id="tu-fe-external-state-variables-12" start="12">
<li>Contrary to the general SPARK 2014 rule that expression evaluation
cannot have side effects, a read of an effectively volatile object with
the properties Async_Writers or Effective_Reads set to True is
considered to have an effect when read. To reconcile this
discrepancy, a name denoting such an object shall only occur in
a <em>non-interfering context</em>. A name occurs in a non-interfering
context if it is:</li>
</ol>
<blockquote>
<div><ul class="simple">
<li>the name on the left-hand side of an assignment statement; or</li>
<li>the [right-hand side] expression of an assignment statement; or</li>
<li>the expression of an initialization expression of an object declaration; or</li>
<li>the <code class="docutils literal"><span class="pre">object_name</span></code> of an <code class="docutils literal"><span class="pre">object_renaming_declaration</span></code>; or</li>
<li>the actual parameter in a call to an instance of Unchecked_Conversion
whose result is renamed [in an object renaming declaration]; or</li>
<li>an actual parameter in a call for which the corresponding
formal parameter is of a non-scalar effectively volatile type; or</li>
<li>the (protected) prefix of a name denoting a protected operation; or</li>
<li>the return expression of a <code class="docutils literal"><span class="pre">simple_return_statement</span></code> which applies
to a volatile function; or</li>
<li>the initial value expression of the <code class="docutils literal"><span class="pre">extended_return_object_declaration</span></code>
of an <code class="docutils literal"><span class="pre">extended_return_statement</span></code> which applies to a
volatile function; or</li>
<li>the prefix of a <code class="docutils literal"><span class="pre">slice</span></code>, <code class="docutils literal"><span class="pre">selected_component</span></code>, <code class="docutils literal"><span class="pre">indexed_component</span></code>,
or <code class="docutils literal"><span class="pre">attribute_reference</span></code> which is itself a name occurring in a
non-interfering context; or</li>
<li>the prefix of an <code class="docutils literal"><span class="pre">attribute_reference</span></code> whose <code class="docutils literal"><span class="pre">attribute_designator</span></code> is
either Alignment, Component_Size, First, First_Bit, Last, Last_Bit,
Length, Position, Size, or Storage_Size; or</li>
<li>the expression of a type conversion occurring in a non-interfering context; or</li>
<li>the expression in a <code class="docutils literal"><span class="pre">delay_statement</span></code>.</li>
</ul>
<p>[The attributes listed above all have the property that when their prefix
denotes an object, evaluation of the attribute does not involve the
evaluation of any part ot the object.]</p>
<p>The same restrictions also apply to a call to a volatile function
(except not in the case of an internal call to a protected function
which is nonvolatile for internal calls)
and to the evaluation of any attribute which is defined to introduce
an implicit dependency on a volatile state abstraction [(these are
the Callable, Caller, Count, and Terminated attributes; see section
<a class="reference internal" href="tasks-and-synchronization.html#tasks-and-synchronization"><span class="std std-ref">Tasks and Synchronization</span></a>)]. [An internal call to a protected
function is treated like a call to a nonvolatile function if the
function&#8217;s Volatile_Function aspect is False.]</p>
</div></blockquote>
<p class="centered" id="etu-external-state-variables-lr">
<strong><strong>Dynamic Semantics</strong></strong></p><ol class="arabic simple" start="13">
<li>There are no dynamic semantics associated with these aspects.</li>
</ol>
<p class="centered">
<strong><strong>Verification Rules</strong></strong></p><ol class="arabic simple" start="14">
<li>An effectively volatile formal parameter of mode <strong>out</strong> shall not be read,
even after it has been updated. [This is because the
Async_Writers aspect of the parameter is True].</li>
</ol>
<p class="centered" id="etu-external-state-variables-vr">
<strong><strong>Examples</strong></strong></p><div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">System.Storage_Elements</span><span class="p">;</span>

<span class="k">package </span><span class="nf">Input_Port</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">Sensor</span> <span class="o">:</span> <span class="n">Integer</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Volatile</span><span class="p">,</span>
          <span class="n">Async_Writers</span><span class="p">,</span>
          <span class="n">Address</span> <span class="o">=&gt;</span> <span class="n">System.Storage_Elements.To_Address</span> <span class="o">(</span><span class="mi">16#ACECAF0#</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Input_Port</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">System.Storage_Elements</span><span class="p">;</span>

<span class="k">package </span><span class="nf">Output_Port</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">Sensor</span> <span class="o">:</span> <span class="n">Integer</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Volatile</span><span class="p">,</span>
          <span class="n">Async_Readers</span><span class="p">,</span>
          <span class="n">Address</span> <span class="o">=&gt;</span> <span class="n">System.Storage_Elements.To_Address</span> <span class="o">(</span><span class="mi">16#ACECAF0#</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Output_Port</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">System.Storage_Elements</span><span class="p">;</span>

<span class="k">package </span><span class="nf">Multiple_Ports</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span>
<span class="kr">is</span><span class="p"></span>
   <span class="kr">type</span><span class="p"> </span><span class="n">Volatile_Type</span> <span class="kr">is</span><span class="p"> </span><span class="kr">record</span><span class="p"></span>
      <span class="n">I</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="k">end record</span> <span class="kr">with</span><span class="p"> </span><span class="n">Volatile</span><span class="p">;</span>

   <span class="c">--  This type declaration indicates all objects of this type will</span>
   <span class="c">--  be volatile. We can declare a number of objects of this type</span>
   <span class="c">--  with different properties.</span>

   <span class="c">--  V_In_1 is essentially an external input since it has</span>
   <span class="c">--  Async_Writers =&gt; True but Async_Readers =&gt; False. Reading a</span>
   <span class="c">--  value from V_In_1 is independent of other reads of the same</span>
   <span class="c">--  object. Two successive reads might not have the same value.</span>
   <span class="n">V_In_1</span> <span class="o">:</span> <span class="n">Volatile_Type</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Async_Writers</span><span class="p">,</span>
          <span class="n">Address</span> <span class="o">=&gt;</span> <span class="n">System.Storage_Elements.To_Address</span> <span class="o">(</span><span class="mi">16#A1CAF0#</span><span class="o">)</span><span class="p">;</span>

   <span class="c">--  V_In_2 is similar to V_In_1 except that each value read is</span>
   <span class="c">--  significant. V_In_2 can only be used as a Global with a</span>
   <span class="c">--  mode_Selector of Output or In_Out or as an actual parameter</span>
   <span class="c">--  whose corresponding formal parameter is of a Volatile type and</span>
   <span class="c">--  has mode out or in out.</span>
   <span class="n">V_In_2</span> <span class="o">:</span> <span class="n">Volatile_Type</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Async_Writers</span><span class="p">,</span>
          <span class="n">Effective_Reads</span><span class="p">,</span>
          <span class="n">Address</span> <span class="o">=&gt;</span> <span class="n">System.Storage_Elements.To_Address</span> <span class="o">(</span><span class="mi">16#ABCCAF0#</span><span class="o">)</span><span class="p">;</span>


   <span class="c">--  V_Out_1 is essentially an external output since it has</span>
   <span class="c">--  Async_Readers =&gt; True but Async_Writers =&gt; False. Writing the</span>
   <span class="c">--  same value successively might not have an observable effect.</span>
   <span class="n">V_Out_1</span> <span class="o">:</span> <span class="n">Volatile_Type</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Async_Readers</span><span class="p">,</span>
          <span class="n">Address</span> <span class="o">=&gt;</span> <span class="n">System.Storage_Elements.To_Address</span> <span class="o">(</span><span class="mi">16#BBCCAF0#</span><span class="o">)</span><span class="p">;</span>

   <span class="c">--  V_Out_2 is similar to V_Out_1 except that each write to</span>
   <span class="c">--  V_Out_2 is significant.</span>
   <span class="n">V_Out_2</span> <span class="o">:</span> <span class="n">Volatile_Type</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Async_Readers</span><span class="p">,</span>
          <span class="n">Effective_Writes</span><span class="p">,</span>
          <span class="n">Address</span> <span class="o">=&gt;</span> <span class="n">System.Storage_Elements.To_Address</span> <span class="o">(</span><span class="mi">16#ADACAF0#</span><span class="o">)</span><span class="p">;</span>

   <span class="c">--  This declaration defaults to the following properties:</span>
   <span class="c">--    Async_Readers    =&gt; True,</span>
   <span class="c">--    Async_Writers    =&gt; True,</span>
   <span class="c">--    Effective_Reads  =&gt; True,</span>
   <span class="c">--    Effective_Writes =&gt; True;</span>
   <span class="c">--  That is the most comprehensive type of external interface which</span>
   <span class="c">--  is bi-directional and each read and write has an observable</span>
   <span class="c">--  effect.</span>
   <span class="n">V_In_Out</span> <span class="o">:</span> <span class="n">Volatile_Type</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Address</span> <span class="o">=&gt;</span> <span class="n">System.Storage_Elements.To_Address</span> <span class="o">(</span><span class="mi">16#BEECAF0#</span><span class="o">)</span><span class="p">;</span>

   <span class="c">--  These volatile variable declarations may be used in specific</span>
   <span class="c">--  ways as global items and actual parameters of subprogram calls</span>
   <span class="c">--  depend on their properties.</span>

   <span class="k">procedure </span><span class="nf">Read</span> <span class="o">(</span><span class="n">Value</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span> <span class="o">=&gt;</span> <span class="n">V_In_1</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Value</span> <span class="o">=&gt;</span> <span class="n">V_in_1</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--  V_In_1, V_Out_1 and V_Out_2 are compatible with a mode selector</span>
   <span class="c">--  of Input as this mode requires Effective_Reads =&gt; False.</span>

   <span class="k">procedure </span><span class="nf">Write</span> <span class="o">(</span><span class="n">Value</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">V_Out_1</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">V_Out_1</span> <span class="o">=&gt;</span> <span class="n">Value</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--  Any Volatile Global is compatible with a mode selector of</span>
   <span class="c">--  Output. A flow error will be raised if the subprogram attempts</span>
   <span class="c">--  to read a Volatile Global with Async_Writers and/or</span>
   <span class="c">--  Effective_Reads set to True.</span>

   <span class="k">procedure </span><span class="nf">Read_With_Effect</span> <span class="o">(</span><span class="n">Value</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">V_In_2</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Value</span>  <span class="o">=&gt;</span> <span class="n">V_In_2</span><span class="p">,</span>
                      <span class="n">V_In_2</span> <span class="o">=&gt;</span> <span class="n">null</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--  Any Volatile Global is compatible with a mode selector of</span>
   <span class="c">--  In_Out. The Depends aspect is used to specify how the Volatile</span>
   <span class="c">--  Global is intended to be used and this is checked by flow</span>
   <span class="c">--  analysis to be compatible with the properties specified for the</span>
   <span class="c">--  Volatile Global.</span>

   <span class="c">--  When a formal parameter is volatile, assumptions have to be</span>
   <span class="c">--  made in the body of the subprogram as to the possible</span>
   <span class="c">--  properties that the actual volatile parameter might have</span>
   <span class="c">--  depending on the mode of the formal parameter.</span>

   <span class="k">procedure </span><span class="nf">Read_Port</span> <span class="o">(</span><span class="n">Port</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Volatile_Type</span><span class="p">;</span> <span class="n">Value</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Value</span> <span class="o">=&gt;</span> <span class="n">Port</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--  Port is Volatile and of mode in. Assume that the formal</span>
   <span class="c">--  parameter has the properties Async_Writers =&gt; True and</span>
   <span class="c">--  Effective_Reads =&gt; False. The actual parameter in a call of the</span>
   <span class="c">--  subprogram must have Async_Writers =&gt; True and</span>
   <span class="c">--  Effective_Reads =&gt; False and may have Async_Writers and/or</span>
   <span class="c">--  Effective_Writes set to True. As an in mode parameter it can</span>
   <span class="c">--  only be read by the subprogram.</span>
   <span class="c">--  Eg. Read_Port (V_In_1, Read_Value).</span>

   <span class="k">procedure </span><span class="nf">Write_Port</span> <span class="o">(</span><span class="n">Port</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Volatile_Type</span><span class="p">;</span> <span class="n">Value</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Port</span> <span class="o">=&gt;</span> <span class="n">Value</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--  Port is volatile and of mode out. Assume the formal parameter</span>
   <span class="c">--  has the properties Async_Readers =&gt; True and</span>
   <span class="c">--  Effective_Writes =&gt; True. The actual parameter in a call to the</span>
   <span class="c">--  subprogram must have Async_Readers and/or Effective_Writes</span>
   <span class="c">--  True, and may have Async_Writers and Effective_Reads True. As</span>
   <span class="c">--  the mode of the formal parameter is mode out, it is</span>
   <span class="c">--  incompatible with reading the parameter because this could read</span>
   <span class="c">--  a value from an Async_Writer. A flow error will be signalled if</span>
   <span class="c">--  a read of the parameter occurs in the subprogram.</span>
   <span class="c">--  Eg. Write_Port (V_Out_1, Output_Value) and</span>
   <span class="c">--      Write_Port (V_Out_2, Output_Value).</span>

   <span class="c">--  A Volatile formal parameter type of mode in out is</span>
   <span class="c">--  assumed to have all the properties True:</span>
   <span class="c">--    Async_Readers    =&gt; True,</span>
   <span class="c">--    Async_Writers    =&gt; True,</span>
   <span class="c">--    Effective_Reads  =&gt; True,</span>
   <span class="c">--    Effective_Writes =&gt; True;</span>
   <span class="c">--  The corresponding actual parameter in a subprogram call must be</span>
   <span class="c">--  volatile with all of the properties set to True.</span>
   <span class="k">procedure </span><span class="nf">Read_And_Ack</span> <span class="o">(</span><span class="n">Port</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Volatile_Type</span><span class="p">;</span> <span class="n">Value</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Value</span> <span class="o">=&gt;</span> <span class="n">Port</span><span class="p">,</span>
                      <span class="n">Port</span>  <span class="o">=&gt;</span> <span class="n">Port</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--  Port is Volatile and reading a value may require the sending of</span>
   <span class="c">--  an acknowledgement, for instance.</span>
   <span class="c">--  Eg. Read_And_Ack (V_In_Out, Read_Value).</span>

<span class="k">end </span><span class="nf">Multiple_Ports</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="abstract-state-aspects">
<span id="abstract-state-aspect"></span><h3>7.1.4. Abstract_State Aspects<a class="headerlink" href="#abstract-state-aspects" title="Permalink to this headline">¶</a></h3>
<p>State abstraction provides a mechanism for naming, in a package’s visible part,
state (typically a collection of variables) that will be declared within the
package’s body (its hidden state). For example, a package declares a visible
procedure and we wish to specify the set of global variables that the procedure
reads and writes as part of the specification of the subprogram. The variables
declared in the package body cannot be named directly in the package
specification. Instead, we introduce a state abstraction which is visible in the
package specification and later, when the package body is declared, we specify
the set of variables that <em>constitute</em> or <em>implement</em> the state abstraction.</p>
<p>If immediately within a package body, for example, a nested package is declared,
then a state abstraction of the inner package may also be part of the
implementation of the given state abstraction of the outer package.</p>
<p>The hidden state of a package may be represented by one or more state
abstractions, with each pair of state abstractions representing disjoint sets of
hidden variables.</p>
<p>If a subprogram P with a Global aspect is declared in the visible part of a
package and P reads or updates any of the hidden state of the package then
the state abstractions shall be denoted by P. If P has a Depends aspect then
the state abstractions shall be denoted as inputs and outputs of P, as
appropriate, in the <code class="docutils literal"><span class="pre">dependency_relation</span></code> of the Depends aspect.</p>
<p>SPARK 2014 facilitates the specification of a hierarchy of state abstractions by
allowing a single state abstraction to contain visible declarations of package
declarations nested immediately within the body of a package, private child or
private sibling units and descendants thereof. Each visible state abstraction or
variable of a private child or descendant thereof has to be specified as being
<em>part of</em> a state abstraction of its parent or a public descendant of its parent.</p>
<p>The Abstract_State aspect is introduced by an <code class="docutils literal"><span class="pre">aspect_specification</span></code>
where the <code class="docutils literal"><span class="pre">aspect_mark</span></code> is Abstract_State and the <code class="docutils literal"><span class="pre">aspect_definition</span></code>
shall follow the grammar of <code class="docutils literal"><span class="pre">abstract_state_list</span></code> given below.</p>
<p class="centered">
<strong><strong>Syntax</strong></strong></p><div class="highlight-default" id="tu-fe-abstract-state-aspects-syntax"><div class="highlight"><pre><span></span><span class="n">abstract_state_list</span>      <span class="p">::</span><span class="o">=</span> <span class="n">null</span>
                           <span class="o">|</span> <span class="n">state_name_with_options</span>
                           <span class="o">|</span> <span class="p">(</span> <span class="n">state_name_with_options</span> <span class="p">{</span> <span class="p">,</span> <span class="n">state_name_with_options</span> <span class="p">}</span> <span class="p">)</span>
<span class="n">state_name_with_options</span>  <span class="p">::</span><span class="o">=</span> <span class="n">state_name</span>
                           <span class="o">|</span> <span class="p">(</span> <span class="n">state_name</span> <span class="k">with</span> <span class="n">option_list</span> <span class="p">)</span>
<span class="n">option_list</span>              <span class="p">::</span><span class="o">=</span> <span class="n">option</span> <span class="p">{</span> <span class="p">,</span> <span class="n">option</span> <span class="p">}</span>
<span class="n">option</span>                   <span class="p">::</span><span class="o">=</span> <span class="n">simple_option</span>
                           <span class="o">|</span> <span class="n">name_value_option</span>
<span class="n">simple_option</span>            <span class="p">::</span><span class="o">=</span> <span class="n">Ghost</span> <span class="o">|</span> <span class="n">Synchronous</span>
<span class="n">name_value_option</span>        <span class="p">::</span><span class="o">=</span> <span class="n">Part_Of</span> <span class="o">=&gt;</span> <span class="n">abstract_state</span>
                           <span class="o">|</span> <span class="n">External</span> <span class="p">[</span><span class="o">=&gt;</span> <span class="n">external_property_list</span><span class="p">]</span>
<span class="n">external_property_list</span>   <span class="p">::</span><span class="o">=</span> <span class="n">external_property</span>
                           <span class="o">|</span> <span class="p">(</span> <span class="n">external_property</span> <span class="p">{,</span> <span class="n">external_property</span><span class="p">}</span> <span class="p">)</span>
<span class="n">external_property</span>        <span class="p">::</span><span class="o">=</span> <span class="n">Async_Readers</span> <span class="p">[</span><span class="o">=&gt;</span> <span class="n">expression</span><span class="p">]</span>
                           <span class="o">|</span> <span class="n">Async_Writers</span> <span class="p">[</span><span class="o">=&gt;</span> <span class="n">expression</span><span class="p">]</span>
                           <span class="o">|</span> <span class="n">Effective_Writes</span> <span class="p">[</span><span class="o">=&gt;</span> <span class="n">expression</span><span class="p">]</span>
                           <span class="o">|</span> <span class="n">Effective_Reads</span>  <span class="p">[</span><span class="o">=&gt;</span> <span class="n">expression</span><span class="p">]</span>
                           <span class="o">|</span> <span class="n">others</span> <span class="o">=&gt;</span> <span class="n">expression</span>
<span class="n">state_name</span>               <span class="p">::</span><span class="o">=</span> <span class="n">defining_identifier</span>
<span class="n">abstract_state</span>           <span class="p">::</span><span class="o">=</span> <span class="n">name</span>
</pre></div>
</div>
<p class="centered" id="etu-abstract-state-aspects-syntax">
<strong><strong>Legality Rules</strong></strong></p><ol class="arabic simple" id="tu-fe-abstract-state-aspects-01">
<li>An <code class="docutils literal"><span class="pre">option</span></code> shall not be repeated within a single <code class="docutils literal"><span class="pre">option_list</span></code>.</li>
</ol>
<ol class="arabic simple" id="tu-fe-abstract-state-aspects-02" start="2">
<li>If External is specified in an <code class="docutils literal"><span class="pre">option_list</span></code> then there shall be at most
one occurrence of each of Async_Readers, Async_Writers, Effective_Writes
and Effective_Reads.</li>
</ol>
<ol class="arabic simple" id="tu-fe-abstract-state-aspects-03" start="3">
<li>If an <code class="docutils literal"><span class="pre">option_list</span></code> contains one or more <code class="docutils literal"><span class="pre">name_value_option</span></code> items
then they shall be the final options in the list.
[This eliminates the possibility of a positional
association following a named association in the property list.]</li>
</ol>
<ol class="arabic" id="tu-fe-abstract-state-aspects-04" start="4">
<li><p class="first">A package_declaration or generic_package_declaration that contains a
non-null Abstract_State aspect shall have a completion (i.e., a body).</p>
<p>[Ada RM 7.1&#8217;s rule defining when a package &#8220;requires a completion&#8221;
is unaffected by the presence of an Abstract_State aspect
specification; such an aspect spec does not cause a
package to &#8220;require a completion&#8221;.
This rule therefore implies that if an Abstract_State aspect
specification occurs anywhere within the specification of a library
unit package or generic package, then that library unit is
going to have to contain a basic_declarative_item that requires
a completion (or have an Elaborate_Body pragma) because otherwise
it would be impossible to  simultaneously satisfy this rule and Ada&#8217;s
rule that a library unit cannot have a package body unless it is required
(Ada RM 7.2(4)). One could imagine a simpler rule that an
Abstract_State aspect specification causes a package to &#8220;require a
completion&#8221;, but we want a SPARK program with its SPARK aspects removed
(or ignored) to remain a legal Ada program.]</p>
</li>
</ol>
<p class="centered" id="etu-abstract-state-aspects-lr">
<strong><strong>Static Semantics</strong></strong></p><ol class="arabic" id="tu-cbatu-abstract-state-aspects-05" start="5">
<li><p class="first">Each <code class="docutils literal"><span class="pre">state_name</span></code> occurring in an Abstract_State aspect
specification for a given package P introduces an implicit
declaration of a state abstraction entity. This implicit
declaration occurs at the beginning of the visible part of P. This
implicit declaration shall have a completion and is overloadable.</p>
<p>[The declaration of a state abstraction has the same visibility as
any other declaration but a state abstraction shall only be named
in contexts where this is explicitly permitted (e.g., as part of a
Global aspect specification). A state abstraction is not an
object; it does not have a type. The completion of a state
abstraction declared in a package <code class="docutils literal"><span class="pre">aspect_specification</span></code> can only
be provided as part of a Refined_State <code class="docutils literal"><span class="pre">aspect_specification</span></code>
within the body of the package.]</p>
</li>
</ol>
<ol class="arabic simple" id="tu-fe-abstract-state-aspects-06" start="6">
<li>A <strong>null</strong> <code class="docutils literal"><span class="pre">abstract_state_list</span></code> specifies that a package contains no
hidden state.</li>
</ol>
<ol class="arabic simple" id="tu-fe-abstract-state-aspects-07" start="7">
<li>An External state abstraction is one declared with an <code class="docutils literal"><span class="pre">option_list</span></code>
that includes the External <code class="docutils literal"><span class="pre">option</span></code> (see <a class="reference internal" href="#external-state"><span class="std std-ref">External State</span></a>).</li>
</ol>
<ol class="arabic simple" id="tu-fe-abstract-state-aspects-08" start="8">
<li>If a state abstraction which is declared with an <code class="docutils literal"><span class="pre">option_list</span></code> that
includes a Part_Of <code class="docutils literal"><span class="pre">name_value_option</span></code> whose <code class="docutils literal"><span class="pre">name</span></code> denote a state
abstraction, this indicates that it is a constituent (see
<a class="reference internal" href="#state-refinement"><span class="std std-ref">State Refinement</span></a>) of the denoted state abstraction.
[Alternatively, the name may denote a task or protected unit (see section
<a class="reference internal" href="tasks-and-synchronization.html#tasks-and-synchronization"><span class="std std-ref">Tasks and Synchronization</span></a>).]</li>
</ol>
<ol class="arabic simple" id="tu-fe-abstract-state-aspects-09" start="9">
<li>A state abstraction for which the <code class="docutils literal"><span class="pre">simple_option</span></code> Ghost is
specified is said to be a ghost state abstraction. A state
abstraction for which the <code class="docutils literal"><span class="pre">simple_option</span></code> Synchronous is
specified is said to be a synchronized state abstraction.
[The option name &#8220;Synchronous&#8221; is used instead of &#8220;Synchronized&#8221;
to avoid unnecessary complications associated with the use of an
Ada reserved word.] Every synchronized state abstraction is
also (by definition) an external state abstraction. A synchronized
state abstraction for which the <code class="docutils literal"><span class="pre">simple_option</span></code> External is
not (explicitly) specified has (by definition) its Async_Readers
and Async_Writers aspects specified to be True and its
Effective_Writes and Effective_Reads aspects specified to be False.</li>
</ol>
<p class="centered" id="etu-abstract-state-aspects-ss">
<strong><strong>Dynamic Semantics</strong></strong></p><p>There are no dynamic semantics associated with the Abstract_State aspect.</p>
<p class="centered">
<strong><strong>Verification Rules</strong></strong></p><p>There are no verification rules associated with the Abstract_State aspect.</p>
<p class="centered">
<strong><strong>Examples</strong></strong></p><div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Q</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="n">State</span>         <span class="c">-- Declaration of abstract state named State</span>
                                       <span class="c">-- representing internal state of Q.</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">Is_Ready</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span>    <span class="c">-- Function checking some property of the State.</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="p">;</span>             <span class="c">-- State may be used in a global aspect.</span>

   <span class="k">procedure </span><span class="nf">Init</span>                      <span class="c">-- Procedure to initialize the internal state of Q.</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">,</span> <span class="c">-- State may be used in a global aspect.</span>
          <span class="n">Post</span>   <span class="o">=&gt;</span> <span class="n">Is_Ready</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Op_1</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span>     <span class="c">-- Another procedure providing some operation on State</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Pre</span>    <span class="o">=&gt;</span> <span class="n">Is_Ready</span><span class="p">,</span>
          <span class="n">Post</span>   <span class="o">=&gt;</span> <span class="n">Is_Ready</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Q</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">X</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A</span><span class="p">,</span>
                          <span class="n">B</span><span class="p">,</span>
                          <span class="o">(</span><span class="n">C</span> <span class="kr">with</span><span class="p"> </span><span class="n">External</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Async_Writers</span><span class="p">,</span>
                                               <span class="n">Effective_Reads</span> <span class="o">=&gt;</span> <span class="kc">False</span><span class="o">))</span>
  <span class="c">--  Three abstract state names are declared A, B &amp; C.</span>
  <span class="c">--  A and B are internal abstract states.</span>
  <span class="c">--  C is specified as external state which is an external input.</span>
<span class="kr">is</span><span class="p"></span>
   <span class="o">...</span>
<span class="k">end </span><span class="nf">X</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="initializes-aspects">
<span id="initializes-aspect"></span><h3>7.1.5. Initializes Aspects<a class="headerlink" href="#initializes-aspects" title="Permalink to this headline">¶</a></h3>
<p>The Initializes aspect specifies the visible variables and state abstractions of
a package that are initialized by the elaboration of the package. In SPARK 2014
a package shall only initialize variables declared immediately within the package.</p>
<p>If the initialization of a variable or state abstraction, <em>V</em>, during the
elaboration of a package, <em>P</em>, is dependent on the value of a visible variable or
state abstraction from another package, then this entity shall be denoted in
the input list associated with <em>V</em> in the Initializes aspect of <em>P</em>.</p>
<p>The Initializes aspect is introduced by an <code class="docutils literal"><span class="pre">aspect_specification</span></code> where the
<code class="docutils literal"><span class="pre">aspect_mark</span></code> is Initializes and the <code class="docutils literal"><span class="pre">aspect_definition</span></code> shall follow the
grammar of <code class="docutils literal"><span class="pre">initialization_spec</span></code> given below.</p>
<p class="centered">
<strong><strong>Syntax</strong></strong></p><div class="highlight-default" id="tu-fe-initializes-aspects-syntax"><div class="highlight"><pre><span></span><span class="n">initialization_spec</span> <span class="p">::</span><span class="o">=</span> <span class="n">initialization_list</span>
                      <span class="o">|</span> <span class="n">null</span>

<span class="n">initialization_list</span> <span class="p">::</span><span class="o">=</span> <span class="n">initialization_item</span>
                      <span class="o">|</span> <span class="p">(</span> <span class="n">initialization_item</span> <span class="p">{</span> <span class="p">,</span> <span class="n">initialization_item</span> <span class="p">}</span> <span class="p">)</span>

<span class="n">initialization_item</span> <span class="p">::</span><span class="o">=</span> <span class="n">name</span> <span class="p">[</span> <span class="o">=&gt;</span> <span class="n">input_list</span><span class="p">]</span>
</pre></div>
</div>
<p class="centered" id="etu-initializes-aspects-syntax">
<strong><strong>Legality Rules</strong></strong></p><ol class="arabic simple" id="tu-fe-initializes-aspects-01">
<li>An Initializes aspect shall only appear in the <code class="docutils literal"><span class="pre">aspect_specification</span></code> of a
<code class="docutils literal"><span class="pre">package_specification</span></code>.</li>
</ol>
<ol class="arabic simple" id="tu-fe-initializes-aspects-02" start="2">
<li>The <code class="docutils literal"><span class="pre">name</span></code> of each <code class="docutils literal"><span class="pre">initialization_item</span></code> in the Initializes aspect
definition for a package shall denote a state abstraction of the package
or an entire object declared immediately within the visible part of the
package.
[For purposes of this rule, formal parameters of a generic package
are not considered to be &#8220;declared in the package&#8221;.]</li>
</ol>
<ol class="arabic simple" id="tu-fe-initializes-aspects-03" start="3">
<li>Each <code class="docutils literal"><span class="pre">name</span></code> in the <code class="docutils literal"><span class="pre">input_list</span></code> shall denote an object, or a state
abstraction but shall not denote an entity declared in the package with
the <code class="docutils literal"><span class="pre">aspect_specification</span></code> containing the Initializes aspect.</li>
</ol>
<ol class="arabic simple" id="tu-fe-initializes-aspects-04" start="4">
<li>Each entity in a single <code class="docutils literal"><span class="pre">input_list</span></code> shall be distinct.</li>
</ol>
<ol class="arabic simple" id="tu-fe-initializes-aspects-05" start="5">
<li>An <code class="docutils literal"><span class="pre">initialization_item</span></code> with a <strong>null</strong> <code class="docutils literal"><span class="pre">input_list</span></code> is
equivalent to the same <code class="docutils literal"><span class="pre">initialization_item</span></code> without an <code class="docutils literal"><span class="pre">input_list</span></code>.
[That is Initializes =&gt; (A =&gt; <strong>null</strong>) is equivalent to Initializes =&gt; A.]</li>
</ol>
<p class="centered" id="etu-initializes-aspects-lr">
<strong><strong>Static Semantics</strong></strong></p><ol class="arabic simple" id="tu-fe-initializes-aspects-06" start="6">
<li>The Initializes aspect of a package has visibility of the declarations
occurring immediately within the visible part of the package.</li>
</ol>
<ol class="arabic simple" id="tu-fa-initializes-aspects-07" start="7">
<li>The Initializes aspect of a package specification asserts which
state abstractions and visible variables of the package are initialized
by the elaboration of the package, both its specification and body, and
any units which have state abstractions or variable declarations that are
part (constituents) of a state abstraction declared by the package.
[A package with a <strong>null</strong> <code class="docutils literal"><span class="pre">initialization_list</span></code>, or no Initializes aspect
does not initialize any of its state abstractions or variables.]</li>
</ol>
<ol class="arabic simple" id="tu-fe-initializes-aspects-08" start="8">
<li>An <code class="docutils literal"><span class="pre">initialization_item</span></code> shall have an <code class="docutils literal"><span class="pre">input_list</span></code> if and
only if its initialization is dependent on visible variables and
state abstractions not declared within the package containing the
Initializes aspect.  Then the <code class="docutils literal"><span class="pre">names</span></code> in the <code class="docutils literal"><span class="pre">input_list</span></code> shall
denote variables and state abstractions which are used in
determining the initial value of the state abstraction or variable
denoted by the <code class="docutils literal"><span class="pre">name</span></code> of the <code class="docutils literal"><span class="pre">initialization_item</span></code> but are not
constituents of the state abstraction.</li>
</ol>
<p class="centered" id="etu-initializes-aspects-ss">
<strong><strong>Dynamic Semantics</strong></strong></p><p>There are no dynamic semantics associated with the Initializes aspect.</p>
<p class="centered">
<strong><strong>Verification Rules</strong></strong></p><ol class="arabic simple" id="tu-fa-initializes-aspects-9" start="9">
<li>If the Initializes aspect is specified for a package, then after
the body (which may be implicit if the package has no explicit
body) has completed its elaboration, every (entire) variable and
state abstraction denoted by a <code class="docutils literal"><span class="pre">name</span></code> in the Initializes aspect
shall be initialized. A state abstraction is said to be
initialized if all of its constituents are initialized. An entire
variable is initialized if all of its components are initialized.
Other parts of the visible state of the package shall not be
initialized.</li>
</ol>
<ol class="arabic simple" id="tu-fa-initializes-aspects-10" start="10">
<li>If an <code class="docutils literal"><span class="pre">initialization_item</span></code> has an <code class="docutils literal"><span class="pre">input_list</span></code> then the
variables and state abstractions denoted in the input list shall
be used in determining the initialized value of the entity denoted
by the <code class="docutils literal"><span class="pre">name</span></code> of the <code class="docutils literal"><span class="pre">initialization_item</span></code>.</li>
</ol>
<ol class="arabic simple" id="tu-fa-initializes-aspects-11" start="11">
<li>All variables and state abstractions which are not declared within
the package but are used in the initialization of an
<code class="docutils literal"><span class="pre">initialization_item</span></code> shall appear in an <code class="docutils literal"><span class="pre">input_list</span></code> of the
<code class="docutils literal"><span class="pre">initialization_item</span></code>.</li>
</ol>
<ol class="arabic simple" id="tu-fa-initializes-aspects-12" start="12">
<li>Any <code class="docutils literal"><span class="pre">initialization_item</span></code> that is a constant shall be a <em>constant
with variable input</em>. Any entity in an <code class="docutils literal"><span class="pre">input_list</span></code> that is a
constant shall be a parameter or <em>constant with variable input</em>.</li>
</ol>
<p id="tu-nt-initializes-aspects-note-1">[Note: these rules allow a variable or state abstraction to be
initialized by the elaboration of a package but not be denoted in an
Initializes aspect.  In such a case the analysis tools will treat the
variable or state abstraction as uninitialized when analyzing clients
of the package.]</p>
<p class="centered" id="etu-initializes-aspects-note">
<strong><strong>Examples</strong></strong></p><div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Q</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="p">,</span>        <span class="c">-- Declaration of abstract state name State</span>
       <span class="n">Initializes</span>    <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State</span><span class="p">,</span>       <span class="c">-- Indicates that State</span>
                          <span class="n">Visible_Var</span><span class="o">)</span> <span class="c">-- and Visible_Var will be initialized</span>
                                       <span class="c">-- during the elaboration of Q.</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">Visible_Var</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="o">...</span>
<span class="k">end </span><span class="nf">Q</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">Q</span><span class="p">;</span>
<span class="k">package </span><span class="nf">R</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="n">S1</span><span class="p">,</span>                   <span class="c">-- Declaration of abstract state name S1</span>
       <span class="n">Initializes</span>    <span class="o">=&gt;</span> <span class="o">(</span><span class="n">S1</span> <span class="o">=&gt;</span> <span class="n">Q.State</span><span class="p">,</span>       <span class="c">-- Indicates that S1 will be initialized</span>
                                               <span class="c">-- dependent on the value of Q.State</span>
                          <span class="n">X</span>  <span class="o">=&gt;</span> <span class="n">Q.Visible_Var</span><span class="o">)</span> <span class="c">-- and X dependent on Q.Visible_Var</span>
                                               <span class="c">-- during the elaboration of R.</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span> <span class="o">:=</span> <span class="n">Q.Visible_Var</span><span class="p">;</span>
   <span class="o">...</span>
<span class="k">end </span><span class="nf">R</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Y</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="o">(</span><span class="n">C</span> <span class="kr">with</span><span class="p"> </span><span class="n">External</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Async_Writers</span><span class="p">,</span> <span class="n">Effective_Reads</span><span class="o">)))</span><span class="p">,</span>
       <span class="c">--  Three abstract state names are declared A, B &amp; C</span>
       <span class="n">Initializes</span>    <span class="o">=&gt;</span> <span class="n">A</span>
       <span class="c">--  A is initialized during the elaboration of Y.</span>
       <span class="c">--  C is specified as external state with Async_Writers</span>
       <span class="c">--  and need not be explicitly initialized.</span>
       <span class="c">--  B is not initialized.</span>
<span class="kr">is</span><span class="p"></span>
   <span class="o">...</span>
<span class="k">end </span><span class="nf">Y</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Z</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="p">,</span>
       <span class="n">Initializes</span>    <span class="o">=&gt;</span> <span class="kr">null</span><span class="p"></span>
       <span class="c">--  Package Z has an abstract state name A declared but the</span>
       <span class="c">--  elaboration of Z and its private descendants do not</span>
       <span class="c">--  perform any initialization during elaboration.</span>
<span class="kr">is</span><span class="p"></span>
   <span class="o">...</span>
<span class="k">end </span><span class="nf">Z</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="initial-condition-aspects">
<span id="initial-condition-aspect"></span><h3>7.1.6. Initial_Condition Aspects<a class="headerlink" href="#initial-condition-aspects" title="Permalink to this headline">¶</a></h3>
<p>The Initial_Condition aspect is introduced by an <code class="docutils literal"><span class="pre">aspect_specification</span></code> where
the <code class="docutils literal"><span class="pre">aspect_mark</span></code> is Initial_Condition and the <code class="docutils literal"><span class="pre">aspect_definition</span></code> shall
be a <em>Boolean_</em><code class="docutils literal"><span class="pre">expression</span></code>.</p>
<p class="centered">
<strong><strong>Legality Rules</strong></strong></p><ol class="arabic simple" id="tu-fe-initial-condition-aspects-01">
<li>An Initial_Condition aspect shall only be placed in an <code class="docutils literal"><span class="pre">aspect_specification</span></code>
of a <code class="docutils literal"><span class="pre">package_specification</span></code>.</li>
</ol>
<p class="centered" id="etu-initial-condition-aspects-lr">
<strong><strong>Static Semantics</strong></strong></p><ol class="arabic simple" id="tu-fe-pf-initial-condition-aspects-02" start="2">
<li>An Initial_Condition aspect is an assertion and behaves as a
postcondition for the elaboration of both the specification and
body of a package. If present on a package, then its assertion
expression defines properties (a predicate) of the state of the
package which can be assumed to be true immediately following the
elaboration of the package. [The expression of the
Initial_Condition cannot denote a state abstraction or hidden
state. This means that to express properties of hidden state,
functions declared in the visible part acting on the state
abstractions of the package must be used.]</li>
</ol>
<p class="centered" id="etu-initial-condition-aspects-ss">
<strong><strong>Dynamic Semantics</strong></strong></p><ol class="arabic simple" id="tu-pr-fa-initial-condition-aspects-03" start="3">
<li>With respect to dynamic semantics, specifying a given expression as
the Initial_Condition aspect of a package is equivalent to
specifying that expression as the argument of an Assert pragma
occurring at the end of the (possibly implicit) statement list of
the (possibly implicit) body of the package. [This equivalence
includes all interactions with pragma Assertion_Policy but does not
extend to matters of static semantics, such as name resolution.] An
Initial_Condition expression does not cause freezing until the
point where it is evaluated [, at which point everything that it
might freeze has already been frozen].</li>
</ol>
<p class="centered" id="etu-initial-condition-aspects-ds">
<strong><strong>Verification Rules</strong></strong></p><ol class="arabic simple" id="tu-pr-initial-condition-aspects-04" start="4">
<li>[The Initial_Condition aspect gives a verification condition to show that the
implementation of the <code class="docutils literal"><span class="pre">package_specification</span></code> and its body satisfy the
predicate given in the Initial_Condition aspect.]</li>
</ol>
<ol class="arabic simple" id="tu-fe-initial-condition-aspects-05" start="5">
<li>Each variable or indirectly referenced state abstraction in an
Initial_Condition aspect of a package Q which is declared
immediately within the visible part of Q shall be initialized
during the elaboration of Q and be denoted by a <code class="docutils literal"><span class="pre">name</span></code> of an
<code class="docutils literal"><span class="pre">initialization_item</span></code> of the Initializes aspect of Q.</li>
</ol>
<p class="centered" id="etu-initial-condition-aspects-vr">
<strong><strong>Examples</strong></strong></p><div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span> <span class="k">package </span><span class="nf">Q</span>
    <span class="kr">with</span><span class="p"> </span><span class="n">Abstract_State</span>    <span class="o">=&gt;</span> <span class="n">State</span><span class="p">,</span>    <span class="c">-- Declaration of abstract state name State</span>
         <span class="n">Initializes</span>       <span class="o">=&gt;</span> <span class="n">State</span><span class="p">,</span>    <span class="c">-- State will be initialized during elaboration</span>
         <span class="n">Initial_Condition</span> <span class="o">=&gt;</span> <span class="n">Is_Ready</span>  <span class="c">-- Predicate stating the logical state after</span>
                                        <span class="c">-- initialization.</span>
 <span class="kr">is</span><span class="p"></span>
    <span class="k">function </span><span class="nf">Is_Ready</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span>
       <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="p">;</span>
 <span class="k">end </span><span class="nf">Q</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span></span> <span class="k">package </span><span class="nf">X</span>
    <span class="kr">with</span><span class="p"> </span><span class="n">Abstract_State</span>    <span class="o">=&gt;</span> <span class="n">A</span><span class="p">,</span>      <span class="c">-- Declares an abstract state named A</span>
         <span class="n">Initializes</span>       <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="o">)</span><span class="p">,</span> <span class="c">-- A and visible variable B are initialized</span>
                                      <span class="c">-- during package initialization.</span>
         <span class="n">Initial_Condition</span> <span class="o">=&gt;</span> <span class="n">A_Is_Ready</span> <span class="kr">and</span><span class="p"> </span><span class="n">B</span> <span class="o">=</span> <span class="mi">0</span>
                                      <span class="c">-- The logical conditions that hold</span>
                                      <span class="c">-- after package elaboration.</span>
 <span class="kr">is</span><span class="p"></span>
    <span class="o">...</span>
    <span class="n">B</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>

    <span class="k">function </span><span class="nf">A_Is_Ready</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span>
       <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="p">;</span>
 <span class="k">end </span><span class="nf">X</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
</div>
<div class="section" id="package-bodies">
<h2>7.2. Package Bodies<a class="headerlink" href="#package-bodies" title="Permalink to this headline">¶</a></h2>
<div class="section" id="state-refinement">
<span id="id3"></span><h3>7.2.1. State Refinement<a class="headerlink" href="#state-refinement" title="Permalink to this headline">¶</a></h3>
<p>A <code class="docutils literal"><span class="pre">state_name</span></code> declared by an Abstract_State aspect in the specification of a
package shall denote an abstraction representing all or part of its hidden
state. The declaration must be completed in the package body by a Refined_State
aspect. The Refined_State aspect defines a <em>refinement</em> for each <code class="docutils literal"><span class="pre">state_name</span></code>.
The refinement shall denote the variables and subordinate state abstractions
represented by the <code class="docutils literal"><span class="pre">state_name</span></code> and these are known as its <em>constituents</em>.</p>
<p>Constituents of each <code class="docutils literal"><span class="pre">state_name</span></code> have to be initialized
consistently with that of their representative <code class="docutils literal"><span class="pre">state_name</span></code> as
determined by its denotation in the Initializes aspect of the package.</p>
<p>A subprogram may have an <em>abstract view</em> and a <em>refined view</em>. The
abstract view is a subprogram declaration in a package specification
of a package where a subprogram may refer to private types and
state abstractions whose details are not visible. A refined view of a
subprogram is the body or body stub of the subprogram in the package
body whose specification declares its abstract view.</p>
<p>In a refined view a subprogram has visibility of the full type declarations of
any private types declared by the enclosing package and visibility of the
refinements of state abstractions declared by the package. Refined versions of
aspects are provided to express the contracts of a refined view of a subprogram.</p>
</div>
<div class="section" id="refined-state-aspects">
<span id="refined-state-aspect"></span><h3>7.2.2. Refined_State Aspects<a class="headerlink" href="#refined-state-aspects" title="Permalink to this headline">¶</a></h3>
<p>The Refined_State aspect is introduced by an <code class="docutils literal"><span class="pre">aspect_specification</span></code> where the
<code class="docutils literal"><span class="pre">aspect_mark</span></code> is Refined_State and the <code class="docutils literal"><span class="pre">aspect_definition</span></code> shall follow
the grammar of <code class="docutils literal"><span class="pre">refinement_list</span></code> given below.</p>
<p class="centered">
<strong><strong>Syntax</strong></strong></p><div class="highlight-default" id="tu-fe-refined-state-aspects-syntax"><div class="highlight"><pre><span></span><span class="n">refinement_list</span>   <span class="p">::</span><span class="o">=</span> <span class="p">(</span> <span class="n">refinement_clause</span> <span class="p">{</span> <span class="p">,</span> <span class="n">refinement_clause</span> <span class="p">}</span> <span class="p">)</span>
<span class="n">refinement_clause</span> <span class="p">::</span><span class="o">=</span> <span class="n">state_name</span> <span class="o">=&gt;</span> <span class="n">constituent_list</span>
<span class="n">constituent_list</span>  <span class="p">::</span><span class="o">=</span> <span class="n">null</span>
                    <span class="o">|</span> <span class="n">constituent</span>
                    <span class="o">|</span> <span class="p">(</span> <span class="n">constituent</span> <span class="p">{</span> <span class="p">,</span> <span class="n">constituent</span> <span class="p">}</span> <span class="p">)</span>
</pre></div>
</div>
<p>where</p>
<blockquote>
<div><code class="docutils literal"><span class="pre">constituent</span> <span class="pre">::=</span></code> <em>object_</em><code class="docutils literal"><span class="pre">name</span> <span class="pre">|</span> <span class="pre">state_name</span></code></div></blockquote>
<p class="centered" id="etu-refined-state-aspects-syntax">
<strong><strong>Name Resolution Rules</strong></strong></p><ol class="arabic simple" id="tu-fe-refined-state-aspects-01">
<li>A Refined_State aspect of a <code class="docutils literal"><span class="pre">package_body</span></code> has visibility extended to the
<code class="docutils literal"><span class="pre">declarative_part</span></code> of the body.</li>
</ol>
<p class="centered" id="etu-refined-state-aspects-nr">
<strong><strong>Legality Rules</strong></strong></p><ol class="arabic simple" id="tu-fe-refined-state-aspects-02" start="2">
<li>A Refined_State aspect shall only appear in the <code class="docutils literal"><span class="pre">aspect_specification</span></code> of a
<code class="docutils literal"><span class="pre">package_body</span></code>. [The use of <code class="docutils literal"><span class="pre">package_body</span></code> rather than package body
allows this aspect to be specified for generic package bodies.]</li>
</ol>
<ol class="arabic simple" id="tu-fe-refined-state-aspects-03" start="3">
<li>If a <code class="docutils literal"><span class="pre">package_specification</span></code> has a non-null Abstract_State aspect its body
shall have a Refined_State aspect.</li>
</ol>
<ol class="arabic simple" id="tu-fe-refined-state-aspects-04" start="4">
<li>If a <code class="docutils literal"><span class="pre">package_specification</span></code> does not have an Abstract_State aspect,
then the corresponding <code class="docutils literal"><span class="pre">package_body</span></code> shall not have a Refined_State
aspect.</li>
</ol>
<ol class="arabic simple" id="tu-fe-refined-state-aspects-05" start="5">
<li>Each <code class="docutils literal"><span class="pre">constituent</span></code> shall be either a variable, a constant, or a state
abstraction.</li>
</ol>
<ol class="arabic simple" id="tu-fe-refined-state-aspects-06" start="6">
<li>An object which is a <code class="docutils literal"><span class="pre">constituent</span></code> shall be an entire object.</li>
</ol>
<ol class="arabic simple" id="tu-fe-refined-state-aspects-07" start="7">
<li>A <code class="docutils literal"><span class="pre">constituent</span></code> of a state abstraction of a package shall denote
either an entity with no Part_Of <code class="docutils literal"><span class="pre">option</span></code> or aspect which is part
of the hidden state of the package, or an entity whose declaration
has a Part_Of <code class="docutils literal"><span class="pre">option</span></code> or aspect which denotes this state
abstraction (see <a class="reference internal" href="#package-hierarchy"><span class="std std-ref">Abstract_State, Package Hierarchy and Part_Of</span></a>).</li>
</ol>
<ol class="arabic simple" id="tu-fe-refined-state-aspects-08" start="8">
<li>Each <em>abstract_</em><code class="docutils literal"><span class="pre">state_name</span></code> declared in the package
specification shall be denoted exactly once as the <code class="docutils literal"><span class="pre">state_name</span></code>
of a <code class="docutils literal"><span class="pre">refinement_clause</span></code> in the Refined_State aspect of the body
of the package.</li>
</ol>
<ol class="arabic simple" id="tu-fe-refined-state-aspects-09" start="9">
<li>Every entity of the hidden state of a package shall be denoted as a
<code class="docutils literal"><span class="pre">constituent</span></code> of exactly one <em>abstract_</em><code class="docutils literal"><span class="pre">state_name</span></code> in the
Refined_State aspect of the package and shall not be denoted more than
once. [These <code class="docutils literal"><span class="pre">constituents</span></code> shall be either objects declared in the
private part or body of the package, or the declarations from the
visible part of nested packages declared immediately therein.]</li>
</ol>
<ol class="arabic simple" id="tu-cbatu-refined-state-aspects-10" start="10">
<li>In a package body where the refinement of a state abstraction is
visible the <code class="docutils literal"><span class="pre">constituents</span></code> of the state abstraction must be
denoted in aspect specifications rather than the state
abstraction.</li>
</ol>
<ol class="arabic simple" id="tu-cbatu-refined-state-aspects-11" start="11">
<li>The legality rules related to a Refined_State aspect given in
<a class="reference internal" href="#package-hierarchy"><span class="std std-ref">Abstract_State, Package Hierarchy and Part_Of</span></a> also apply.</li>
</ol>
<ol class="arabic simple" id="tu-cbatu-refined-state-aspects-12" start="12">
<li>Each <code class="docutils literal"><span class="pre">constituent</span></code> of a ghost state abstraction shall be either
a ghost variable or a ghost state abstraction. [The reverse situation
(i.e., a ghost constituent of a non-ghost state abstraction) is permitted.]</li>
</ol>
<ol class="arabic simple" id="tu-fe-refined-state-aspects-13" start="13">
<li>A <code class="docutils literal"><span class="pre">constituent</span></code> of a synchronized state abstraction shall be
either a synchronized object or another synchronized state abstraction.
A <code class="docutils literal"><span class="pre">constituent</span></code> of a state abstraction which is neither external
nor synchronized shall be not be an effectively volatile object,
a synchronized state abstraction, or an external state abstraction.</li>
</ol>
<p class="centered" id="etu-refined-state-aspects-lr">
<strong><strong>Static Semantics</strong></strong></p><ol class="arabic simple" id="tu-fe-refined-state-aspects-14" start="14">
<li>A Refined_State aspect of a <code class="docutils literal"><span class="pre">package_body</span></code> completes the
declaration of the state abstractions occurring in the
corresponding <code class="docutils literal"><span class="pre">package_specification</span></code> and defines the objects
and each subordinate state abstraction that are the
<code class="docutils literal"><span class="pre">constituents</span></code> of the <em>abstract_</em><code class="docutils literal"><span class="pre">state_names</span></code> declared in
the <code class="docutils literal"><span class="pre">package_specification</span></code>.</li>
</ol>
<ol class="arabic simple" id="tu-fe-refined-state-aspects-15" start="15">
<li>A <strong>null</strong> <code class="docutils literal"><span class="pre">constituent_list</span></code> indicates that the named abstract
state has no constituents and termed a <em>null_refinement</em>. The
state abstraction does not represent any actual state at
all. [This feature may be useful to minimize changes to Global and
Depends aspects if it is believed that a package may have some
extra state in the future, or if hidden state is removed.]</li>
</ol>
<p class="centered" id="etu-refined-state-aspects-ss">
<strong><strong>Dynamic Semantics</strong></strong></p><p>There are no dynamic semantics associated with Refined_State aspect.</p>
<p class="centered">
<strong><strong>Verification Rules</strong></strong></p><ol class="arabic simple" id="tu-fe-refined-state-aspects-16" start="16">
<li>Each <code class="docutils literal"><span class="pre">constituent</span></code> that is a constant shall be a constant <em>with
variable inputs</em>.</li>
</ol>
<ol class="arabic simple" id="tu-fe-refined-state-aspects-17" start="17">
<li>If the Async_Writers aspect of a state abstraction is True and the
Async_Writers aspect of a constituent of that state abstraction is
False, then after the elaboration of the (possibly implicit) body
of the package which declares the abstraction, the constituent
shall be initialized.</li>
</ol>
<p class="centered" id="etu-refined-state-aspects-vr">
<strong><strong>Examples</strong></strong></p><div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">-- Here, we present a package Q that declares two abstract states:</span>
<span class="k">package </span><span class="nf">Q</span>
   <span class="kr">with</span><span class="p"> </span><span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="o">)</span><span class="p">,</span>
        <span class="n">Initializes</span>    <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="o">...</span>
<span class="k">end </span><span class="nf">Q</span><span class="p">;</span>

<span class="c">-- The package body refines</span>
<span class="c">--   A onto three concrete variables declared in the package body</span>
<span class="c">--   B onto the abstract state of a nested package</span>
<span class="k">package body </span><span class="nf">Q</span>
   <span class="kr">with</span><span class="p"> </span><span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">F</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">H</span><span class="o">)</span><span class="p">,</span>
                          <span class="n">B</span> <span class="o">=&gt;</span> <span class="n">R.State</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">F</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">H</span> <span class="o">:</span> <span class="n">Integer</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="c">-- all initialized as required</span>

   <span class="k">package </span><span class="nf">R</span>
      <span class="kr">with</span><span class="p"> </span><span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="p">,</span>
           <span class="n">Initializes</span>    <span class="o">=&gt;</span> <span class="n">State</span> <span class="c">-- initialized as required</span>
   <span class="kr">is</span><span class="p"></span>
      <span class="o">...</span>
   <span class="k">end </span><span class="nf">R</span><span class="p">;</span>

   <span class="o">...</span>
<span class="k">end </span><span class="nf">Q</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="initialization-issues">
<h3>7.2.3. Initialization Issues<a class="headerlink" href="#initialization-issues" title="Permalink to this headline">¶</a></h3>
<p>Every state abstraction specified as being initialized in the Initializes
aspect of a package has to have all of its constituents initialized. This
may be achieved by initialization within the package, by assumed
pre-initialization (in the case of external state) or, for constituents
which reside in another package, initialization by their declaring package.</p>
<p class="centered">
<strong><strong>Verification Rules</strong></strong></p><ol class="arabic simple" id="tu-fa-initialization-issues-01">
<li>For each state abstraction denoted by the <code class="docutils literal"><span class="pre">name</span></code> of an
<code class="docutils literal"><span class="pre">initialization_item</span></code> of an Initializes aspect of a package, all the
<code class="docutils literal"><span class="pre">constituents</span></code> of the state abstraction must be initialized by:<ul>
<li>initialization within the package; or</li>
<li>assumed pre-initialization (in the case of external states); or</li>
<li>for constituents which reside in another unit [and have a Part_Of
indicator associated with their declaration (see
<a class="reference internal" href="#package-hierarchy"><span class="std std-ref">Abstract_State, Package Hierarchy and Part_Of</span></a>)] by their declaring package. [It follows
that such constituents will appear in the initialization clause
of the declaring unit unless they are external states.]</li>
</ul>
</li>
</ol>
</div>
<div class="section" id="refined-global-aspects">
<span id="refined-global-aspect"></span><span id="etu-initialization-issues"></span><h3>7.2.4. Refined_Global Aspects<a class="headerlink" href="#refined-global-aspects" title="Permalink to this headline">¶</a></h3>
<p>A subprogram declared in the specification of a package may
have a Refined_Global aspect applied to its body or body stub. A
Refined_Global aspect of a subprogram defines a <em>refinement</em> of the
Global Aspect of the subprogram; that is, the Refined_Global aspect
repeats the Global aspect of the subprogram except that references to
state abstractions whose refinements are visible at the point of the
subprogram_body are replaced with references to [some or all of the]
constituents of those abstractions. References to a state abstraction
whose refinement is not visible at the point of the subprogram_body
may also be similarly replaced if Part_Of aspect specifications
which are visible at the point of the subprogram body
identify one or more constituents of the abstraction; such a state
abstraction is said to be &#8220;optionally refinable&#8221; at the point of the
subprogram body.</p>
<p>See section <a class="reference internal" href="subprograms.html#global-aspects"><span class="std std-ref">Global Aspects</span></a> regarding how the rules given in this
section apply to protected operations and to task bodies.</p>
<p>The Refined_Global aspect is introduced by an <code class="docutils literal"><span class="pre">aspect_specification</span></code> where
the <code class="docutils literal"><span class="pre">aspect_mark</span></code> is Refined_Global and the <code class="docutils literal"><span class="pre">aspect_definition</span></code>
shall follow the grammar of <code class="docutils literal"><span class="pre">global_specification</span></code> in <a class="reference internal" href="subprograms.html#global-aspects"><span class="std std-ref">Global Aspects</span></a>.</p>
<p class="centered">
<strong><strong>Static Semantics</strong></strong></p><ol class="arabic simple">
<li>The static semantics are as for those of the Global aspect given in
<a class="reference internal" href="subprograms.html#global-aspects"><span class="std std-ref">Global Aspects</span></a>. [Differences between these two aspects for one
subprogram stem from differences in state abstraction visibility
between the points where the two aspects are specified.]</li>
</ol>
<p class="centered">
<strong><strong>Legality Rules</strong></strong></p><ol class="arabic simple" id="tu-fe-refined-global-aspects-02" start="2">
<li>A Refined_Global aspect is permitted on a body_stub (if one is
present), subprogram body, entry body, or task body if and only if
the stub or body is the completion of a declaration occurring in the
specification of an enclosing package, the declaration has a
Global aspect which denotes a state abstraction declared by the package and
either the refinement of the state abstraction is visible or a Part_Of
specification specifying a constituent of the state abstraction is visible.</li>
</ol>
<ol class="arabic simple" id="tu-fe-refined-global-aspects-03" start="3">
<li>A Refined_Global aspect specification shall <em>refine</em> the subprogram&#8217;s
Global aspect as follows:<ol class="loweralpha">
<li>For each <code class="docutils literal"><span class="pre">global_item</span></code> in the Global aspect which denotes a
state abstraction whose non-<strong>null</strong> refinement is visible at
the point of the Refined_Global aspect specification, the
Refined_Global specification shall include one or more
<code class="docutils literal"><span class="pre">global_items</span></code> which denote <code class="docutils literal"><span class="pre">constituents</span></code> of that state
abstraction.</li>
<li>For each <code class="docutils literal"><span class="pre">global_item</span></code> in the Global aspect which denotes a
state abstraction whose <strong>null</strong> refinement is visible at the
point of the Refined_Global aspect specification, there are no
corresponding <code class="docutils literal"><span class="pre">global_items</span></code> in the Refined_Global specification.
If this results in a Refined_Global specification with no
<code class="docutils literal"><span class="pre">global_items</span></code>, then the Refined_Global specification shall
include a <code class="docutils literal"><span class="pre">null_global_specification</span></code>.</li>
<li>For each <code class="docutils literal"><span class="pre">global_item</span></code> in the Global aspect which does not
denote a state abstraction whose refinement is visible and
does not denote an optionally refinable state abstraction, the
Refined_Global specification shall include exactly one
<code class="docutils literal"><span class="pre">global_item</span></code> which denotes the same entity as the
<code class="docutils literal"><span class="pre">global_item</span></code> in the Global aspect.</li>
<li>For each <code class="docutils literal"><span class="pre">global_item</span></code> in the Global aspect which designates
a state abstraction which is optionally refinable, refinement
of the abstraction is optional in the following sense: either the
reference to the state abstraction may be replaced with references
to its constituents (following the rules of case &#8216;a&#8217; above) or
not (in which case the rules of case &#8216;c&#8217; above apply). However,
only the latter option is available if the mode of the state
abstraction in the Global specification is Output.</li>
<li>No other <code class="docutils literal"><span class="pre">global_items</span></code> shall be included in the Refined_Global
aspect specification.</li>
<li>At least one state abstraction mentioned in the Global aspect
specification shall be unmentioned in the Refined_Global
aspect specification. [This usually follows as a consequence of
other rules, but not in some cases involving optionally refinable
state abstractions where the option is declined.]</li>
</ol>
</li>
</ol>
<ol class="arabic simple" id="tu-fe-refined-global-aspects-04" start="4">
<li><code class="docutils literal"><span class="pre">Global_items</span></code> in a Refined_Global <code class="docutils literal"><span class="pre">aspect_specification</span></code> shall denote
distinct entities.</li>
</ol>
<ol class="arabic" id="tu-fe-refined-global-aspects-05" start="5">
<li><p class="first">The mode of each <code class="docutils literal"><span class="pre">global_item</span></code> in a Refined_Global aspect shall match
that of the corresponding <code class="docutils literal"><span class="pre">global_item</span></code> in the Global aspect unless
that corresponding <code class="docutils literal"><span class="pre">global_item</span></code> denotes a state abstraction which
is not mentioned in the Refined_Global aspect. In that case, the modes
of the <code class="docutils literal"><span class="pre">global_items</span></code> in the Refined_Global aspect which denote (direct
or indirect) constituents of that state abstraction collectively determine
(as described below) an &#8220;effective mode&#8221; for the abstraction. If there is
at least one such constituent, then that &#8220;effective mode&#8221; shall match that
of the corresponding <code class="docutils literal"><span class="pre">global_item</span></code>
in the Global aspect; it is determined as follows:</p>
<ol class="loweralpha simple">
<li>If the refinement of the abstraction is visible and every constituent
of the abstraction is mentioned in the Refined_Global aspect with a mode
of Output, then the effective mode is Output;</li>
<li>Otherwise, if at least one constituent of the abstraction is mentioned
in the Refined_Global aspect with a mode of Output or In_Out, then
the effective mode is In_Out;</li>
<li>Otherwise, if at least one constituent of the abstraction is mentioned
in the Refined_Global aspect with a mode of Input, then the effective
mode is Input;</li>
<li>Otherwise, the effective mode is Proof_In.</li>
</ol>
<p>[If there is no such consituent (e.g., because a <em>null</em> refinement is
visible) then the mode of the state abstraction in the Global aspect
plays no role in determining the legality of the Refined_Global aspect.]</p>
</li>
</ol>
<ol class="arabic simple" id="tu-cbatu-refined-global-aspects-06" start="6">
<li>The legality rules for <a class="reference internal" href="subprograms.html#global-aspects"><span class="std std-ref">Global Aspects</span></a> and External states described in
<a class="reference internal" href="#refined-external-states"><span class="std std-ref">Refined External States</span></a> also apply.</li>
</ol>
<p class="centered" id="etu-refined-global-aspects-lr">
<strong><strong>Dynamic Semantics</strong></strong></p><p>There are no dynamic semantics associated with a Refined_Global aspect.</p>
<p class="centered">
<strong><strong>Verification Rules</strong></strong></p><ol class="arabic simple" id="tu-fa-refined-global-aspects-08" start="8">
<li>If a subprogram has a Refined_Global aspect it is used in the analysis of the
subprogram body rather than its Global aspect.</li>
</ol>
<ol class="arabic simple" id="tu-cbatu-refined-global-aspects-09" start="9">
<li>The verification rules given for <a class="reference internal" href="subprograms.html#global-aspects"><span class="std std-ref">Global Aspects</span></a> also apply.</li>
</ol>
<p class="centered" id="etu-refined-global-aspects-vr">
<strong><strong>Examples</strong></strong></p><div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Refined_Global_Examples</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">S1</span><span class="p">,</span> <span class="n">S2</span><span class="o">)</span><span class="p">,</span>
       <span class="n">Initializes</span>    <span class="o">=&gt;</span> <span class="o">(</span><span class="n">S1</span><span class="p">,</span> <span class="n">V1</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">V1</span> <span class="o">:</span> <span class="n">Integer</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c">--  Visible state variables</span>

   <span class="k">procedure </span><span class="nf">P1_1</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">S1</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">P1_2</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">S1</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">P1_3</span> <span class="o">(</span><span class="n">Result</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span> <span class="o">=&gt;</span> <span class="n">S1</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">P1_4</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">S1</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">P2</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span>  <span class="o">=&gt;</span> <span class="n">V1</span><span class="p">,</span>
                     <span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">S2</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">P3</span> <span class="o">(</span><span class="n">J</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">V1</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">P4</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">S1</span><span class="p">,</span> <span class="n">V1</span><span class="o">)</span><span class="p">,</span>
                     <span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">S2</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Refined_Global_Examples</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Refined_Global_Examples</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">S1</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="o">)</span><span class="p">,</span>
                         <span class="n">S2</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="o">))</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">A</span> <span class="o">:</span> <span class="n">Integer</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c">--  The constituents of S1</span>
   <span class="n">B</span> <span class="o">:</span> <span class="n">Integer</span> <span class="o">:=</span> <span class="mi">2</span><span class="p">;</span>  <span class="c">--  Initialized as promised</span>

   <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span> <span class="c">--  The constituents of S2</span>
                      <span class="c">--  Not initialized</span>

   <span class="k">procedure </span><span class="nf">P1_1</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="p">,</span>  <span class="c">--  Refined onto constituents of S1</span>
                             <span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span>  <span class="c">--  B is Output but A is In_Out and</span>
                                           <span class="c">--  so Global S1 is also In_Out</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">B</span> <span class="o">:=</span> <span class="n">A</span><span class="p">;</span>
      <span class="n">A</span> <span class="o">:=</span> <span class="n">I</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">P1_1</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">P1_2</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span>  <span class="c">--  Not all of the constituents of</span>
                                           <span class="c">--  S1 are updated and so the Global</span>
                                           <span class="c">--  S1 must In_Out</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">A</span> <span class="o">:=</span> <span class="n">I</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">P1_2</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">P1_3</span> <span class="o">(</span><span class="n">Result</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span>  <span class="c">--  Not all of the constituents of S1</span>
                                          <span class="c">--  are read but none of them are</span>
                                          <span class="c">--  updated so the Global S1 is Input</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Result</span> <span class="o">:=</span> <span class="n">B</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">P1_3</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">P1_4</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="o">))</span>  <span class="c">--  The constituents of S1 are</span>
                                                <span class="c">--  not read but they are all</span>
                                                <span class="c">--  updated and so the mode</span>
                                                <span class="c">--  selector of S1 is Output</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">A</span> <span class="o">:=</span> <span class="n">I</span><span class="p">;</span>
      <span class="n">B</span> <span class="o">:=</span> <span class="n">A</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">P1_4</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">P2</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span>  <span class="o">=&gt;</span> <span class="n">V1</span><span class="p">,</span> <span class="c">--  V1 has no constituents and is</span>
                                           <span class="c">--  not subject to refinement.</span>
                             <span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">)</span>  <span class="c">--  Only constituent Z of S2 is</span>
                                           <span class="c">--  updated and so mode selector of</span>
                                           <span class="c">--  Global S2 is In_Out.</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Z</span> <span class="o">:=</span> <span class="n">V1</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">P2</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">P3</span> <span class="o">(</span><span class="n">J</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="c">--  No Refined_Global aspect here because V1 has no refinement.</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">V1</span> <span class="o">:=</span> <span class="n">J</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">P3</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">P4</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A</span><span class="p">,</span> <span class="n">V1</span><span class="o">)</span><span class="p">,</span> <span class="c">--  The refinment of both S1</span>
                                                <span class="c">--  and S2 are visible and</span>
                             <span class="n">Output</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="o">))</span>  <span class="c">--  cannot be denoted here.</span>
                                                <span class="c">--  Their constituents must be</span>
                                                <span class="c">--  used instead.</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">X</span> <span class="o">:=</span> <span class="n">V1</span><span class="p">;</span>
      <span class="n">Y</span> <span class="o">:=</span> <span class="n">A</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">P4</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Refined_Global_Examples</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="refined-depends-aspects">
<span id="refined-depends-aspect"></span><h3>7.2.5. Refined_Depends Aspects<a class="headerlink" href="#refined-depends-aspects" title="Permalink to this headline">¶</a></h3>
<p>A subprogram declared in the specification of a package may have a Refined_Depends
aspect applied to its body or body stub. A Refined_Depends aspect of a
subprogram defines a <em>refinement</em> of the Depends aspect of the subprogram; that
is, the Refined_Depends aspect repeats the Depends aspect of the subprogram
except that references to state abstractions, whose refinements are visible at
the point of the subprogram_body, are replaced with references to [some or all of
the] constituents of those abstractions.</p>
<p>See section <a class="reference internal" href="subprograms.html#global-aspects"><span class="std std-ref">Global Aspects</span></a> regarding how the rules given in this
section apply to protected operations and to task bodies.</p>
<p>The Refined_Depends aspect is introduced by an <code class="docutils literal"><span class="pre">aspect_specification</span></code> where
the <code class="docutils literal"><span class="pre">aspect_mark</span></code> is Refined_Depends and the <code class="docutils literal"><span class="pre">aspect_definition</span></code>
shall follow the grammar of <code class="docutils literal"><span class="pre">dependency_relation</span></code> in <a class="reference internal" href="subprograms.html#depends-aspects"><span class="std std-ref">Depends Aspects</span></a>.</p>
<p class="centered">
<strong><strong>Static Semantics</strong></strong></p><ol class="arabic simple">
<li>The static semantics are as for those of the Depends aspect given in
<a class="reference internal" href="subprograms.html#depends-aspects"><span class="std std-ref">Depends Aspects</span></a>. [Differences between these two aspects for one
subprogram stem from differences in state abstraction visibility
between the points where the two aspects are specified.]</li>
</ol>
<p class="centered">
<strong><strong>Legality Rules</strong></strong></p><ol class="arabic simple" id="tu-fe-refined-depends-aspects-02" start="2">
<li>A Refined_Depends aspect is permitted on a body_stub (if one is
present), subprogram body, entry body, or task body if and only if
the stub or body is the completion of a declaration in the
specification of an enclosing package and the declaration has a
Depends aspect which denotes a state abstraction declared by the package and
the refinement of the state abstraction is visible.</li>
</ol>
<ol class="arabic simple" id="tu-fe-refined-depends-aspects-03" start="3">
<li>A Refined_Depends aspect specification is, in effect, a copy of the
corresponding Depends aspect specification except that any
references in the Depends aspect to a state abstraction, whose
refinement is visible at the point of the Refined_Depends
specification, are replaced with references to zero or more direct
or indirect constituents of that state abstraction. A
Refined_Depends aspect shall have a <code class="docutils literal"><span class="pre">dependency_relation</span></code> which
is derivable from the original given in the Depends aspect as
follows:<ol class="loweralpha">
<li>A <em>partially refined dependency relation</em> is created by first
copying, from the Depends aspect, each <code class="docutils literal"><span class="pre">output</span></code> that is not
state abstraction whose refinement is visible at the point of
the Refined_Depends aspect, along with its <code class="docutils literal"><span class="pre">input_list</span></code>, to
the partially refined dependency relation as an <code class="docutils literal"><span class="pre">output</span></code>
denoting the same entity with an <code class="docutils literal"><span class="pre">input_list</span></code> denoting the
same entities as the original. [The order of the <code class="docutils literal"><span class="pre">outputs</span></code> and
the order of <code class="docutils literal"><span class="pre">inputs</span></code> within the <code class="docutils literal"><span class="pre">input_list</span></code> is
insignificant.]</li>
<li>The partially refined dependency relation is then extended by
replacing each <code class="docutils literal"><span class="pre">output</span></code> in the Depends aspect that is a state
abstraction, whose refinement is visible at the point of the
Refined_Depends, by zero or more <code class="docutils literal"><span class="pre">outputs</span></code> in the partially
refined dependency relation. It shall be zero only for a
<strong>null</strong> refinement, otherwise all of the <code class="docutils literal"><span class="pre">outputs</span></code> shall
denote a <code class="docutils literal"><span class="pre">constituent</span></code> of the state abstraction.</li>
<li>If the <code class="docutils literal"><span class="pre">output</span></code> in the Depends aspect denotes a state
abstraction which is not also an <code class="docutils literal"><span class="pre">input</span></code>, then each
<code class="docutils literal"><span class="pre">constituent</span></code> of the state abstraction shall be denoted as an
<code class="docutils literal"><span class="pre">output</span></code> of the partially refined dependency relation.</li>
<li>These rules may, for each <code class="docutils literal"><span class="pre">output</span></code> in the Depends aspect,
introduce more than one <code class="docutils literal"><span class="pre">output</span></code> in the partially refined
dependency relation. Each of these <code class="docutils literal"><span class="pre">outputs</span></code> has an
<code class="docutils literal"><span class="pre">input_list</span></code> that has zero or more of the <code class="docutils literal"><span class="pre">inputs</span></code> from the
<code class="docutils literal"><span class="pre">input_list</span></code> of the original <code class="docutils literal"><span class="pre">output</span></code>.  The union of these
<code class="docutils literal"><span class="pre">inputs</span></code> and the original state abstraction, if it is an
<code class="docutils literal"><span class="pre">input</span></code> in the <code class="docutils literal"><span class="pre">input_list</span></code>, shall denote the same <code class="docutils literal"><span class="pre">inputs</span></code>
that appear in the <code class="docutils literal"><span class="pre">input_list</span></code> of the original <code class="docutils literal"><span class="pre">output</span></code>.</li>
<li>If the Depends aspect has a <code class="docutils literal"><span class="pre">null_dependency_clause</span></code>, then the
partially refined dependency relation has a
<code class="docutils literal"><span class="pre">null_dependency_clause</span></code> added with an <code class="docutils literal"><span class="pre">input_list</span></code> denoting
the same <code class="docutils literal"><span class="pre">inputs</span></code> as the original.</li>
<li>The partially refined dependency relation is completed by
replacing each <code class="docutils literal"><span class="pre">input</span></code> which is a state abstraction, whose
refinement is visible at the point of the Refined_Depends
aspect, by zero or more <code class="docutils literal"><span class="pre">inputs</span></code> which are its
constituents.</li>
<li>If a state abstraction is denoted in an <code class="docutils literal"><span class="pre">input_list</span></code> of a
<code class="docutils literal"><span class="pre">dependency_clause</span></code> of the original Depends aspect and its
refinement is visible at the point of the Refined_Depends aspect
(derived via the process described in the rules 3a - 3f above),
then:<ul>
<li>at least one of its <code class="docutils literal"><span class="pre">constituents</span></code> shall be denoted as an
<code class="docutils literal"><span class="pre">input</span></code> in at least one of the <code class="docutils literal"><span class="pre">dependency_clauses</span></code> of the
Refined_Depends aspect corresponding to the original
<code class="docutils literal"><span class="pre">dependency_clause</span></code> in the Depends aspect; or</li>
<li>at least one of its <code class="docutils literal"><span class="pre">constituents</span></code> shall be denoted in the
<code class="docutils literal"><span class="pre">input_list</span></code> of a <code class="docutils literal"><span class="pre">null_dependency_clause</span></code>; or</li>
<li>the state abstraction is both an <code class="docutils literal"><span class="pre">input</span></code> and an <code class="docutils literal"><span class="pre">output</span></code>
and not every <code class="docutils literal"><span class="pre">constituent</span></code> of the state abstraction is an
<code class="docutils literal"><span class="pre">output</span></code> of the Refined_Depends aspect. [This rule does not
exclude denoting a <code class="docutils literal"><span class="pre">constituent</span></code> of such a state abstraction
in an <code class="docutils literal"><span class="pre">input_list</span></code>.]</li>
</ul>
</li>
</ol>
</li>
</ol>
<ol class="arabic simple" id="tu-fe-refined-depends-aspects-04" start="4">
<li>These rules result in omitting each state abstraction whose <strong>null</strong>
refinement is visible at the point of the Refined_Depends. If and only if
required by the syntax, the state abstraction shall be replaced by a <strong>null</strong>
symbol rather than being omitted.</li>
</ol>
<ol class="arabic simple" id="tu-fe-refined-depends-aspects-05" start="5">
<li>No other <code class="docutils literal"><span class="pre">outputs</span></code> or <code class="docutils literal"><span class="pre">inputs</span></code> shall be included in the Refined_Depends
aspect specification. <code class="docutils literal"><span class="pre">Outputs</span></code> in the Refined_Depends aspect
specification shall denote distinct entities. <code class="docutils literal"><span class="pre">Inputs</span></code> in an <code class="docutils literal"><span class="pre">input_list</span></code>
shall denote distinct entities.</li>
</ol>
<ol class="arabic" id="tu-cbatu-refined-depends-aspects-06" start="6">
<li><p class="first">[The above rules may be viewed from the perspective of checking the
consistency of a Refined_Depends aspect with its corresponding Depends
aspect. In this view, each <code class="docutils literal"><span class="pre">input</span></code> in the Refined_Depends aspect that
is a <code class="docutils literal"><span class="pre">constituent</span></code> of a state abstraction, whose refinement is visible at
the point of the Refined_Depends aspect, is replaced by its representative
state abstraction with duplicate <code class="docutils literal"><span class="pre">inputs</span></code> removed.</p>
<p>Each <code class="docutils literal"><span class="pre">output</span></code> in the Refined_Depends aspect, which is a
<code class="docutils literal"><span class="pre">constituent</span></code> of the same state abstraction whose refinement is
visible at the point of the Refined_Depends aspect, is merged along
with its <code class="docutils literal"><span class="pre">input_list</span></code> into a single <code class="docutils literal"><span class="pre">dependency_clause</span></code> whose
<code class="docutils literal"><span class="pre">output</span></code> denotes the state abstraction and <code class="docutils literal"><span class="pre">input_list</span></code> is the
union of all of the <code class="docutils literal"><span class="pre">inputs</span></code> replaced by their encapsulating
state abstraction, as described above, and the state abstraction
itself if not every <code class="docutils literal"><span class="pre">constituent</span></code> of the state abstraction
appears as an <code class="docutils literal"><span class="pre">output</span></code> in the Refined_Depends aspect.]</p>
</li>
</ol>
<ol class="arabic simple" id="tu-cbatu-refined-depends-aspects-07" start="7">
<li>The rules for <a class="reference internal" href="subprograms.html#depends-aspects"><span class="std std-ref">Depends Aspects</span></a> also apply.</li>
</ol>
<p class="centered" id="etu-refined-depends-aspects-lr">
<strong><strong>Dynamic Semantics</strong></strong></p><p>There are no dynamic semantics associated with a Refined_Depends aspect
as it is used purely for static analysis purposes and is not executed.</p>
<p class="centered">
<strong><strong>Verification Rules</strong></strong></p><ol class="arabic simple" id="tu-fa-refined-depends-aspects-08" start="8">
<li>If a subprogram has a Refined_Depends aspect it is used in the analysis of
the subprogram body rather than its Depends aspect.</li>
</ol>
<ol class="arabic simple" id="tu-cbatu-refined-depends-aspects-09" start="9">
<li>The verification rules given for <a class="reference internal" href="subprograms.html#depends-aspects"><span class="std std-ref">Depends Aspects</span></a> also apply.</li>
</ol>
<p class="centered" id="etu-refined-depends-aspects-vr">
<strong><strong>Examples</strong></strong></p><div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Refined_Depends_Examples</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">S1</span><span class="p">,</span> <span class="n">S2</span><span class="o">)</span><span class="p">,</span>
       <span class="n">Initializes</span>    <span class="o">=&gt;</span> <span class="o">(</span><span class="n">S1</span><span class="p">,</span> <span class="n">V1</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">V1</span> <span class="o">:</span> <span class="n">Integer</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c">-- Visible state variables</span>

   <span class="k">procedure </span><span class="nf">P1_1</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">S1</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">S1</span> <span class="o">=&gt;+</span> <span class="n">I</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">P1_2</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">S1</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">S1</span> <span class="o">=&gt;+</span> <span class="n">I</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">P1_3</span> <span class="o">(</span><span class="n">Result</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span> <span class="o">=&gt;</span> <span class="n">S1</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Result</span> <span class="o">=&gt;</span> <span class="n">S1</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">P1_4</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">S1</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">S1</span> <span class="o">=&gt;</span> <span class="n">I</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">P2</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span>  <span class="o">=&gt;</span> <span class="n">V1</span><span class="p">,</span>
                      <span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">S2</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">S2</span> <span class="o">=&gt;+</span> <span class="n">V1</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">P3</span> <span class="o">(</span><span class="n">J</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">V1</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">V1</span> <span class="o">=&gt;</span> <span class="n">J</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">P4</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">S1</span><span class="p">,</span> <span class="n">V1</span><span class="o">)</span><span class="p">,</span>
                      <span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">S2</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">S2</span> <span class="o">=&gt;+</span> <span class="o">(</span><span class="n">S1</span><span class="p">,</span> <span class="n">V1</span><span class="o">))</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Refined_Depends_Examples</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Refined_Depends_Examples</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">S1</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="o">)</span><span class="p">,</span>
                         <span class="n">S2</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="o">))</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">A</span> <span class="o">:</span> <span class="n">Integer</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c">--  The constituents of S1</span>
   <span class="n">B</span> <span class="o">:</span> <span class="n">Integer</span> <span class="o">:=</span> <span class="mi">2</span><span class="p">;</span>  <span class="c">--  Initialized as promised</span>

   <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span> <span class="c">--  The constituents of S2</span>
                      <span class="c">--  Not initialized</span>

   <span class="k">procedure </span><span class="nf">P1_1</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="p">,</span>
                              <span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Refined_Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A</span> <span class="o">=&gt;</span> <span class="n">I</span><span class="p">,</span>  <span class="c">--  A and B are constituents of S1 and</span>
                                       <span class="c">--  both are outputs.</span>
		              <span class="n">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span>  <span class="c">--  A is dependent on I but A is also an</span>
                                       <span class="c">--  input and B depends on A. Hence the</span>
                                       <span class="c">--  Depends =&gt; (S1 =&gt;+ I).</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">B</span> <span class="o">:=</span> <span class="n">A</span><span class="p">;</span>
      <span class="n">A</span> <span class="o">:=</span> <span class="n">I</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">P1_1</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">P1_2</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Refined_Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A</span> <span class="o">=&gt;</span> <span class="n">I</span><span class="o">)</span>  <span class="c">--  One but not all of the constituents</span>
                                       <span class="c">--  of S1 is updated hence the</span>
                                       <span class="c">--  Depends =&gt; (S1 =&gt;+ I)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">A</span> <span class="o">:=</span> <span class="n">I</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">P1_2</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">P1_3</span> <span class="o">(</span><span class="n">Result</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Refined_Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Result</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span>  <span class="c">--  Not all of the constituents of</span>
                                            <span class="c">--  S1 are read but none of them</span>
                                            <span class="c">--  are updated, hence</span>
                                            <span class="c">--  Depends =&gt; (Result =&gt; S1)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Result</span> <span class="o">:=</span> <span class="n">B</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">P1_3</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">P1_4</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="o">))</span><span class="p">,</span>
          <span class="n">Refined_Depends</span> <span class="o">=&gt;</span> <span class="o">((</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">I</span><span class="o">)</span>  <span class="c">--  The constituents of S1 are not</span>
                                            <span class="c">--  inputs but all constituents of</span>
                                            <span class="c">--  S1 are updated, hence,</span>
                                            <span class="c">--  Depends =&gt; (S1 =&gt; I)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">A</span> <span class="o">:=</span> <span class="n">I</span><span class="p">;</span>
      <span class="n">B</span> <span class="o">:=</span> <span class="n">I</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">P1_4</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">P2</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span>  <span class="o">=&gt;</span> <span class="n">V1</span><span class="p">,</span>
                              <span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Refined_Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Z</span> <span class="o">=&gt;</span> <span class="n">V1</span><span class="o">)</span>  <span class="c">--  Only constituent Z of S2 is an</span>
                                        <span class="c">--  output. The other constituents of</span>
                                        <span class="c">--  S2 are preserved, hence,</span>
                                        <span class="c">--  Depends =&gt; (S2 =&gt;+ V1);</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Z</span> <span class="o">:=</span> <span class="n">V1</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">P2</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">P3</span> <span class="o">(</span><span class="n">J</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="c">-- No Refined_Depends aspect here because V1 has no refinement.</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">V1</span> <span class="o">:=</span> <span class="n">J</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">P3</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">P4</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A</span><span class="p">,</span> <span class="n">V1</span><span class="o">)</span><span class="p">,</span>
                              <span class="n">Output</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="o">))</span><span class="p">,</span>
          <span class="n">Refined_Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">X</span> <span class="o">=&gt;</span> <span class="n">V1</span><span class="p">,</span> <span class="c">--  Only constituents X and Y of S2 are</span>
                                       <span class="c">--  updated.</span>
                              <span class="n">Y</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span>  <span class="c">--  Z is not updated and so S2 must have</span>
                                       <span class="c">--  a self-dependency. Constituent A of</span>
                                       <span class="c">--  S1 is read and no constituent of S1</span>
                                       <span class="c">--  is updated, hence,</span>
                                       <span class="c">--  Depends =&gt; (S2 =&gt;+ (S1, V1))</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">X</span> <span class="o">:=</span> <span class="n">V1</span><span class="p">;</span>
      <span class="n">Y</span> <span class="o">:=</span> <span class="n">A</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">P4</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Refined_Depends_Examples</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="abstract-state-package-hierarchy-and-part-of">
<span id="package-hierarchy"></span><h3>7.2.6. Abstract_State, Package Hierarchy and Part_Of<a class="headerlink" href="#abstract-state-package-hierarchy-and-part-of" title="Permalink to this headline">¶</a></h3>
<p>In order to avoid aliasing-related problems (see <a class="reference internal" href="subprograms.html#anti-aliasing"><span class="std std-ref">Anti-Aliasing</span></a>), SPARK 2014
must ensure that if a given piece of state (either an object or a state
abstraction) is going to be a constituent of a given state abstraction, that
relationship must be known at the point where the constituent is declared.</p>
<p>For a variable declared immediately within a package body, this is not
a problem.  The state refinement in which the variable is specified as
a constituent precedes the declaration of the variable, and so there
is no <em>window</em> between the introduction of the variable and its
identification as a constituent. Similarly for a variable or state
abstraction that is part of the visible state of a package that is
declared immediately within the given package body.</p>
<p>For variable declared immediately within the private part of a
package, such an unwanted window does exist (and similarly for a
variable or state abstraction that is part of the visible state of a
package that is declared immediately within the given private part).</p>
<p>In order to cope with this situation, the Part_Of aspect provides a
mechanism for specifying at the point of a constituent&#8217;s declaration
the state abstraction to which it belongs, thereby closing the window.
The state abstraction&#8217;s refinement will eventually confirm this
relationship. The Part_Of aspect, in effect, makes visible a preview
of (some of) the state refinement that will eventually be provided in
the package body.</p>
<p>This mechanism is also used in the case of the visible state of a
private child unit (or a public descendant thereof).</p>
<p>The Part_Of aspect can also be used in a different way to indicate
that an object or state abstraction is to be treated as though it
were declared within a protected unit or task unit (see section
<a class="reference internal" href="tasks-and-synchronization.html#tasks-and-synchronization"><span class="std std-ref">Tasks and Synchronization</span></a>).</p>
<p class="centered">
<strong><strong>Static Semantics</strong></strong></p><ol class="arabic simple" id="tu-nt-abstract-state-package-hierarchy-and-part-of-01">
<li>A <em>Part_Of indicator</em> is a Part_Of <code class="docutils literal"><span class="pre">option</span></code> of a state
abstraction declaration in an Abstract_State aspect, a Part_Of
aspect specification applied to a variable declaration or a Part_Of
specification aspect applied to a generic package instantiation. The
Part_Of indicator shall denote the <em>encapsulating</em> state abstraction
of which the declaration is a constituent, or shall denote a
task or protected unit (see section <a class="reference internal" href="tasks-and-synchronization.html#tasks-and-synchronization"><span class="std std-ref">Tasks and Synchronization</span></a>).</li>
</ol>
<p class="centered" id="etu-abstract-state-package-hierarchy-and-part-of-ss">
<strong><strong>Legality Rules</strong></strong></p><ol class="arabic simple" id="tu-fe-abstract-state-package-hierarchy-and-part-of-02" start="2">
<li>A variable declared immediately within the private part of a given
package or a variable or state abstraction that is part of the
visible state of a package that is declared immediately within the
private part of the given package shall have its Part_Of indicator
specified; the Part_Of indicator shall denote a state abstraction
declared by the given package.</li>
</ol>
<ol class="arabic simple" id="tu-fe-abstract-state-package-hierarchy-and-part-of-03" start="3">
<li>A variable or state abstraction which is part of the visible state of a
non-generic private child unit (or a public descendant thereof) shall have
its Part_Of indicator specified; the Part_Of indicator shall denote a state
abstraction declared by either the parent unit of the private unit or by a
public descendant of that parent unit.</li>
</ol>
<ol class="arabic simple" id="tu-nt-abstract-state-package-hierarchy-and-part-of-04" start="4">
<li>A Part_Of aspect specification for a package instantiation applies
to each part of the visible state of the instantiation. More
specifically, explicitly specifying the Part_Of aspect of a package
instantiation implicitly specifies the Part_Of aspect of each part
of the visible state of that instantiation. The legality rules for
such an implicit specification are the same as for an explicit
specification.</li>
</ol>
<ol class="arabic simple" id="tu-cbatu-abstract-state-package-hierarchy-and-part-of-05" start="5">
<li>No other declarations shall have a Part_Of indicator which denotes
a state abstraction. [Other declarations may have a Part_Of indicator
which denotes a task or protected unit (see section
<a class="reference internal" href="tasks-and-synchronization.html#tasks-and-synchronization"><span class="std std-ref">Tasks and Synchronization</span></a>).]</li>
</ol>
<ol class="arabic simple" id="tu-fe-abstract-state-package-hierarchy-and-part-of-06" start="6">
<li>The refinement of a state abstraction denoted in a Part_Of
indicator shall denote as <code class="docutils literal"><span class="pre">constituents</span></code> all of the declarations
that have a Part_Of indicator denoting the state abstraction. [This
might be performed once the package body has been processed.]</li>
</ol>
<ol class="arabic simple" id="tu-fe-abstract-state-package-hierarchy-and-part-of-07" start="7">
<li>A state abstraction and a constituent (direct or indirect) thereof
shall not both be denoted in one Global, Depends, Initializes,
Refined_Global or Refined_Depends aspect specification.  The
denotation must be consistent between the Global and Depends or
between Refined_Global and Refined_Depends aspects of a single
subprogram.</li>
</ol>
<p class="centered" id="etu-abstract-state-package-hierarchy-and-part-of-lr">
<strong><strong>Verification Rules</strong></strong></p><ol class="arabic simple" id="tu-fe-abstract-state-package-hierarchy-and-part-of-08" start="8">
<li>For flow analysis, where a state abstraction is visible as well as
one or more of its <code class="docutils literal"><span class="pre">constituents</span></code>, its refinement is not visible
and the Global and or Depends aspects of a subprogram denote the
state abstraction, then in the implementation of the subprogram a
direct or indirect<ul>
<li>read of a <code class="docutils literal"><span class="pre">constituent</span></code> of the state abstraction shall be
treated as a read of the encapsulating state abstraction of the
<code class="docutils literal"><span class="pre">constituent</span></code>; or</li>
<li>update of a <code class="docutils literal"><span class="pre">constituent</span></code> of the state abstraction shall be
treated as an update of the encapsulating state abstraction of
the <code class="docutils literal"><span class="pre">constituent</span></code>.  An update of such a <code class="docutils literal"><span class="pre">constituent</span></code> is
regarded as updating its encapsulating state abstraction with a self
dependency as it is unknown what other <code class="docutils literal"><span class="pre">constituents</span></code> the state
abstraction encapsulates.</li>
</ul>
</li>
</ol>
<p class="centered" id="etu-abstract-state-package-hierarchy-and-part-of-vr">
<strong><strong>Examples</strong></strong></p><div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">P</span>
   <span class="c">--  P has no state abstraction</span>
<span class="kr">is</span><span class="p"></span>
   <span class="o">...</span>
<span class="k">end </span><span class="nf">P</span><span class="p">;</span>

<span class="c">--  P.Pub is the public package that declares the state abstraction</span>
<span class="k">package </span><span class="nf">P.Pub</span> <span class="c">--  public unit</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">R</span><span class="p">,</span> <span class="n">S</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="o">...</span>
<span class="k">end </span><span class="nf">P.Pub</span><span class="p">;</span>

<span class="c">--  State abstractions of P.Priv, A and B, plus the concrete variable X,</span>
<span class="c">--  are split up among two state abstractions within P.Pub, R and S.</span><span class="p"></span>
<span class="kr">with</span><span class="nn"> P.Pub;</span>
<span class="kr">private</span><span class="p"> </span><span class="k">package </span><span class="nf">P.Priv</span> <span class="c">--  private unit</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="o">((</span><span class="n">A</span> <span class="kr">with</span><span class="p"> </span><span class="n">Part_Of</span> <span class="o">=&gt;</span> <span class="n">P.Pub.R</span><span class="o">)</span><span class="p">,</span>
                          <span class="o">(</span><span class="n">B</span> <span class="kr">with</span><span class="p"> </span><span class="n">Part_Of</span> <span class="o">=&gt;</span> <span class="n">P.Pub.S</span><span class="o">))</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">X</span> <span class="o">:</span> <span class="n">T</span>  <span class="c">--  visible variable which is a constituent of P.Pub.R.</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Part_Of</span> <span class="o">=&gt;</span> <span class="n">P.Pub.R</span><span class="p">;</span>
<span class="k">end </span><span class="nf">P.Priv</span><span class="p">;</span>

<span class="kr">with</span><span class="nn"> P.Priv;</span> <span class="c">--  P.Priv has to be with&#39;d because its state is part of</span>
             <span class="c">--  the refined state.</span>
<span class="k">package body </span><span class="nf">P.Pub</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">R</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">P.Priv.A</span><span class="p">,</span> <span class="n">P.Priv.X</span><span class="p">,</span> <span class="n">Y</span><span class="o">)</span><span class="p">,</span>
                         <span class="n">S</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">P.Priv.B</span><span class="p">,</span> <span class="n">Z</span><span class="o">))</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">Y</span> <span class="o">:</span> <span class="n">T2</span><span class="p">;</span>  <span class="c">--  hidden state</span>
   <span class="n">Z</span> <span class="o">:</span> <span class="n">T3</span><span class="p">;</span>  <span class="c">--  hidden state</span>
   <span class="o">...</span>
<span class="k">end </span><span class="nf">P.Pub</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Outer</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A1</span><span class="p">,</span> <span class="n">A2</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Init_A1</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">A1</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A1</span> <span class="o">=&gt;</span> <span class="n">null</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Init_A2</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">A2</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A2</span> <span class="o">=&gt;</span> <span class="n">null</span><span class="o">)</span><span class="p">;</span>

<span class="kr">private</span><span class="p"></span>
   <span class="c">--  A variable declared in the private part must have a Part_Of aspect</span>
   <span class="n">Hidden_State</span> <span class="o">:</span> <span class="n">Integer</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Part_Of</span> <span class="o">=&gt;</span> <span class="n">A2</span><span class="p">;</span>

   <span class="k">package </span><span class="nf">Inner</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Abstract_state</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">B1</span> <span class="kr">with</span><span class="p"> </span><span class="n">Part_Of</span> <span class="o">=&gt;</span> <span class="n">Outer.A1</span><span class="o">)</span>
     <span class="c">--  State abstraction declared in the private</span>
     <span class="c">--  part must have a Part_Of option.</span>
   <span class="kr">is</span><span class="p"></span>
      <span class="c">--  B1 may be used in aspect specifications provided</span>
      <span class="c">--  Outer.A1 is not also used.</span>
      <span class="k">procedure </span><span class="nf">Init_B1</span>
        <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">B1</span><span class="o">)</span><span class="p">,</span>
             <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">B1</span> <span class="o">=&gt;</span> <span class="n">null</span><span class="o">)</span><span class="p">;</span>

      <span class="k">procedure </span><span class="nf">Init_A2</span>
        <span class="c">--  We can only refer to Outer.Hidden_State which is a constituent</span>
        <span class="c">--  of Outer.A2 if the subprogram does not also refer to Outer.A2.</span>
        <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">Hidden_State</span><span class="o">)</span><span class="p">,</span>
             <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Hidden_State</span> <span class="o">=&gt;</span> <span class="n">null</span><span class="o">)</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Inner</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Outer</span><span class="p">;</span>

<span class="k">package body </span><span class="nf">Outer</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A1</span> <span class="o">=&gt;</span> <span class="n">Inner.B1</span><span class="p">,</span>
                         <span class="n">A2</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Hidden_State</span><span class="p">,</span> <span class="n">State_In_Body</span><span class="o">))</span>
  <span class="c">--  A1 and A2 cannot be denoted in the body of Outer because their</span>
  <span class="c">--  refinements are visible.</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">State_In_Body</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>

   <span class="k">package body </span><span class="nf">Inner</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">B1</span> <span class="o">=&gt;</span> <span class="n">null</span><span class="o">)</span>  <span class="c">--  Oh, there isn&#39;t any state after all</span>
   <span class="kr">is</span><span class="p"></span>
      <span class="k">procedure </span><span class="nf">Init_B1</span>
        <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span>  <span class="o">=&gt;</span> <span class="kr">null</span><span class="p">,</span>  <span class="c">--  Refined_Global and</span>
             <span class="n">Refined_Depends</span> <span class="o">=&gt;</span> <span class="kr">null</span><span class="p"> </span>  <span class="c">--  Refined_Depends of a null refinement</span>
      <span class="kr">is</span><span class="p"></span>
      <span class="kr">begin</span><span class="p"></span>
         <span class="kr">null</span><span class="p">;</span>
      <span class="k">end </span><span class="nf">Init_B1</span><span class="p">;</span>

      <span class="k">procedure </span><span class="nf">Init_A2</span>
        <span class="c">--  The Global sparct is already in terms of the constituent</span>
        <span class="c">--  Hidden_State which is part of A2, so no refined</span>
        <span class="c">--  Global or Depends aspects are required.</span>
      <span class="kr">is</span><span class="p"></span>
      <span class="kr">begin</span><span class="p"></span>
         <span class="n">Outer.Hidden_State</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">end </span><span class="nf">Init_A2</span><span class="p">;</span>

   <span class="k">end </span><span class="nf">Inner</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Init_A1</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">Inner.B1</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Refined_Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Inner.B1</span> <span class="o">=&gt;</span> <span class="n">null</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Inner.Init_B1</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Init_A1</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Init_A2</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Hidden_State</span><span class="p">,</span> <span class="n">State_In_Body</span><span class="o">))</span><span class="p">,</span>
          <span class="n">Refined_Depends</span> <span class="o">=&gt;</span> <span class="o">((</span><span class="n">Hidden_State</span><span class="p">,</span> <span class="n">State_In_Body</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">null</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">State_In_Body</span> <span class="o">:=</span> <span class="mi">42</span><span class="p">;</span>
      <span class="n">Inner.Init_A2</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Init_A2</span><span class="p">;</span>

<span class="k">end </span><span class="nf">Outer</span><span class="p">;</span>

<span class="k">package </span><span class="nf">Outer.Public_Child</span> <span class="kr">is</span><span class="p"></span>
   <span class="c">--  Outer.A1 and Outer.A2 are visible but</span>
   <span class="c">--  Outer.Hidden_State is not (by the rules of Ada).</span>
   <span class="c">--  The Global and Depends Aspects are in terms</span>
   <span class="c">--  of the encapsulating state abstraction Outer.A2.</span>
   <span class="k">procedure </span><span class="nf">Init_A2_With</span> <span class="o">(</span><span class="n">Val</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">Outer.A2</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Outer.A2</span> <span class="o">=&gt;</span> <span class="n">Val</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Outer.Public_Child</span><span class="p">;</span>

<span class="k">package body </span><span class="nf">Outer.Public_Child</span> <span class="kr">is</span><span class="p"></span>
   <span class="c">--  Outer.Hidden is visible here but the</span>
   <span class="c">--  refinement of A2 is not so there are</span>
   <span class="c">--  no Refined_Global or Refined_Depends.</span>
   <span class="k">procedure </span><span class="nf">Init_A2_With</span> <span class="o">(</span><span class="n">Val</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span> <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Outer.Init_A2</span><span class="p">;</span>
      <span class="n">Outer.Hidden_State</span> <span class="o">:=</span> <span class="n">Val</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Init_A2_With</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Outer.Public_Child</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Q</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Q1</span><span class="p">,</span> <span class="n">Q2</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="c">--  Q1 and Q2 may be denoted here</span>
   <span class="k">procedure </span><span class="nf">Init_Q1</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">Q1</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Q1</span> <span class="o">=&gt;</span> <span class="n">null</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Init_Q2</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">Q2</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Q2</span> <span class="o">=&gt;</span> <span class="n">null</span><span class="o">)</span><span class="p">;</span>

<span class="kr">private</span><span class="p"></span>
   <span class="n">Hidden_State</span> <span class="o">:</span> <span class="n">Integer</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Part_Of</span> <span class="o">=&gt;</span> <span class="n">Q2</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Q</span><span class="p">;</span>

<span class="kr">private</span><span class="p"> </span><span class="k">package </span><span class="nf">Q.Child</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">C1</span> <span class="kr">with</span><span class="p"> </span><span class="n">Part_Of</span> <span class="o">=&gt;</span> <span class="n">Q.Q1</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="c">--  C1 rather than the encapsulating state abstraction</span>
   <span class="c">--  may be used in aspect specifications provided</span>
   <span class="c">--  Q.Q1 is not also denoted in the same aspect</span>
   <span class="c">--  specification.</span>

   <span class="c">--  Here C1 is used so Q1 cannot also be used in</span>
   <span class="c">--  the aspect specifications of this subprogram.</span>
   <span class="k">procedure </span><span class="nf">Init_Q1</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">C1</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">C1</span> <span class="o">=&gt;</span> <span class="n">null</span><span class="o">)</span><span class="p">;</span>

   <span class="c">--  Q.Hidden_State which is a constituent of Q.Q2</span>
   <span class="c">--  is visible here so it can be used in a aspect</span>
   <span class="c">--  specification provided Q.Q2 is not also used.</span>
   <span class="k">procedure </span><span class="nf">Init_Q2</span>
      <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">Q.Hidden_State</span><span class="o">)</span><span class="p">,</span>
           <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Q.Hidden_State</span> <span class="o">=&gt;</span> <span class="n">null</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Q.Child</span><span class="p">;</span>

<span class="k">package body </span><span class="nf">Q.Child</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">C1</span> <span class="o">=&gt;</span> <span class="n">Actual_State</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="c">--  C1 shall not be denoted here - only Actual_State</span>
   <span class="c">--  but Q.Q2 and Q.Hidden_State may be denoted.</span>
   <span class="n">Actual_State</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Init_Q1</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">Actual_State</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Refined_Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Actual_State</span> <span class="o">=&gt;</span> <span class="n">null</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Actual_State</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Init_Q1</span><span class="p">;</span>

   <span class="c">--  The refinement of Q2 is not visible and so Init_Q2</span>
   <span class="c">--  has no Refined_Global or Refined_Depends aspects.</span>
   <span class="k">procedure </span><span class="nf">Init_Q2</span> <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Q.Hidden_State</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Init_Q2</span><span class="p">;</span>

<span class="k">end </span><span class="nf">Q.Child</span><span class="p">;</span>

<span class="kr">with</span><span class="nn"> Q.Child;</span>

<span class="k">package body </span><span class="nf">Q</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Q1</span> <span class="o">=&gt;</span> <span class="n">Q.Child.C1</span><span class="p">,</span>
                         <span class="n">Q2</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Hidden_State</span><span class="p">,</span> <span class="n">State_In_Body</span><span class="o">))</span>
<span class="kr">is</span><span class="p"></span>
   <span class="c">--  Q1 and Q2 shall not be denoted here but the constituents</span>
   <span class="c">--  Q.Child.C1, State_In_Body and Hidden_State may be.</span>
   <span class="n">State_In_Body</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Init_Q1</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">Q.Child.C1</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Refined_Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Q.Child.C1</span> <span class="o">=&gt;</span> <span class="n">null</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Q.Child.Init_Q1</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Init_Q1</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Init_Q2</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Hidden_State</span><span class="p">,</span> <span class="n">State_in_Body</span><span class="o">))</span><span class="p">,</span>
          <span class="n">Refined_Depends</span> <span class="o">=&gt;</span> <span class="o">((</span><span class="n">Hidden_State</span><span class="p">,</span> <span class="n">State_in_Body</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">null</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">State_In_Body</span> <span class="o">:=</span> <span class="mi">42</span><span class="p">;</span>
      <span class="n">Q.Child.Init_Q2</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Init_Q2</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Q</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">R</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="n">R1</span>
<span class="kr">is</span><span class="p"></span>
   <span class="c">-- R1 may be denoted here</span>
   <span class="k">procedure </span><span class="nf">Init_R1</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">R1</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">R1</span> <span class="o">=&gt;</span> <span class="n">null</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Op_1</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">R1</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">R1</span> <span class="o">=&gt;+</span> <span class="n">I</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Q</span><span class="p">;</span>

<span class="kr">private</span><span class="p"> </span><span class="k">package </span><span class="nf">R.Child</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">R2</span> <span class="kr">with</span><span class="p"> </span><span class="n">Part_Of</span> <span class="o">=&gt;</span> <span class="n">R.R1</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="c">--  Both R.R1 and R2 are visible.</span>

   <span class="c">--  Here more than just the R2 constituent of R.R1</span>
   <span class="c">--  will be updated and so we use R.R1 in the</span>
   <span class="c">--  aspect specifications rather than R2.</span>
   <span class="c">--  R2 cannot also be used in the aspect</span>
   <span class="c">--  specifications of this subprogram.</span>
   <span class="k">procedure </span><span class="nf">Private_Op</span> <span class="o">(</span><span class="n">I</span><span class="p">,</span> <span class="n">J</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">R.R1</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">R.R1</span> <span class="o">=&gt;+</span> <span class="o">(</span><span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="o">))</span><span class="p">;</span>
<span class="k">end </span><span class="nf">R.Child</span><span class="p">;</span>

<span class="k">package body </span><span class="nf">R.Child</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">R2</span> <span class="o">=&gt;</span> <span class="n">Actual_State</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="c">--  R2 shall not be denoted here - only Actual_State</span>
   <span class="c">--  but R.R1 may be denoted.</span>
   <span class="n">Actual_State</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>

   <span class="c">--  The Global and Depends aspects of Private_Op</span>
   <span class="c">--  are in terms of R.R1 and the refinement of</span>
   <span class="c">--  R.R1 is not visible and so Refined_Global</span>
   <span class="c">--  and Refined_Depends are not required.</span>
   <span class="k">procedure </span><span class="nf">Private_Op</span> <span class="o">(</span><span class="n">I</span><span class="p">,</span> <span class="n">J</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span> <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">R.Op_1</span> <span class="o">(</span><span class="n">I</span><span class="o">)</span><span class="p">;</span>
      <span class="n">Actual_State</span> <span class="o">:=</span> <span class="n">J</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Private_Op</span><span class="p">;</span>
<span class="k">end </span><span class="nf">R.Child</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="refined-postcondition-aspects">
<span id="refined-postcondition"></span><h3>7.2.7. Refined Postcondition Aspects<a class="headerlink" href="#refined-postcondition-aspects" title="Permalink to this headline">¶</a></h3>
<p>A subprogram declared in the specification of a package may have a Refined_Post
aspect applied to its body or body stub. The Refined_Post aspect
may be used to restate a postcondition given on the declaration of a subprogram
in terms of the full view of a private type or the <code class="docutils literal"><span class="pre">constituents</span></code> of a refined
<code class="docutils literal"><span class="pre">state_name</span></code>.</p>
<p>The Refined_Post aspect is introduced by an <code class="docutils literal"><span class="pre">aspect_specification</span></code>
where the <code class="docutils literal"><span class="pre">aspect_mark</span></code> is &#8220;Refined_Post&#8221; and the <code class="docutils literal"><span class="pre">aspect_definition</span></code> shall
be a Boolean <code class="docutils literal"><span class="pre">expression</span></code>.</p>
<p class="centered">
<strong><strong>Legality Rules</strong></strong></p><ol class="arabic simple" id="tu-fe-refined-postcondition-aspects-01">
<li>A Refined_Post aspect may only appear on a body_stub (if one is
present) or the body (if no stub is present) of a subprogram or
entry which is declared in the specification of a package, its
abstract view. If the initial declaration in the visible part has
no explicit postcondition, a postcondition of True is assumed for
the abstract view.</li>
</ol>
<ol class="arabic simple" id="tu-cbatu-refined-postcondition-aspects-02" start="2">
<li>A Refined_Post aspect is an assertion. The same legality rules
apply to a Refined_Post aspect as for a postcondition (a Post
aspect).</li>
</ol>
<p class="centered" id="etu-refined-postcondition-aspects-lr">
<strong><strong>Static Semantics</strong></strong></p><ol class="arabic simple" id="tu-cbatu-refined-postcondition-aspects-03" start="3">
<li>[A Refined Postcondition of a subprogram defines a <em>refinement</em>
of the postcondition of the subprogram and is intended for use
by callers who can see the body of the subprogram.]</li>
</ol>
<ol class="arabic simple" id="tu-pr-refined-postcondition-aspects-04" start="4">
<li>[Logically, the Refined Postcondition of a subprogram must imply
its postcondition. This means that it is perfectly logical for the
declaration not to have a postcondition (which in its absence
defaults to True) but for the body or body stub to have a
Refined Postcondition. It also means that a caller who sees the
Refined Postcondition of a subprogram will always be able to
prove at least as much about the results of the call as if the
usual precondition were used instead.]</li>
</ol>
<ol class="arabic simple" id="tu-cbatu-refined-postcondition-aspects-05" start="5">
<li>The static semantics are otherwise as for a postcondition.</li>
</ol>
<p class="centered" id="etu-refined-postcondition-aspects-ss">
<strong><strong>Dynamic Semantics</strong></strong></p><ol class="arabic simple" id="tu-fe-refined-postcondition-aspects-06" start="6">
<li>When a subprogram or entry with a Refined Postcondition is called,
the Refined Postcondition is evaluated
immediately before the evaluation of the postcondition or, if there is no
postcondition, immediately before the point at which a postcondition would
have been evaluated. If the Refined Postcondition evaluates to
False, then the exception Assertion.Assertion_Error is raised.
Otherwise, the postcondition is then evaluated and checked
as described in the Ada RM.</li>
</ol>
<p class="centered" id="etu-refined-postcondition-aspects-ds">
<strong><strong>Verification Rules</strong></strong></p><ol class="arabic" id="tu-pr-refined-postcondition-aspects-07" start="7">
<li><p class="first">If a subprogram has both a Refined_Post aspect and a
Post (and/or Post&#8217;Class) aspect, then the verification condition
associated with postcondition checking is discharged in two steps.</p>
<p>First, the success of the Refined_Post run-time check must be proven
as usual (i.e., just like any other run-time check).</p>
<p>Next, an additional proof obligation is generated which relates
the Refined_Post to to the Post (and Post&#8217;Class) aspects of
the subprogram according to a &#8220;wrapper&#8221; model. Imagine two
subprograms with the same parameter profile and Global and
Depends aspects, but with different postconditions P1 and P2
(neither of these two subprograms has a Refined_Post aspect).
Suppose further that the first subprogram is a &#8220;wrapper&#8221; for
the second; that is, its implementation consists of nothing
but a call to the second subprogram (for functions,
the call would occur in a return statement). Consider
the proof obligation generated for the postcondition
check of that &#8220;wrapper&#8221; subprogram; roughly speaking, it
is a check that P1 is implied by P2. In that sense of the
word &#8220;implied&#8221;, a verification condition is generated
that any Post/Post&#8217;Class condition for a subprogram is
implied by its Refined_Post condition. In particular,
knowledge about the internals of the subprogram
that was available in proving the Refined_Post condition
is not available in proving this implication (just
as, in the &#8220;wrapper&#8221; illustration, the internal details of
the second subprogram are not available in proving the postcondition
of the first).</p>
</li>
</ol>
<ol class="arabic simple" id="tu-pr-refined-postcondition-aspects-08" start="8">
<li>If a Refined_Post aspect specification is visible at the
point of a call to the subprogram, then the Refined_Post
is used instead of the Postcondition aspect for purposes of formal
analysis of the call. Similarly for using the Refined_Global aspect
instead of the Global aspect and the Refined_Depends aspect instead
of the Depends aspect. [Roughly speaking, the &#8220;contract&#8221; associated
with a call is defined by using the Refined_* aspects of the callee
instead of the corresponding non-refined aspects in the case where
Refined_* aspect specifications are visible.]</li>
</ol>
<p class="centered" id="etu-refined-postcondition-aspects-vr">
<strong><strong>Examples</strong></strong></p><p>These examples show the two ways in which the Refined_Post aspect is
useful:</p>
<ol class="arabic simple">
<li>To write a postcondition in terms of the full view of a private
type.</li>
<li>To write a postcondition in terms of the constituents of a state
abstraction.</li>
</ol>
<p>In either case a postcondition may be strengthened by the Refined_Post
aspect by adding further constraints. The combination of these two
types of usage in a single package is not necessarily common but is
used here for brevity of the example.</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Stacks_1</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span>
<span class="kr">is</span><span class="p"></span>
   <span class="kr">type</span><span class="p"> </span><span class="n">Stack_Type</span> <span class="kr">is</span><span class="p"> </span><span class="kr">private</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Is_Empty</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Stack_Type</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span><span class="p">;</span>
   <span class="c">--  Default postcondition is True.</span>

   <span class="k">function </span><span class="nf">Is_Full</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Stack_Type</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span><span class="p">;</span>
   <span class="c">--  Default postcondition is True.</span>

   <span class="k">procedure </span><span class="nf">Push</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Stack_Type</span><span class="p">;</span> <span class="n">I</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Pre</span>  <span class="o">=&gt;</span> <span class="kr">not</span><span class="p"> </span><span class="n">Is_Full</span> <span class="o">(</span><span class="n">S</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Post</span> <span class="o">=&gt;</span> <span class="kr">not</span><span class="p"> </span><span class="n">Is_Empty</span> <span class="o">(</span><span class="n">S</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Pop</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Stack_Type</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Post</span> <span class="o">=&gt;</span> <span class="kr">not</span><span class="p"> </span><span class="n">Is_Full</span> <span class="o">(</span><span class="n">S</span><span class="o">)</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Top</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Stack_Type</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Pre</span> <span class="o">=&gt;</span> <span class="kr">not</span><span class="p"> </span><span class="n">Is_Empty</span> <span class="o">(</span><span class="n">S</span><span class="o">)</span><span class="p">;</span>
<span class="kr">private</span><span class="p"></span>
   <span class="c">--  Full type declaration of private type.</span>
   <span class="n">Stack_Size</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="o">:=</span> <span class="mi">100</span><span class="p">;</span>

   <span class="kr">type</span><span class="p"> </span><span class="n">Pointer_Type</span> <span class="kr">is</span><span class="p"> </span><span class="kr">range</span><span class="p"> </span><span class="mi">0</span> <span class="o">..</span> <span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">subtype</span><span class="p"> </span><span class="n">Stack_Index</span> <span class="kr">is</span><span class="p"> </span><span class="n">Pointer_Type</span> <span class="kr">range</span><span class="p"> </span><span class="mi">1</span> <span class="o">..</span> <span class="n">Pointer_Type</span><span class="na">&#39;Last</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span><span class="n">Stack_Array</span> <span class="kr">is</span><span class="p"> </span><span class="kr">array</span><span class="p"> </span><span class="o">(</span><span class="n">Stack_Index</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>

   <span class="c">--  All stack objects have default initialization.</span>
   <span class="kr">type</span><span class="p"> </span><span class="n">Stack_Type</span> <span class="kr">is</span><span class="p"> </span><span class="kr">record</span><span class="p"></span>
      <span class="n">Pointer</span> <span class="o">:</span> <span class="n">Pointer_Type</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">Vector</span>  <span class="o">:</span> <span class="n">Stack_Array</span> <span class="o">:=</span> <span class="o">(</span><span class="kr">others</span><span class="p"> </span><span class="o">=&gt;</span> <span class="mi">0</span><span class="o">)</span><span class="p">;</span>
   <span class="k">end record</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Stacks_1</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Stacks_1</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">Is_Empty</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Stack_Type</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">S.Pointer</span> <span class="o">=</span> <span class="mi">0</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--  Default Refined_Post =&gt; Is_Empty&#39;Result = S.Pointer = 0</span>
   <span class="c">--  refines the postcondition of True in terms of the full view of</span>
   <span class="c">--  Stack_Type.</span>

   <span class="k">function </span><span class="nf">Is_Full</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Stack_Type</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span> <span class="kr">is</span><span class="p"></span>
     <span class="o">(</span><span class="n">S.Pointer</span> <span class="o">=</span> <span class="n">Stack_Size</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--  Default Refined_Post =&gt; Is_Full&#39;Result = (S.Pointer = Stack_Size)</span>
   <span class="c">--  refines the postcondition of True in terms of the full view of</span>
   <span class="c">--  Stack_Type.</span>

   <span class="k">procedure </span><span class="nf">Push</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Stack_Type</span><span class="p">;</span> <span class="n">I</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Post</span> <span class="o">=&gt;</span> <span class="n">S.Pointer</span> <span class="o">=</span> <span class="n">S.Pointer</span><span class="na">&#39;Old</span> <span class="o">+</span> <span class="mi">1</span> <span class="kr">and</span><span class="p"></span>
          <span class="n">S.Vector</span> <span class="o">=</span> <span class="n">S.Vector</span><span class="na">&#39;Old&#39;Update</span> <span class="o">(</span><span class="n">S.Pointer</span> <span class="o">=&gt;</span> <span class="n">I</span><span class="o">)</span>
     <span class="c">--  Refined_Post in terms of full view of Stack_Type and a</span>
     <span class="c">--  further constraint added specifying what is required by the</span>
     <span class="c">--  implementation.</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">S.Pointer</span> <span class="o">:=</span> <span class="n">S.Pointer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">S.Vector</span> <span class="o">(</span><span class="n">S.Pointer</span><span class="o">)</span> <span class="o">:=</span> <span class="n">I</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Push</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Pop</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Stack_Type</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Post</span> <span class="o">=&gt;</span> <span class="n">S.Pointer</span> <span class="o">=</span> <span class="n">S.Pointer</span><span class="na">&#39;Old</span> <span class="o">-</span> <span class="mi">1</span>
     <span class="c">--  Refined_Post in terms of full view of Stack_Type and also</span>
     <span class="c">--  specifies what is required by the implementation.</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="kr">if</span><span class="p"> </span><span class="n">S.Pointer</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="kr">then</span><span class="p"></span>
         <span class="n">S.Pointer</span> <span class="o">:=</span> <span class="n">S.Pointer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">end if</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Pop</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Top</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Stack_Type</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">S.Vector</span> <span class="o">(</span><span class="n">S.Pointer</span><span class="o">))</span><span class="p">;</span>
   <span class="c">--  Default Refined_Post =&gt; Top&#39;Result = S.Vector (S.Pointer)</span>
   <span class="c">--  refines the postcondition of True in terms of the full view of</span>
   <span class="c">--  Stack_Type.</span>
<span class="k">end </span><span class="nf">Stacks_1</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Stacks_2</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="n">The_Stack</span><span class="p">,</span>
       <span class="n">Initializes</span>    <span class="o">=&gt;</span> <span class="n">The_Stack</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">Is_Empty</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="n">The_Stack</span><span class="p">;</span>
   <span class="c">--  Default postcondition is True.</span>

   <span class="k">function </span><span class="nf">Is_Full</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="n">The_Stack</span><span class="p">;</span>
   <span class="c">--  Default postcondition is True.</span>

   <span class="k">procedure </span><span class="nf">Push</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">The_Stack</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Pre</span>    <span class="o">=&gt;</span> <span class="kr">not</span><span class="p"> </span><span class="n">Is_Full</span><span class="p">,</span>
          <span class="n">Post</span>   <span class="o">=&gt;</span> <span class="kr">not</span><span class="p"> </span><span class="n">Is_Empty</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Pop</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">The_Stack</span><span class="o">)</span><span class="p">,</span>
     <span class="n">Post</span>   <span class="o">=&gt;</span> <span class="kr">not</span><span class="p"> </span><span class="n">Is_Full</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Top</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="n">The_Stack</span><span class="p">,</span>
          <span class="n">Pre</span>    <span class="o">=&gt;</span> <span class="kr">not</span><span class="p"> </span><span class="n">Is_Empty</span><span class="p">;</span>
   <span class="c">--  Default postcondition is True.</span>
<span class="kr">private</span><span class="p"></span>
   <span class="c">--  Full type declaration of private type for usage (1).</span>
   <span class="n">Stack_Size</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="o">:=</span> <span class="mi">100</span><span class="p">;</span>

   <span class="kr">type</span><span class="p"> </span><span class="n">Pointer_Type</span> <span class="kr">is</span><span class="p"> </span><span class="kr">range</span><span class="p"> </span><span class="mi">0</span> <span class="o">..</span> <span class="n">Stack_Size</span><span class="p">;</span>
   <span class="kr">subtype</span><span class="p"> </span><span class="n">Stack_Index</span> <span class="kr">is</span><span class="p"> </span><span class="n">Pointer_Type</span> <span class="kr">range</span><span class="p"> </span><span class="mi">1</span> <span class="o">..</span> <span class="n">Pointer_Type</span><span class="na">&#39;Last</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span><span class="n">Stack_Array</span> <span class="kr">is</span><span class="p"> </span><span class="kr">array</span><span class="p"> </span><span class="o">(</span><span class="n">Stack_Index</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>

   <span class="c">--  All stack objects have default initialization.</span>
   <span class="kr">type</span><span class="p"> </span><span class="n">Stack_Type</span> <span class="kr">is</span><span class="p"> </span><span class="kr">record</span><span class="p"></span>
      <span class="n">Pointer</span> <span class="o">:</span> <span class="n">Pointer_Type</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">Vector</span>  <span class="o">:</span> <span class="n">Stack_Array</span> <span class="o">:=</span> <span class="o">(</span><span class="kr">others</span><span class="p"> </span><span class="o">=&gt;</span> <span class="mi">0</span><span class="o">)</span><span class="p">;</span>
   <span class="k">end record</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Stacks_2</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Stacks_2</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">The_Stack</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A_Pointer</span><span class="p">,</span> <span class="n">A_Vector</span><span class="o">))</span>
<span class="kr">is</span><span class="p"></span>
   <span class="c">--  Constituents of state abstraction The_Stack</span>
   <span class="c">--  We promised to initialize The_Stack</span>
   <span class="n">A_Pointer</span> <span class="o">:</span> <span class="n">Pointer_Type</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="n">A_Vector</span>  <span class="o">:</span> <span class="n">Stack_Array</span> <span class="o">:=</span> <span class="o">(</span><span class="kr">others</span><span class="p"> </span><span class="o">=&gt;</span> <span class="mi">0</span><span class="o">)</span><span class="p">;</span>

   <span class="c">--  Is_Empty could have been written as a expression function as was done</span>
   <span class="c">--  for Is_Empty (S : Stack_Type) but is presented here as a subproram body</span>
   <span class="c">--  to contrast the two approaches</span>
   <span class="k">function </span><span class="nf">Is_Empty</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="n">A_Pointer</span><span class="p">,</span>
          <span class="n">Refined_Post</span>   <span class="o">=&gt;</span> <span class="n">Is_Empty</span><span class="na">&#39;Result</span> <span class="o">=</span> <span class="o">(</span><span class="n">A_Pointer</span> <span class="o">=</span> <span class="mi">0</span><span class="o">)</span>
     <span class="c">--  Refines the postcondition of True in terms of the constituent A_Pointer.</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="kr">return</span><span class="p"> </span><span class="n">A_Pointer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Is_Empty</span><span class="p">;</span>

   <span class="c">--  Could be written as an expression function</span>
   <span class="k">function </span><span class="nf">Is_Full</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="n">A_Pointer</span><span class="p">,</span>
          <span class="n">Refined_Post</span>   <span class="o">=&gt;</span> <span class="n">Is_Full</span><span class="na">&#39;Result</span> <span class="o">=</span> <span class="o">(</span><span class="n">A_Pointer</span> <span class="o">=</span> <span class="n">Stack_Size</span><span class="o">)</span>
     <span class="c">--  Refines the postcondition of True in terms of the constituent A_Pointer.</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="kr">return</span><span class="p"> </span><span class="n">A_Pointer</span> <span class="o">=</span> <span class="n">Stack_Size</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Is_Full</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Push</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A_Pointer</span><span class="p">,</span> <span class="n">A_Vector</span><span class="o">))</span><span class="p">,</span>
          <span class="n">Refined_Post</span>   <span class="o">=&gt;</span> <span class="n">A_Pointer</span> <span class="o">=</span> <span class="n">A_Pointer</span><span class="na">&#39;Old</span> <span class="o">+</span> <span class="mi">1</span> <span class="kr">and</span><span class="p"></span>
                            <span class="n">A_Vector</span> <span class="o">=</span> <span class="n">A_Vector</span><span class="na">&#39;Old&#39;Update</span> <span class="o">(</span><span class="n">A_Pointer</span> <span class="o">=&gt;</span> <span class="n">I</span><span class="o">)</span>
     <span class="c">--  Refined_Post in terms of constituents A_Pointer and A_Vector and a further</span>
     <span class="c">--  constraint added specifying what is required by the implementation.</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">A_Pointer</span> <span class="o">:=</span> <span class="n">A_Pointer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">A_Vector</span> <span class="o">(</span><span class="n">A_Pointer</span><span class="o">)</span> <span class="o">:=</span> <span class="n">I</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Push</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Pop</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">A_Pointer</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Refined_Post</span>   <span class="o">=&gt;</span> <span class="n">A_Pointer</span> <span class="o">=</span> <span class="n">A_Pointer</span><span class="na">&#39;Old</span> <span class="o">-</span> <span class="mi">1</span>
     <span class="c">--  Refined_Post in terms of constituents A_Pointer and also</span>
     <span class="c">--  specifies what is required by the implementation.</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">A_Pointer</span> <span class="o">:=</span> <span class="n">A_Pointer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Pop</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Top</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">A_Vector</span> <span class="o">(</span><span class="n">A_Pointer</span><span class="o">))</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A_Pointer</span><span class="p">,</span> <span class="n">A_Vector</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--  Default Refined_Post =&gt; Top&#39;Result = A_Vector (S.Pointer)</span>
   <span class="c">--  refines the postcondition of True in terms of the constituents</span>
   <span class="c">--  A_Pointer and A_Vector.</span>
<span class="k">end </span><span class="nf">Stacks_2</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="refined-external-states">
<span id="id4"></span><h3>7.2.8. Refined External States<a class="headerlink" href="#refined-external-states" title="Permalink to this headline">¶</a></h3>
<p>External state which is a state abstraction requires a refinement as does any
state abstraction. There are rules which govern refinement of a state
abstraction on to external states which are given in this section.</p>
<p class="centered">
<strong><strong>Legality Rules</strong></strong></p><ol class="arabic simple" id="tu-fe-refined-external-states-01">
<li>A state abstraction that is not specified as External shall not have
<code class="docutils literal"><span class="pre">constituents</span></code> which are External states.</li>
</ol>
<ol class="arabic simple" id="tu-fe-refined-external-states-02" start="2">
<li>An External state abstraction shall have each of the properties set to True
which are True for any of its <code class="docutils literal"><span class="pre">constituents</span></code>.</li>
</ol>
<ol class="arabic simple" id="tu-cbatu-refined-external-states-03" start="3">
<li>Refined_Global aspects must respect the rules related to external
properties of constituents which are external states given in
<a class="reference internal" href="#external-state"><span class="std std-ref">External State</span></a> and <a class="reference internal" href="#external-state-variables"><span class="std std-ref">External State - Variables</span></a>.</li>
</ol>
<ol class="arabic simple" id="tu-cbatu-refined-external-states-04" start="4">
<li>All other rules for Refined_State, Refined_Global and Refined_Depends aspect
also apply.</li>
</ol>
<p class="centered" id="etu-refined-external-states-lr">
<strong><strong>Examples</strong></strong></p><div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Externals</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="o">((</span><span class="n">Combined_Inputs</span> <span class="kr">with</span><span class="p"> </span><span class="n">External</span> <span class="o">=&gt;</span> <span class="n">Async_Writers</span><span class="o">)</span><span class="p">,</span>
                          <span class="o">(</span><span class="n">Displays</span> <span class="kr">with</span><span class="p"> </span><span class="n">External</span> <span class="o">=&gt;</span> <span class="n">Async_Readers</span><span class="o">)</span><span class="p">,</span>
                          <span class="o">(</span><span class="n">Complex_Device</span> <span class="kr">with</span><span class="p"> </span><span class="n">External</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Async_Readers</span><span class="p">,</span>
                                                            <span class="n">Effective_Writes</span><span class="p">,</span>
                                                            <span class="n">Async_Writers</span><span class="o">)))</span><span class="p">,</span>
       <span class="n">Initializes</span>    <span class="o">=&gt;</span> <span class="n">Complex_Device</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Read</span> <span class="o">(</span><span class="n">Combined_Value</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="n">Combined_Inputs</span><span class="p">,</span>  <span class="c">-- Combined_Inputs is an Input;</span>
                                       <span class="c">-- it does not have Effective_Reads and</span>
                                       <span class="c">-- may be an specified just as an</span>
                                       <span class="c">-- Input in Global and Depends aspects.</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Combined_Value</span> <span class="o">=&gt;</span> <span class="n">Combined_Inputs</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Display</span> <span class="o">(</span><span class="n">D_Main</span><span class="p">,</span> <span class="n">D_Secondary</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">String</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">Displays</span><span class="o">)</span><span class="p">,</span> <span class="c">-- Displays is an Output and may</span>
                                           <span class="c">-- be specified just as an</span>
                                           <span class="c">-- Output in Global and Depends</span>
                                           <span class="c">-- aspects.</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Displays</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">D_Main</span><span class="p">,</span> <span class="n">D_Secondary</span><span class="o">))</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Last_Value_Sent</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Volatile_Function</span><span class="p">,</span>
          <span class="n">Global</span> <span class="o">=&gt;</span> <span class="n">Complex_Device</span><span class="p">;</span>  <span class="c">-- Complex_Device is an External</span>
                                     <span class="c">-- state.  It can be a global_item of</span>
                                     <span class="c">-- a function provided the Refined_Global</span>
                                     <span class="c">-- aspect only refers to non-volatile</span>
                                     <span class="c">-- constituents and to external</span>
                                     <span class="c">-- state abstractions via calls to</span>
                                     <span class="c">-- functions defined on them.</span>

   <span class="k">procedure </span><span class="nf">Output_Value</span> <span class="o">(</span><span class="n">Value</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">Complex_Device</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Complex_Device</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Complex_Device</span><span class="p">,</span> <span class="n">Value</span><span class="o">))</span><span class="p">;</span>
   <span class="c">-- Output_Value only sends out a value if it is not the same</span>
   <span class="c">-- as the last value sent.  When a value is sent it updates</span>
   <span class="c">-- the saved value and has to check a status port.</span>
   <span class="c">-- The subprogram must be a procedure.</span>

<span class="k">end </span><span class="nf">Externals</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">private</span><span class="p"> </span><span class="k">package </span><span class="nf">Externals.Temperature</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State</span> <span class="kr">with</span><span class="p"> </span><span class="n">External</span> <span class="o">=&gt;</span> <span class="n">Async_Writers</span><span class="p">,</span>
                                     <span class="n">Part_Of</span>  <span class="o">=&gt;</span> <span class="n">Externals.Combined_Inputs</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Read</span> <span class="o">(</span><span class="n">Temp</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="n">State</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Temp</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Externals.Temperature</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">private</span><span class="p"> </span><span class="k">package </span><span class="nf">Externals.Pressure</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State</span> <span class="kr">with</span><span class="p"> </span><span class="n">External</span> <span class="o">=&gt;</span> <span class="n">Async_Writers</span><span class="p">,</span>
                                     <span class="n">Part_Of</span>  <span class="o">=&gt;</span> <span class="n">Externals.Combined_Inputs</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Read</span> <span class="o">(</span><span class="n">Press</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="n">State</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Press</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Externals.Pressure</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">private</span><span class="p"> </span><span class="k">package </span><span class="nf">Externals.Main_Display</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State</span> <span class="kr">with</span><span class="p"> </span><span class="n">External</span> <span class="o">=&gt;</span> <span class="n">Async_Readers</span><span class="p">,</span>
                                     <span class="n">Part_Of</span>  <span class="o">=&gt;</span> <span class="n">Externals.Displays</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Display</span> <span class="o">(</span><span class="n">Text</span><span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">String</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State</span> <span class="o">=&gt;</span> <span class="n">Text</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Externals.Main_Display</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">private</span><span class="p"> </span><span class="k">package </span><span class="nf">Externals.Secondary_Display</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State</span> <span class="kr">with</span><span class="p"> </span><span class="n">External</span> <span class="o">=&gt;</span> <span class="n">Async_Readers</span><span class="p">,</span>
                                     <span class="n">Part_Of</span>  <span class="o">=&gt;</span> <span class="n">Externals.Displays</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Display</span> <span class="o">(</span><span class="n">Text</span><span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">String</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State</span> <span class="o">=&gt;</span> <span class="n">Text</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Externals.Secondary_Display</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">System.Storage_Elements</span><span class="p">,</span>
     <span class="n">Externals.Temperature</span><span class="p">,</span>
     <span class="n">Externals.Pressure</span><span class="p">,</span>
     <span class="n">Externals.Main_Display</span><span class="p">,</span>
     <span class="n">Externals.Secondary_Display</span><span class="p">;</span>

<span class="k">package body </span><span class="nf">Externals</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Combined_Inputs</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Externals.Temperature.State</span><span class="p">,</span>
                                             <span class="n">Externals.Pressure.State</span><span class="o">)</span><span class="p">,</span>
                         <span class="c">-- Both Temperature and</span>
                         <span class="c">-- Pressure are inputs only.</span>

                         <span class="n">Displays</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Externals.Main_Display.State</span><span class="p">,</span>
                                      <span class="n">Externals.Secondary_Display.State</span><span class="o">)</span><span class="p">,</span>
                         <span class="c">-- Both Main_Display and</span>
                         <span class="c">-- Secondary_Display are outputs only.</span>

                         <span class="n">Complex_Device</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Saved_Value</span><span class="p">,</span>
                                            <span class="n">Out_Reg</span><span class="p">,</span>
                                            <span class="n">In_Reg</span><span class="o">))</span>
                         <span class="c">-- Complex_Device is a mixture of inputs, outputs and</span>
                         <span class="c">-- non-volatile constituents.</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">Saved_Value</span> <span class="o">:</span> <span class="n">Integer</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c">-- Initialized as required.</span>

   <span class="n">Out_Reg</span> <span class="o">:</span> <span class="n">Integer</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Volatile</span><span class="p">,</span>
          <span class="n">Async_Readers</span><span class="p">,</span>
          <span class="n">Effective_Writes</span><span class="p">,</span> <span class="c">-- Every value written to the port is significant.</span>
          <span class="n">Address</span>  <span class="o">=&gt;</span> <span class="n">System.Storage_Elements.To_Address</span> <span class="o">(</span><span class="mi">16#ACECAFE0#</span><span class="o">)</span><span class="p">;</span>

   <span class="n">In_Reg</span> <span class="o">:</span> <span class="n">Integer</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Volatile</span><span class="p">,</span>
          <span class="n">Async_Writers</span><span class="p">,</span>
          <span class="n">Address</span>  <span class="o">=&gt;</span> <span class="n">System.Storage_Elements.To_Address</span> <span class="o">(</span><span class="mi">16#A11CAFE0#</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Read</span> <span class="o">(</span><span class="n">Combined_Value</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Temperature.State</span><span class="p">,</span> <span class="n">Pressure.State</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Refined_Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Combined_Value</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Temperature.State</span><span class="p">,</span>
                                                 <span class="n">Pressure.State</span><span class="o">))</span>
   <span class="kr">is</span><span class="p"></span>
      <span class="n">Temp</span><span class="p">,</span>
      <span class="n">Press</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
      <span class="n">K</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="o">:=</span> <span class="mi">1234</span><span class="p">;</span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Temperature.Read</span> <span class="o">(</span><span class="n">Temp</span><span class="o">)</span><span class="p">;</span>
      <span class="n">Pressure.Read</span> <span class="o">(</span><span class="n">Press</span><span class="o">)</span><span class="p">;</span>
      <span class="n">Combined_Value</span> <span class="o">:=</span> <span class="n">Press</span> <span class="o">+</span> <span class="n">Temp</span> <span class="o">*</span> <span class="n">K</span><span class="p">;</span><span class="c">-- Some_Function_Of (Temp, Pressure);</span>
   <span class="k">end </span><span class="nf">Read</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Display</span> <span class="o">(</span><span class="n">D_Main</span><span class="p">,</span> <span class="n">D_Secondary</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">String</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Main_Display.State</span><span class="p">,</span>
                                         <span class="n">Secondary_Display.State</span><span class="o">))</span><span class="p">,</span>
          <span class="n">Refined_Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Main_Display.State</span>      <span class="o">=&gt;</span> <span class="n">D_Main</span><span class="p">,</span>
                              <span class="n">Secondary_Display.State</span> <span class="o">=&gt;</span> <span class="n">D_Secondary</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Main_Display.Display</span> <span class="o">(</span><span class="n">D_Main</span><span class="o">)</span><span class="p">;</span>
      <span class="n">Secondary_Display.Display</span> <span class="o">(</span><span class="n">D_Secondary</span><span class="o">)</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Display</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Last_Value_Sent</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="n">Saved_Value</span> <span class="c">-- Refined_Global aspect only</span>
                                        <span class="c">-- refers to a non-volatile</span>
                                        <span class="c">-- constituent.</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="kr">return</span><span class="p"> </span><span class="n">Saved_Value</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Last_Value_Sent</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Output_Value</span> <span class="o">(</span><span class="n">Value</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span>  <span class="o">=&gt;</span> <span class="n">In_Reg</span><span class="p">,</span>
                              <span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">Out_Reg</span><span class="p">,</span>
                              <span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">Saved_Value</span><span class="o">)</span><span class="p">,</span>
     <span class="c">--  Refined_Global aspect refers to both volatile</span>
     <span class="c">--  and non-volatile constituents.</span>

          <span class="n">Refined_Depends</span> <span class="o">=&gt;</span> <span class="o">((</span><span class="n">Out_Reg</span><span class="p">,</span>
                               <span class="n">Saved_Value</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Saved_Value</span><span class="p">,</span>
                                                <span class="n">Value</span><span class="o">)</span><span class="p">,</span>
                              <span class="kr">null</span><span class="p"> </span><span class="o">=&gt;</span> <span class="n">In_Reg</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
      <span class="n">Ready</span>  <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="n">Integer</span> <span class="o">:=</span> <span class="mi">42</span><span class="p">;</span>
      <span class="n">Status</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="kr">if</span><span class="p"> </span><span class="n">Saved_Value</span> <span class="o">/=</span> <span class="n">Value</span> <span class="kr">then</span><span class="p"></span>
         <span class="kr">loop</span><span class="p"></span>
            <span class="n">Status</span> <span class="o">:=</span> <span class="n">In_Reg</span><span class="p">;</span>  <span class="c">-- In_Reg has the property Async_Writers</span>
                               <span class="c">-- and may appear on RHS of assignment</span>
                               <span class="c">-- but not in a condition.</span>
            <span class="kr">exit</span><span class="p"> </span><span class="kr">when</span><span class="p"> </span><span class="n">Status</span> <span class="o">=</span> <span class="n">Ready</span><span class="p">;</span>
         <span class="k">end loop</span><span class="p">;</span>

         <span class="n">Out_Reg</span> <span class="o">:=</span> <span class="n">Value</span><span class="p">;</span>  <span class="c">-- Out_Reg has the property Async_Readers</span>
                            <span class="c">-- and the assigned value will be consumed.</span>
         <span class="n">Saved_Value</span> <span class="o">:=</span> <span class="n">Value</span><span class="p">;</span>  <span class="c">-- Writing to the Out_Reg also results</span>
                                <span class="c">-- in updating Saved_Value.</span>
      <span class="k">end if</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Output_Value</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Externals</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">-- This is a hardware abstraction layer (HAL)</span>
<span class="c">-- which handles input and output streams over serial interfaces</span>
<span class="c">-- and monitors and resets an area of shared memory used</span>
<span class="c">-- as a watchdog.</span>
<span class="k">package </span><span class="nf">HAL</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Abstract_State</span> <span class="o">=&gt;</span>
              <span class="o">((</span><span class="n">FIFO_Status</span>
                  <span class="kr">with</span><span class="p"> </span><span class="n">External</span> <span class="o">=&gt;</span> <span class="n">Async_Writers</span><span class="o">)</span><span class="p">,</span>
               <span class="o">(</span><span class="n">Serial_In</span>
                  <span class="kr">with</span><span class="p"> </span><span class="n">External</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Async_Writers</span><span class="p">,</span>
                                    <span class="n">Effective_Reads</span><span class="o">))</span><span class="p">,</span>
                  <span class="c">-- Each value received is significant</span>
               <span class="o">(</span><span class="n">FIFO_Control</span>
                  <span class="kr">with</span><span class="p"> </span><span class="n">External</span> <span class="o">=&gt;</span> <span class="n">Async_Readers</span><span class="o">)</span><span class="p">,</span>
               <span class="o">(</span><span class="n">Serial_Out</span>
                  <span class="kr">with</span><span class="p"> </span><span class="n">External</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Async_Readers</span><span class="p">,</span>
                                    <span class="n">Effective_Writes</span><span class="o">))</span><span class="p">,</span>
               <span class="o">(</span><span class="n">Wdog_State</span>
                  <span class="kr">with</span><span class="p"> </span><span class="n">External</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Async_Readers</span><span class="p">,</span>
                                    <span class="n">Async_Writers</span><span class="o">)))</span>
<span class="kr">is</span><span class="p"></span>
   <span class="kr">type</span><span class="p"> </span><span class="n">Byte_T</span> <span class="kr">is</span><span class="p"> </span><span class="kr">mod</span><span class="p"> </span><span class="mi">256</span><span class="p">;</span>

   <span class="c">-- This procedure reads the next byte available on</span>
   <span class="c">-- the serial input port using a FIFO buffer.</span>
   <span class="k">procedure </span><span class="nf">Get_Byte</span> <span class="o">(</span><span class="n">A_Byte</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Byte_T</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">Serial_In</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A_Byte</span>    <span class="o">=&gt;</span> <span class="n">Serial_In</span><span class="p">,</span>
                      <span class="n">Serial_In</span> <span class="o">=&gt;</span> <span class="n">Serial_In</span><span class="o">)</span><span class="p">;</span>

   <span class="c">-- This procedure skips input bytes until</span>
   <span class="c">-- the byte matches the given pattern or the input</span>
   <span class="c">-- FIFO is empty.</span>
   <span class="k">procedure </span><span class="nf">Skip_To</span> <span class="o">(</span><span class="n">Pattern</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Byte_T</span><span class="p">;</span> <span class="n">Found</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Boolean</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span>  <span class="o">=&gt;</span> <span class="n">FIFO_Status</span><span class="p">,</span>
                      <span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">Serial_In</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">((</span><span class="n">Found</span><span class="p">,</span>
                       <span class="n">Serial_In</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">FIFO_Status</span><span class="p">,</span>
                                      <span class="n">Pattern</span><span class="p">,</span>
                                      <span class="n">Serial_In</span><span class="o">))</span><span class="p">;</span>

   <span class="c">-- This procedure reads the status of the input and output FIFOs.</span>
   <span class="k">procedure </span><span class="nf">Get_FIFO_Status</span> <span class="o">(</span><span class="n">A_Byte</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Byte_T</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span>  <span class="o">=&gt;</span> <span class="n">FIFO_Status</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A_Byte</span> <span class="o">=&gt;</span> <span class="n">FIFO_Status</span><span class="o">)</span><span class="p">;</span>

   <span class="c">-- This procedure writes a byte to the serial</span>
   <span class="c">-- output port using a FIFO buffer.</span>
   <span class="k">procedure </span><span class="nf">Put_Byte</span> <span class="o">(</span><span class="n">A_Byte</span> <span class="o">:</span> <span class="n">Byte_T</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">Serial_Out</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Serial_Out</span> <span class="o">=&gt;</span> <span class="n">A_Byte</span><span class="o">)</span><span class="p">;</span>


   <span class="c">-- This procedure clears the input FIFO.</span>
   <span class="k">procedure </span><span class="nf">Clear_In_FIFO</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">FIFO_Control</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">FIFO_Control</span> <span class="o">=&gt;</span> <span class="n">null</span><span class="o">)</span><span class="p">;</span>


   <span class="c">-- This procedure clears the output FIFO.</span>
   <span class="k">procedure </span><span class="nf">Clear_Out_FIFO</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">FIFO_Control</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">FIFO_Control</span> <span class="o">=&gt;</span> <span class="n">null</span><span class="o">)</span><span class="p">;</span>


   <span class="c">-- This procedure checks and then resets the status of</span>
   <span class="c">-- the watchdog state.</span>
   <span class="k">procedure </span><span class="nf">Wdog_Timed_Out</span> <span class="o">(</span><span class="n">Result</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Boolean</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">Wdog_State</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Result</span>     <span class="o">=&gt;</span> <span class="n">Wdog_State</span><span class="p">,</span>
                      <span class="n">Wdog_State</span> <span class="o">=&gt;</span> <span class="n">Wdog_State</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">HAL</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">System.Storage_Elements</span><span class="p">;</span>

<span class="k">package body </span><span class="nf">HAL</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Serial_In</span>    <span class="o">=&gt;</span> <span class="n">Read_FIFO</span><span class="p">,</span>
                         <span class="n">Serial_Out</span>   <span class="o">=&gt;</span> <span class="n">Write_FIFO</span><span class="p">,</span>
                         <span class="n">FIFO_Status</span>  <span class="o">=&gt;</span> <span class="n">Status</span><span class="p">,</span>
                         <span class="n">FIFO_Control</span> <span class="o">=&gt;</span> <span class="n">Control</span><span class="p">,</span>
                         <span class="n">Wdog_State</span>   <span class="o">=&gt;</span> <span class="n">Wdog_Shared_memory</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="c">-- Each byte read is significant, it is a sequence of bytes</span>
   <span class="c">-- and so Effective_Reads =&gt; True.</span>
   <span class="n">Read_FIFO</span><span class="o">:</span> <span class="n">Byte_T</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Volatile</span><span class="p">,</span>
          <span class="n">Async_Writers</span><span class="p">,</span>
          <span class="n">Effective_Reads</span><span class="p">,</span>
          <span class="n">Address</span> <span class="o">=&gt;</span> <span class="n">System.Storage_Elements.To_Address</span><span class="o">(</span><span class="mi">16#A1CAFE0#</span><span class="o">)</span><span class="p">;</span>

   <span class="c">-- Each byte written is significant, it is a sequence of bytes</span>
   <span class="c">-- and so Effective_Writes =&gt; True.</span>
   <span class="n">Write_FIFO</span><span class="o">:</span> <span class="n">Byte_T</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Volatile</span><span class="p">,</span>
          <span class="n">Async_Readers</span><span class="p">,</span>
          <span class="n">Effective_Writes</span><span class="p">,</span>
          <span class="n">Address</span> <span class="o">=&gt;</span> <span class="n">System.Storage_Elements.To_Address</span><span class="o">(</span><span class="mi">16#A2CAFE0#</span><span class="o">)</span><span class="p">;</span>

   <span class="c">-- The read of the FIFO status is a snap shot of the current status</span>
   <span class="c">-- individual reads are independent of other reads of the FIFO status</span>
   <span class="c">-- and so Effective_Reads =&gt; False.</span>
   <span class="n">Status</span><span class="o">:</span> <span class="n">Byte_T</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Volatile</span><span class="p">,</span>
          <span class="n">Async_Writers</span><span class="p">,</span>
          <span class="n">Address</span> <span class="o">=&gt;</span> <span class="n">System.Storage_Elements.To_Address</span><span class="o">(</span><span class="mi">16#A3CAFE0#</span><span class="o">)</span><span class="p">;</span>

   <span class="c">-- The value written to the FIFO control register are independent</span>
   <span class="c">-- of other value written to the control register and so</span>
   <span class="c">-- Effective_Writes =&gt; False.</span>
   <span class="n">Control</span><span class="o">:</span> <span class="n">Byte_T</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Volatile</span><span class="p">,</span>
          <span class="n">Async_Readers</span><span class="p">,</span>
          <span class="n">Address</span> <span class="o">=&gt;</span> <span class="n">System.Storage_Elements.To_Address</span><span class="o">(</span><span class="mi">16#A4CAFE0#</span><span class="o">)</span><span class="p">;</span>

   <span class="c">-- This is a bidirectional port but individual reads and writes</span>
   <span class="c">-- are independent and so Effective_Reads and Effective_Writes</span>
   <span class="c">-- are both False.</span>
   <span class="n">Wdog_Shared_Memory</span> <span class="o">:</span> <span class="n">Boolean</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Volatile</span><span class="p">,</span>
          <span class="n">Async_Writers</span><span class="p">,</span>
          <span class="n">Async_Readers</span><span class="p">,</span>
          <span class="n">Address</span> <span class="o">=&gt;</span> <span class="n">System.Storage_Elements.To_Address</span><span class="o">(</span><span class="mi">16#A5CAFE0#</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Get_Byte</span> <span class="o">(</span><span class="n">A_Byte</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Byte_T</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span>    <span class="o">=&gt;</span> <span class="n">Read_FIFO</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Refined_Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A_Byte</span>    <span class="o">=&gt;</span> <span class="n">Read_FIFO</span><span class="p">,</span>
                              <span class="n">Read_FIFO</span> <span class="o">=&gt;</span> <span class="n">Read_FIFO</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">A_Byte</span> <span class="o">:=</span> <span class="n">Read_FIFO</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Get_Byte</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Skip_To</span> <span class="o">(</span><span class="n">Pattern</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Byte_T</span><span class="p">;</span> <span class="n">Found</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Boolean</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span>  <span class="o">=&gt;</span> <span class="n">Status</span><span class="p">,</span>
                              <span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">Read_FIFO</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Refined_Depends</span> <span class="o">=&gt;</span> <span class="o">((</span><span class="n">Found</span><span class="p">,</span>
                               <span class="n">Read_FIFO</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Status</span><span class="p">,</span>
                                              <span class="n">Pattern</span><span class="p">,</span>
                                              <span class="n">Read_FIFO</span><span class="o">))</span>
   <span class="kr">is</span><span class="p"></span>
      <span class="n">Read_FIFO_Empty</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="n">Byte_T</span> <span class="o">:=</span> <span class="mi">16#010#</span><span class="p">;</span>
      <span class="n">Current_Status</span> <span class="o">:</span> <span class="n">Byte_T</span><span class="p">;</span>
      <span class="n">Next_Byte</span> <span class="o">:</span> <span class="n">Byte_T</span><span class="p">;</span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Found</span> <span class="o">:=</span> <span class="kc">False</span><span class="p">;</span>
      <span class="kr">loop</span><span class="p"></span>
         <span class="n">Get_FIFO_Status</span> <span class="o">(</span><span class="n">Current_Status</span><span class="o">)</span><span class="p">;</span>
         <span class="kr">exit</span><span class="p"> </span><span class="kr">when</span><span class="p"> </span><span class="n">Current_Status</span> <span class="o">=</span> <span class="n">Read_FIFO_Empty</span><span class="p">;</span>
         <span class="n">Get_Byte</span> <span class="o">(</span><span class="n">Next_Byte</span><span class="o">)</span><span class="p">;</span>
         <span class="kr">if</span><span class="p"> </span><span class="n">Next_Byte</span> <span class="o">=</span> <span class="n">Pattern</span> <span class="kr">then</span><span class="p"></span>
            <span class="n">Found</span> <span class="o">:=</span> <span class="kc">True</span><span class="p">;</span>
            <span class="kr">exit</span><span class="p">;</span>
         <span class="k">end if</span><span class="p">;</span>
      <span class="k">end loop</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Skip_To</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Get_FIFO_Status</span> <span class="o">(</span><span class="n">A_Byte</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Byte_T</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span>  <span class="o">=&gt;</span> <span class="n">Status</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Refined_Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A_Byte</span> <span class="o">=&gt;</span> <span class="n">Status</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">A_Byte</span> <span class="o">:=</span> <span class="n">Status</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Get_FIFO_Status</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Put_Byte</span> <span class="o">(</span><span class="n">A_Byte</span> <span class="o">:</span> <span class="n">Byte_T</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">Write_FIFO</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Refined_Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Write_FIFO</span> <span class="o">=&gt;</span> <span class="n">A_Byte</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Write_FIFO</span> <span class="o">:=</span> <span class="n">A_Byte</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Put_Byte</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Clear_In_FIFO</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">Control</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Refined_Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Control</span> <span class="o">=&gt;</span> <span class="n">null</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
      <span class="n">In_FIFO_Clear</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="n">Byte_T</span> <span class="o">:=</span> <span class="mi">16#010#</span><span class="p">;</span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Control</span> <span class="o">:=</span> <span class="n">In_FIFO_Clear</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Clear_In_FIFO</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Clear_Out_FIFO</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">Control</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Refined_Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Control</span> <span class="o">=&gt;</span> <span class="n">null</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
      <span class="n">Out_FIFO_Clear</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="n">Byte_T</span> <span class="o">:=</span> <span class="mi">16#020#</span><span class="p">;</span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Control</span> <span class="o">:=</span> <span class="n">Out_FIFO_Clear</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Clear_Out_FIFO</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Wdog_Timed_Out</span> <span class="o">(</span><span class="n">Result</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Boolean</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">Wdog_Shared_Memory</span><span class="o">)</span><span class="p">,</span>
          <span class="n">Refined_Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Result</span>             <span class="o">=&gt;</span> <span class="n">Wdog_Shared_Memory</span><span class="p">,</span>
                              <span class="n">Wdog_Shared_memory</span> <span class="o">=&gt;</span> <span class="n">Wdog_Shared_Memory</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
      <span class="n">Watch_Dog_OK</span> <span class="o">:</span> <span class="n">Boolean</span><span class="p">;</span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Watch_Dog_OK</span> <span class="o">:=</span> <span class="n">Wdog_Shared_Memory</span><span class="p">;</span>
      <span class="kr">if</span><span class="p"> </span><span class="n">Watch_Dog_OK</span> <span class="kr">then</span><span class="p"></span>
         <span class="c">-- Retrigger the watch dog timer</span>
         <span class="n">Wdog_shared_memory</span> <span class="o">:=</span> <span class="kc">True</span><span class="p">;</span>
         <span class="c">-- It has not timed out.</span>
         <span class="n">Result</span> <span class="o">:=</span> <span class="kc">False</span><span class="p">;</span>
      <span class="kr">else</span><span class="p"></span>
         <span class="n">Result</span> <span class="o">:=</span> <span class="kc">True</span><span class="p">;</span>
      <span class="k">end if</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Wdog_Timed_Out</span><span class="p">;</span>

<span class="k">end </span><span class="nf">HAL</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">HAL</span><span class="p">;</span>
<span class="kr">use</span><span class="p"> </span><span class="kr">type</span><span class="p"> </span><span class="n">HAL.Byte_T</span><span class="p">;</span>

<span class="k">procedure </span><span class="nf">Main_Hal</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">SPARK_Mode</span><span class="p">,</span>
       <span class="n">Global</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Input</span>  <span class="o">=&gt;</span> <span class="n">HAL.FIFO_Status</span><span class="p">,</span>
                   <span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">HAL.Serial_In</span><span class="p">,</span>
                              <span class="n">HAL.Wdog_State</span><span class="o">)</span><span class="p">,</span>
                   <span class="n">Output</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">HAL.FIFO_Control</span><span class="p">,</span>
                              <span class="n">HAL.Serial_Out</span><span class="o">))</span><span class="p">,</span>
       <span class="n">Depends</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">HAL.Serial_In</span>    <span class="o">=&gt;+</span> <span class="o">(</span><span class="n">HAL.FIFO_Status</span><span class="p">,</span>
                                         <span class="n">HAL.Wdog_State</span><span class="o">)</span><span class="p">,</span>
                   <span class="n">HAL.Serial_Out</span>   <span class="o">=&gt;</span>  <span class="o">(</span><span class="n">HAL.Serial_In</span><span class="p">,</span>
                                         <span class="n">HAL.FIFO_Status</span><span class="p">,</span>
                                         <span class="n">HAL.Wdog_State</span><span class="o">)</span><span class="p">,</span>
                   <span class="n">HAL.Wdog_State</span>   <span class="o">=&gt;+</span> <span class="n">HAL.FIFO_Status</span><span class="p">,</span>
                   <span class="n">HAL.FIFO_Control</span> <span class="o">=&gt;</span>  <span class="n">null</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">Wdog_Timed_Out</span><span class="p">,</span> <span class="n">Found</span> <span class="o">:</span> <span class="n">Boolean</span><span class="p">;</span>
   <span class="n">A_Byte</span>                <span class="o">:</span> <span class="n">HAL.Byte_T</span><span class="p">;</span>
<span class="kr">begin</span><span class="p"></span>
   <span class="n">HAL.Clear_Out_FIFO</span><span class="p">;</span>

   <span class="c">-- The start of the data is marked by the sequence 16#5555#</span>
   <span class="c">-- Skip until we find the start of the message or the FIFO is empty.</span>
   <span class="kr">loop</span><span class="p"></span>
      <span class="n">HAL.Wdog_Timed_Out</span> <span class="o">(</span><span class="n">Wdog_Timed_Out</span><span class="o">)</span><span class="p">;</span>
      <span class="kr">exit</span><span class="p"> </span><span class="kr">when</span><span class="p"> </span><span class="n">Wdog_Timed_Out</span><span class="p">;</span>
      <span class="n">HAL.Skip_To</span> <span class="o">(</span><span class="mi">16#55#</span><span class="p">,</span> <span class="n">Found</span><span class="o">)</span><span class="p">;</span>
      <span class="kr">exit</span><span class="p"> </span><span class="kr">when</span><span class="p"> </span><span class="kr">not</span><span class="p"> </span><span class="n">Found</span><span class="p">;</span>
      <span class="n">HAL.Get_Byte</span> <span class="o">(</span><span class="n">A_Byte</span><span class="o">)</span><span class="p">;</span>
      <span class="kr">exit</span><span class="p"> </span><span class="kr">when</span><span class="p"> </span><span class="n">A_Byte</span> <span class="o">=</span> <span class="mi">16#55#</span><span class="p">;</span>
   <span class="k">end loop</span><span class="p">;</span>

   <span class="kr">if</span><span class="p"> </span><span class="n">Found</span> <span class="kr">and</span><span class="p"> </span><span class="kr">not</span><span class="p"> </span><span class="n">Wdog_Timed_Out</span> <span class="kr">then</span><span class="p"></span>
      <span class="c">-- We have found the start of the data</span>

      <span class="c">-- As long as the watchdog doesn&#39;t time out, move data</span>
      <span class="c">-- from Serial_In to Serial_Out.</span>
      <span class="kr">loop</span><span class="p"></span>
         <span class="n">HAL.Wdog_Timed_Out</span> <span class="o">(</span><span class="n">Wdog_Timed_Out</span><span class="o">)</span><span class="p">;</span>

         <span class="kr">exit</span><span class="p"> </span><span class="kr">when</span><span class="p"> </span><span class="n">Wdog_Timed_Out</span><span class="p">;</span>

         <span class="n">HAL.Get_Byte</span> <span class="o">(</span><span class="n">A_Byte</span><span class="o">)</span><span class="p">;</span>
         <span class="n">HAL.Put_Byte</span> <span class="o">(</span><span class="n">A_Byte</span><span class="o">)</span><span class="p">;</span>
         <span class="k">end loop</span><span class="p">;</span>
   <span class="k">end if</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Main_Hal</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
</div>
<div class="section" id="private-types-and-private-extensions">
<h2>7.3. Private Types and Private Extensions<a class="headerlink" href="#private-types-and-private-extensions" title="Permalink to this headline">¶</a></h2>
<p>No extensions or restrictions.</p>
<div class="section" id="private-operations">
<h3>7.3.1. Private Operations<a class="headerlink" href="#private-operations" title="Permalink to this headline">¶</a></h3>
<p>No extensions or restrictions.</p>
</div>
<div class="section" id="type-invariants">
<span id="id5"></span><h3>7.3.2. Type Invariants<a class="headerlink" href="#type-invariants" title="Permalink to this headline">¶</a></h3>
<p>[Type invariants are supported in SPARK, but are subject to restrictions
which imply that if a type invariant is specified for
a type T, then any new verification conditions which this introduces outside
of the package which defines T are trivially satisified.
These restrictions ensure that any object or value of type T (or a
descendant thereof) which can be named outside of that package
will satisfy the invariant and so, for example, could not fail the runtime
check associated with passing that object or value as a parameter in call
to a procedure for which Ada requires runtime checking of the invariant
(which, in turn, means that the verification condition corresponding
to that runtime check is trivally satisfied).
In order to accomplish this goal, verification conditions for
type invariants are introduced in several contexts where Ada does
not define corresponding runtime checks.]</p>
<p>[As a consequence of this approach, adding or deleting a type invariant for a
private type should have little or no impact on users
outside of the package defining the private type; on the other hand,
such a change could have a great deal of impact on the verification conditions
generated for the implementation of the private type and its operations.]</p>
<p>[Just as a reminder to the reader, text enclosed in square brackets
is non-normative expository text. This is true everywhere in the SPARK
RM, but there is a lot of such expository text in this section and we
don&#8217;t want anyone to be confused about what is strictly part of the
language definition and what is not.]</p>
<p class="centered">
<strong><strong>Static Semantics</strong></strong></p><ol class="arabic">
<li><p class="first">For a given type-invariant bearing type T, a <em>boundary</em> subprogram is a
subprogram which is declared inside the immediate scope of type T, and
visible outside the immediate scope of T.</p>
<p>The point at which a generic is declared plays no role in determining
whether a subprogram declared as or within an instantiation of that generic
is a boundary subprogram.</p>
</li>
</ol>
<p class="centered">
<strong><strong>Legality Rules</strong></strong></p><ol class="arabic simple" id="tu-type-invariants-02" start="2">
<li>The aspect Type_Invariant may be specified in SPARK, but only for
the completion of a private type. [In other words, the Type_Invariant
aspect shall not be specified for a partial view of a type, nor for the
completion of a private extension.]
The aspect Type_Invariant&#8217;Class is not in SPARK.</li>
</ol>
<ol class="arabic simple" id="tu-type-invariants-03" start="3">
<li>[A Type_Invariant expression shall not have a variable input;
see <a class="reference internal" href="names-and-expressions.html#expressions"><span class="std std-ref">Expressions</span></a> for the statement of this rule.]</li>
</ol>
<ol class="arabic simple" id="tu-type-invariants-04" start="4">
<li>A Type_Invariant shall not apply to an effectively volatile type.</li>
</ol>
<p class="centered">
<strong><strong>Verification Rules</strong></strong></p><p>In Ada RM 7.3.2, Ada defines the points at which runtime checking of
type invariants is performed. In SPARK, these rules (or, more precisely,
the verification conditions corresponding to these Ada dynamic semantics
rules) are extended in several ways. In effect, verification conditions
are generated as if Ada defined additional dynamic type invariant checking at
several points (described below) where, in fact, Ada defines no such checks.
[This means that when we talk below about extending invariant checks,
we are only talking about generating additional verification conditions;
we are not talking about any changes in a program&#8217;s behavior at run-time.]</p>
<ol class="arabic simple" id="tu-type-invariants-05" start="5">
<li>The type invariant expression for a type T shall not include a call
to a boundary function for type T. [This often means that a type
invariant expression cannot contain calls to functions declared in
the visible part of the package in question.]</li>
</ol>
<p id="tu-type-invariants-ram-01"><strong>Ramification:</strong> It is a consequence of other rules that upon entry
to a boundary subprogram for a type T, every part of every input that
is of type T can be assumed to satisfy T&#8217;s invariant.</p>
<ol class="arabic simple" id="tu-type-invariants-06" start="6">
<li>Upon returning from a boundary subprogram for a type T, a
verification condition is introduced for every part of every output
that is of type T (or a descendant thereof), to ensure that this part
satisfies T&#8217;s invariant.</li>
</ol>
<ol class="arabic simple" id="tu-type-invariants-07" start="7">
<li>For every subprogram declared inside the immediate scope of type T,
the preceding rule [and ramification] also apply to [any parts of]
any global input or output and to [any parts of] any tagged
subprogram parameter.</li>
</ol>
<ol class="arabic simple" id="tu-type-invariants-08" start="8">
<li>When calling a boundary subprogram for a type T or a subprogram
declared outside of the immediate scope of T, a verification
condition is introduced for every part of every input that is of type T
(or a descendant thereof), to ensure that this part satisfies
T&#8217;s invariant. [This
verification condition is trivially satisfied if the caller is
outside of the immediate scope of T, or if the input in question is
subject to rule 5 and constant for the caller. The idea here is to
prevent invariant-violating values from &#8220;leaking out&#8221;.]</li>
</ol>
<p id="tu-type-invariants-ram-02"><strong>Ramification:</strong> It is a consequence of other rules that upon return
from a boundary subprogram for a type T or a subprogram declared
outside of the immediate scope of T, every part of every output that
is of type T (or a descendant thereof) can be assumed to satisfy T&#8217;s invariant.</p>
<ol class="arabic simple" id="tu-type-invariants-09" start="9">
<li>For every subprogram, the preceding rule [and ramification] also
apply to [any parts of] any global input or output and to [any
parts of] any tagged subprogram parameter. [The verification
condition of rule 6 is trivially satisfied if the caller is outside
of the immediate scope of T, or if the input in question is subject
to rule 4 and constant for the caller.]</li>
</ol>
<ol class="arabic simple" id="tu-type-invariants-10" start="10">
<li>At the end of the elaboration of a package (i.e., at the point where the
Initial_Condition, if any, is checked) a verification condition is
introduced for the objects (both variables and constants) declared within
the package. [If one chooses to think of package elaboration as being
performed by a notional parameterless &#8220;elaboration&#8221; subprogram, then this
rule (very roughly speaking) says that the global outputs of this notional
subprogram follow much the same rules as for other subprograms.]</li>
</ol>
<p id="tu-type-invariants-ram-03"><strong>Ramification:</strong> In determining whether a dispatching call is a call
to a boundary subprogram or to a subprogram declared outside of the
immediate scope of T, the statically named callee is used.</p>
<p id="tu-type-invariants-ram-04"><strong>Ramification:</strong> It is possible that the underlying tag of a tagged
object (at runtime) may differ from the tag of its nominal (compile
time) type. Suppose that an object X is (statically) of type T1 (or
T1&#8217;Class) but has T2&#8217;Tag as its underlying tag, and that T2 has one or
more components which are not components of T1. Ada does not define
runtime checking of type invariants for such &#8220;hidden&#8221; components of
parameters. The rules about tagged inputs and outputs in rules 6 and 8
are introduced in order to deal with technical difficulties that would
otherwise arise in the treatment of these hidden components.</p>
</div>
<div class="section" id="default-initial-condition-aspects">
<span id="default-initial-condition-aspect"></span><h3>7.3.3. Default_Initial_Condition Aspects<a class="headerlink" href="#default-initial-condition-aspects" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>The Default_Initial_Condition aspect is introduced by an aspect_specification
where the aspect_mark is Default_Initial_Condition. The aspect may be
specified only as part of the aspect_specification of a
<code class="docutils literal"><span class="pre">private_type_declaration</span></code>.
The <code class="docutils literal"><span class="pre">aspect_definition</span></code>, if any, of such an aspect specification
shall be either a null literal or a <em>Boolean_</em><code class="docutils literal"><span class="pre">expression</span></code>.</p>
<p>The <code class="docutils literal"><span class="pre">aspect_definition</span></code> may be omitted; this is semantically
equivalent to specifying a static <em>Boolean_</em><code class="docutils literal"><span class="pre">expression</span></code> having the
value True.</p>
<p>An aspect specification of &#8220;null&#8221; indicates that the partial view of the
type does not define full default initialization (see <a class="reference internal" href="declarations-and-types.html#declarations"><span class="std std-ref">Declarations</span></a>).
[The full view of the type might or might not define full default
initialization.]</p>
<p>Conversely, an aspect specification of a <em>Boolean_</em><code class="docutils literal"><span class="pre">expression</span></code> indicates
that the partial view of the type does define full default initialization.
In this case, the completion of the private type shall define full
default initialization. [Implementations may provide a mechanism for
suppressing enforcement of this rule as described; the burden is then on
the user to ensure that this does not result in undetected uses of
uninitialized variables.]</p>
<p>Unlike the null literal case, this case has associated dynamic semantics.
The <em>Boolean_</em><code class="docutils literal"><span class="pre">expression</span></code> (which might typically mention the current
instance of the type, although this is not required) is an assertion
which is checked (at run time) after any object of the given type (or of
any descendant of the given type for which the specified aspect is
inherited and not overridden), is &#8220;initialized by
default&#8221; (see Ada RM 3.3.1).</p>
<p>The <em>Boolean_</em><code class="docutils literal"><span class="pre">expression</span></code>, if any, causes freezing in the
same way as the <code class="docutils literal"><span class="pre">default_expression</span></code> of a <code class="docutils literal"><span class="pre">component_declaration</span></code>.
[If the expresion is non-static, this means that the expression does not
cause freezing where it occurs, but instead when an object of the type
is initialized by default.]</p>
<p>Default_Initial_Condition assertion is an assertion aspect, which means
that it may be used in an Assertion_Policy pragma.</p>
<p>Within the Boolean expression of the Default_Initial_Condition aspect of
a tagged type T, a name that denotes the current instance of the
tagged type is interpreted as though it had a (notional) type NT
that is a formal derived type whose ancestor type is T, with
directly visible primitive operations. [This name resolution rule
is similar to the &#8220;notional formal derived type&#8221; name resolution
rule introduced in Ada RM 6.1.1 for certain subexpressions of
class-wide precondition and postcondition expressions.]
Any operations within a Default_Initial_Condition expression that
were resolved in this way (i.e., as primitive operations of the (notional)
formal derived type NT), are in the evaluation of the the expression
(i.e., at run-time) bound to the corresponding operations of the type of the
object being &#8220;initialized by default&#8221; (see Ada RM 3.3.1).</p>
</div></blockquote>
</div>
</div>
<div class="section" id="deferred-constants">
<h2>7.4. Deferred Constants<a class="headerlink" href="#deferred-constants" title="Permalink to this headline">¶</a></h2>
<p>No extensions or restrictions.</p>
</div>
<div class="section" id="limited-types">
<h2>7.5. Limited Types<a class="headerlink" href="#limited-types" title="Permalink to this headline">¶</a></h2>
<p>No extensions or restrictions.</p>
</div>
<div class="section" id="assignment-and-finalization">
<h2>7.6. Assignment and Finalization<a class="headerlink" href="#assignment-and-finalization" title="Permalink to this headline">¶</a></h2>
<p class="centered">
<strong><strong>Legality Rules</strong></strong></p><ol class="arabic simple" id="tu-assignment-and-finalization-01">
<li>Controlled types are not permitted in SPARK 2014.</li>
</ol>
</div>
<div class="section" id="elaboration-issues">
<span id="etu-assignment-and-finalization"></span><span id="id6"></span><h2>7.7. Elaboration Issues<a class="headerlink" href="#elaboration-issues" title="Permalink to this headline">¶</a></h2>
<p>SPARK 2014 imposes a set of restrictions which ensure that a
call to a subprogram cannot occur before the body of the
subprogram has been elaborated. The success of the runtime
elaboration check associated with a call is guaranteed by
these restrictions and so the verification condition associated with
such a check is trivially discharged. Similar restrictions
are imposed to prevent the reading of uninitialized library-level
variables during library unit elaboration, and to prevent
instantiation of a generic before its body has been elaborated.
Finally, restrictions are imposed in order to ensure that the
Initial_Condition (and Initializes aspect) of a library-level package
can be meaningfully used.</p>
<p>These restrictions are described in this section. Because all of these
elaboration-related issues are treated similarly, they are
discussed together in one section.</p>
<p>Note that throughout this section an implicit call
(e.g., one associated with default initialization of an
object or with a defaulted parameter in a call) is treated
in the same way as an explicit call, and an explicit call
which is unevaluated at the point where it (textually) occurs is
ignored at that point (but is not ignored later at a point
where it is evaluated). This is similar to the treatment of
expression evaluation in Ada&#8217;s freezing rules.
This same principle applies to the rules about reading
global variables discussed later in this section.</p>
<p class="centered">
<strong><strong>Static Semantics</strong></strong></p><ol class="arabic simple" id="tu-nt-elaboration-issues-01">
<li>A call which occurs within the same compilation_unit as the subprogram_body
of the callee is said to be an <em>intra-compilation_unit call</em>.</li>
</ol>
<ol class="arabic" id="tu-nt-elaboration-issues-02" start="2">
<li><p class="first">A construct (specifically, a call to a subprogram or a read or write
of a variable) which occurs in elaboration code for a library-level package
is said to be <em>executable during elaboration</em>. If a subprogram call is
executable during elaboration and the callee&#8217;s body occurs in the same
compilation_unit as the call, then any constructs occurring within that body
are also executable during elaboration. [If a construct is executable during
elaboration, this means that it could be executed during the elaboration of
the enclosing library unit and is subject to certain restrictions described
below.]</p>
<p>For a given library unit L1 and a given distinct library unit&#8217;s spec or body
L2 depending on L1 through a chain of <code class="docutils literal"><span class="pre">with_clauses</span></code>, the elaboration of
the body of L1 is said to be <em>known to precede</em> the elaboration of L2 if
either:</p>
<ol class="loweralpha simple">
<li>L2 references L1 in an Elaborate or Elaborate_All pragma; or</li>
<li>L1&#8217;s Elaborate_Body aspect is True; or</li>
<li>L1 does not require a body (the terminology is a little odd in this
case because L1 has no body); or</li>
<li>L1 is preelaborated and L2&#8217;s library unit is not; or</li>
<li>L2 semantically depends on some library_item L3 such that the
elaboration of the body of L1 is known to precede the
elaboration of L3.
[See Ada RM 10.1.1 for definition of semantic dependence.]</li>
</ol>
</li>
</ol>
<p class="centered" id="etu-elaboration-issues-ss">
<strong><strong>Legality Rules</strong></strong></p><ol class="arabic simple" id="tu-nt-elaboration-issues-03" start="3">
<li>SPARK 2014 requires that an intra-compilation_unit call which is
executable during elaboration shall occur after a certain point in the unit
(described below) where the subprogram&#8217;s completion is known to have been
elaborated. The portion of the unit following this point and extending
to the start of the completion of the subprogram is defined to
be the <em>early call region</em> for the subprogram. An intra-compilation_unit
call which is executable during elaboration and which occurs (statically)
before the start of the completion of the callee shall occur within the
early call region of the callee.</li>
</ol>
<ol class="arabic" id="tu-nt-elaboration-issues-04" start="4">
<li><p class="first">The start of the early call region is obtained by starting at the
subprogram&#8217;s completion (typically a subprogram_body) and then traversing
the preceding constructs in reverse elaboration order until
a non-preelaborable statement/declarative_item/pragma
is encountered. The early call region starts immediately after this
non-preelaborable construct (or at the beginning of the enclosing block
(or library unit package spec or body) if no such non-preelaborable construct
is found).</p>
<p>[The idea here is that once elaboration reaches the start of the early call
region, there will be no further expression evaluation or statement
execution (and, in particular, no further calls) before the subprogram_body
has been elaborated because all elaborable constructs that will be elaborated
in that interval will be preelaborable. Hence, any calls that occur
statically after this point cannot occur dynamically before the elaboration
of the subprogram body.]</p>
<p>[These rules allow this example</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Pkg</span> <span class="kr">is</span><span class="p"></span>
   <span class="o">...</span>
   <span class="k">procedure </span><span class="nf">P</span><span class="p">;</span>
   <span class="k">procedure </span><span class="nf">Q</span><span class="p">;</span>
   <span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span> <span class="o">:=</span> <span class="n">Some_Function_Call</span><span class="p">;</span> <span class="c">-- not preelaborable</span>
   <span class="k">procedure </span><span class="nf">P</span> <span class="kr">is</span><span class="p"> </span><span class="o">...</span> <span class="kr">if</span><span class="p"> </span><span class="n">Blap</span> <span class="kr">then</span><span class="p"> </span><span class="n">Q</span><span class="p">;</span> <span class="k">end if</span><span class="p">;</span> <span class="o">...</span> <span class="k">end </span><span class="nf">P</span><span class="p">;</span>
   <span class="k">procedure </span><span class="nf">Q</span> <span class="kr">is</span><span class="p"> </span><span class="o">...</span> <span class="kr">if</span><span class="p"> </span><span class="n">Blaq</span> <span class="kr">then</span><span class="p"> </span><span class="n">P</span><span class="p">;</span> <span class="k">end if</span><span class="p">;</span> <span class="o">...</span> <span class="k">end </span><span class="nf">Q</span><span class="p">;</span>
<span class="kr">begin</span><span class="p"></span>
   <span class="n">P</span><span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>even though the call to Q precedes the body of Q. The early call region
for either P or Q begins immediately after the declaration of X.
Note that because the call to P is executable during elaboration, so
is the call to Q.]</p>
</li>
</ol>
<ol class="arabic simple" id="tu-nt-elaboration-issues-05" start="5">
<li>For purposes of the above rules, a subprogram completed by a
renaming-as-body is treated as though it were a wrapper
which calls the renamed subprogram (as described in Ada RM 8.5.4(7.1/1)).
[The notional &#8220;call&#8221; occuring in this wrapper is then subject to the
above rules, like any other call.]</li>
</ol>
<ol class="arabic" id="tu-nt-elaboration-issues-06" start="6">
<li><p class="first">If an instance of a generic occurs in the same compilation_unit as the
body of the generic, the body must precede the instance.</p>
<p>[If this rule
were only needed in order to avoid elaboration check failures, a similar
rule to the rule for calls could be defined. This stricter rule is used
in order to avoid having to cope with use-before-definition, as in</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="kr">generic</span><span class="p"></span>
<span class="k">package </span><span class="nf">G</span> <span class="kr">is</span><span class="p"></span>
   <span class="o">...</span>
<span class="k">end </span><span class="nf">G</span><span class="p">;</span>

<span class="k">procedure </span><span class="nf">Proc</span> <span class="kr">is</span><span class="p"></span>
   <span class="k">package </span><span class="nf">I</span> <span class="kr">is</span><span class="p"> </span><span class="kr">new</span><span class="p"> </span><span class="n">G</span><span class="p">;</span> <span class="c">-- expansion of I includes references to X</span>
<span class="kr">begin</span><span class="p"> </span><span class="o">...</span> <span class="p">;</span> <span class="kr">end</span><span class="p">;</span>

<span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>

<span class="k">package body </span><span class="nf">G</span> <span class="kr">is</span><span class="p"></span>
   <span class="o">...</span> <span class="o">&lt;</span><span class="n">uses</span> <span class="kr">of</span><span class="p"> </span><span class="n">X</span><span class="o">&gt;</span> <span class="o">...</span>
<span class="k">end </span><span class="nf">G</span><span class="p">;</span>
</pre></div>
</div>
<p>This stricter rule applies even if the declaration of the instantiation
is not &#8220;executable during elaboration&#8221;].</p>
</li>
</ol>
<ol class="arabic simple" id="tu-nt-elaboration-issues-07" start="7">
<li>In the case of a dispatching call, the subprogram_body mentioned
in the above rules is that (if any) of the statically denoted callee.</li>
</ol>
<ol class="arabic" id="tu-nt-elaboration-issues-08" start="8">
<li><p class="first">The first freezing point of a tagged type shall occur within the
early call region of each of its overriding primitive operations.</p>
<p>[This rule is needed to prevent a dispatching call before the body
of the (dynamic, not static) callee has been elaborated.
The idea here is that after the freezing point it would be
possible to declare an object of the type and then use it as a controlling
operand in a dispatching call to a primitive operation of an ancestor type.
No analysis is performed to identify scenarios where this is not the case,
so conservative rules are adopted.]</p>
<p>[Ada ensures that the freezing point of a tagged type will always occur after
both the completion of the type and the declarations of each of its primitive
subprograms; the freezing point of any type will occur before the
declaration of any objects of the type or the evaluation of any
expressions of the type. This is typically all that one needs to know about
freezing points in order to understand how the above rule applies to a
particular example.]</p>
</li>
</ol>
<ol class="arabic" id="tu-nt-elaboration-issues-09" start="9">
<li><p class="first">For purposes of defining the early call region, the specification and body
of a library unit package whose Elaborate_Body aspect is True are treated as
if they both belonged to some enclosing declaration list with the body
immediately following the specification. This means that the early call
region in which a call is permitted can span the specification/body boundary.</p>
<p>This is important for tagged type declarations.</p>
</li>
</ol>
<ol class="arabic simple" id="tu-nt-elaboration-issues-10" start="10">
<li>For each call that is executable during elaboration for a given
library unit package spec or body, there are two cases: it is
(statically) a call to a subprogram whose completion is in the
current compilation_unit (or in a preelaborated unit), or it is not.
In the latter case, an Elaborate_All pragma shall be provided to ensure
that the given library unit spec or body will not be elaborated
until after the complete semantic closure of the unit in which
the (statically denoted) callee is declared.</li>
</ol>
<ol class="arabic simple" id="tu-nt-elaboration-issues-11" start="11">
<li>For an instantiation of a generic package (excluding a bodiless generic
package) which does not occur in the same compilation unit as the generic
body, the same rules apply as described
above for a call (i.e., an Elaborate_All pragma is required).
For an instantiation of a generic subprogram which does not occur in
the same compilation unit as the generic body, the same rules also
apply except that only an Elaborate (as opposed to an Elaborate_All)
pragma is required.</li>
</ol>
<ol class="arabic simple" id="tu-nt-elaboration-issues-12" start="12">
<li>An implementation is permitted to accept constructs which
violate the preceding rules in this section (e.g., an
implementation might choose to behave, for purposes of defining
an early call region, as though some non-preelaborable construct
is preelaborable), but only if the
implementation is able to statically ensure that accepting
these constructs does not introduce the possibility of
failing an elaboration check (either for a call or for
an instantiation), reading an uninitialized variable, or
unsafe reliance on a package&#8217;s Initial_Condition. [If an implementation
chooses to take advantage of this permission, then the burden
is entirely on the implementation to &#8220;get it right&#8221;.]</li>
</ol>
<p id="etu-elaboration-issues-lr">[These rules correctly prohibit the following example:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">P</span> <span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">F</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span><span class="p">;</span>
   <span class="n">Flag</span> <span class="o">:</span> <span class="n">Boolean</span> <span class="o">:=</span> <span class="n">F</span><span class="p">;</span> <span class="c">-- would fail elaboration checks</span>
<span class="kr">end</span><span class="p">;</span> <span class="c">--]</span>
</pre></div>
</div>
<p class="centered">
<strong><strong>Examples</strong></strong></p><div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">function </span><span class="nf">Times_2</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">is</span><span class="p"></span>
<span class="kr">begin</span><span class="p"></span>
   <span class="kr">return</span><span class="p"> </span><span class="mi">2</span> <span class="o">*</span> <span class="n">X</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Times_2</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">Times_2</span><span class="p">;</span>

<span class="k">package </span><span class="nf">Intra_Unit_Elaboration_Order_Examples</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">Initializes</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
   <span class="kr">pragma</span><span class="p"> </span><span class="n">Elaborate_Body</span><span class="p">;</span>  <span class="c">--  Ensures body of package is elaborated</span>
                           <span class="c">--  immediately after its declaration</span>
   <span class="k">procedure </span><span class="nf">P</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span> <span class="c">--  P and hence Q are executable during</span>
   <span class="k">procedure </span><span class="nf">Q</span> <span class="o">(</span><span class="n">J</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span> <span class="c">--  elaboration as P is called in the</span>
                                     <span class="c">--  package body</span>

   <span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span> <span class="o">:=</span> <span class="n">Times_2</span> <span class="o">(</span><span class="mi">10</span><span class="o">)</span><span class="p">;</span>  <span class="c">--  Not preelaborable</span>
                                 <span class="c">--  The early call region begins here</span>
                                 <span class="c">--  and extends into the package body because</span>
                                 <span class="c">--  of the Elaborate_Body pragma.</span>

   <span class="n">Y</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">R</span> <span class="o">(</span><span class="n">Z</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Post</span> <span class="o">=&gt;</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">G</span> <span class="o">(</span><span class="n">Z</span><span class="na">&#39;Old</span><span class="o">)</span><span class="p">;</span> <span class="c">--  The call to G is allowed here as it is in</span>
                                 <span class="c">--  the early call region</span>

   <span class="k">procedure </span><span class="nf">S</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="n">Y</span><span class="p">;</span>           <span class="c">--  Global Y needs to be initialized.</span>

   <span class="k">function </span><span class="nf">F</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>
   <span class="k">function </span><span class="nf">G</span> <span class="o">(</span><span class="n">J</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">F</span> <span class="o">(</span><span class="n">J</span><span class="o">))</span><span class="p">;</span>
   <span class="c">--  The call to F is allowed here as it is in</span>
   <span class="c">--  early call region.</span>
<span class="k">end </span><span class="nf">Intra_Unit_Elaboration_Order_Examples</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Intra_Unit_Elaboration_Order_Examples</span> <span class="kr">is</span><span class="p"></span>

   <span class="k">function </span><span class="nf">F</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">I</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--  The early call region for F ends here as the body has been</span>
   <span class="c">--  declared. It can now be called using normal visibility rules.</span>

   <span class="k">procedure </span><span class="nf">P</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span> <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="kr">if</span><span class="p"> </span><span class="n">I</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="kr">then</span><span class="p"></span>
         <span class="n">Q</span> <span class="o">(</span><span class="n">I</span><span class="o">)</span><span class="p">;</span>  <span class="c">--  Q is still in the early call region and so this call is</span>
                 <span class="c">--  allowed</span>
      <span class="k">end if</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">P</span><span class="p">;</span>
   <span class="c">--  The early call region for P ends here as the body has been</span>
   <span class="c">--  declared. It can now be called using normal visibility rules.</span>

   <span class="k">procedure </span><span class="nf">Q</span> <span class="o">(</span><span class="n">J</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span> <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="kr">if</span><span class="p"> </span><span class="n">J</span> <span class="o">&gt;</span> <span class="mi">20</span> <span class="kr">then</span><span class="p"></span>
         <span class="n">J</span> <span class="o">:=</span> <span class="n">J</span> <span class="o">-</span> <span class="mi">10</span><span class="p">;</span>
         <span class="n">P</span> <span class="o">(</span><span class="n">J</span><span class="o">)</span><span class="p">;</span>  <span class="c">--  P can be called as its body is declared.</span>
      <span class="k">end if</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Q</span><span class="p">;</span>
   <span class="c">--  The early call region for Q ends here as the body has been</span>
   <span class="c">--  declared. It can now be called using normal visibility rules.</span>

   <span class="k">procedure </span><span class="nf">R</span> <span class="o">(</span><span class="n">Z</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span> <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Z</span> <span class="o">:=</span> <span class="n">G</span> <span class="o">(</span><span class="n">Z</span><span class="o">)</span><span class="p">;</span> <span class="c">--  The expression function G has been declared and</span>
                  <span class="c">--  so can be called</span>
   <span class="k">end </span><span class="nf">R</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">S</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span> <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">A</span> <span class="o">:=</span> <span class="n">A</span> <span class="o">+</span> <span class="n">Y</span><span class="p">;</span> <span class="c">--  Reference to Y is ok because it is in the early call</span>
                  <span class="c">--  region and the Elaborate_Body pragma ensures it is</span>
                  <span class="c">--  initialized before it is used.</span>
   <span class="k">end </span><span class="nf">S</span><span class="p">;</span>

<span class="kr">begin</span><span class="p"></span>
   <span class="n">Y</span> <span class="o">:=</span> <span class="mi">42</span><span class="p">;</span>
   <span class="n">P</span> <span class="o">(</span><span class="n">X</span><span class="o">)</span><span class="p">;</span>   <span class="c">--  Call to P and hence Q during the elaboration of the package.</span>
<span class="k">end </span><span class="nf">Intra_Unit_Elaboration_Order_Examples</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Inter_1</span> <span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">F</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Inter_1</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Inter_1</span> <span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">F</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">I</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Inter_1</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Inter_2</span> <span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">G</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Inter_2</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package body </span><span class="nf">Inter_2</span> <span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">G</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">I</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Inter_2</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">Inter_1</span><span class="p">;</span>
<span class="kr">pragma</span><span class="p"> </span><span class="n">Elaborate_All</span> <span class="o">(</span><span class="n">Inter_1</span><span class="o">)</span><span class="p">;</span>  <span class="c">--  Ensure the body of the called function F</span>
                                 <span class="c">--  has been elaborated.</span>

<span class="k">package </span><span class="nf">Inter_Unit_Elaboration_Examples</span> <span class="kr">with</span><span class="p"> </span><span class="n">Elaborate_Body</span> <span class="kr">is</span><span class="p"></span>
   <span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span> <span class="o">:=</span> <span class="n">Inter_1.F</span> <span class="o">(</span><span class="mi">10</span><span class="o">)</span><span class="p">;</span>  <span class="c">--  The call to F is ok because its body is</span>
                                   <span class="c">--  sure to have been elaborated.</span>
   <span class="n">Y</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">P</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span><span class="p">;</span>  <span class="c">--  P is declared so that the package</span>
                                      <span class="c">--  requires a body for this example.</span>
<span class="k">end </span><span class="nf">Inter_Unit_Elaboration_Examples</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">Inter_2</span><span class="p">;</span>
<span class="kr">pragma</span><span class="p"> </span><span class="n">Elaborate_All</span> <span class="o">(</span><span class="n">Inter_2</span><span class="o">)</span><span class="p">;</span>  <span class="c">--  Ensure body of called function G has</span>
                                 <span class="c">--  been elaborated.</span>

<span class="k">package body </span><span class="nf">Inter_Unit_Elaboration_Examples</span> <span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">P</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span> <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">I</span> <span class="o">:=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">I</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">P</span><span class="p">;</span>
<span class="kr">begin</span><span class="p"></span>
   <span class="n">Y</span> <span class="o">:=</span> <span class="n">Inter_2.G</span> <span class="o">(</span><span class="mi">20</span><span class="o">)</span><span class="p">;</span>  <span class="c">--  Call to G is ok because the body of</span>
                         <span class="c">--  G is sure to have been elaborated.</span>
<span class="k">end </span><span class="nf">Inter_Unit_Elaboration_Examples</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="section" id="use-of-initial-condition-and-initializes-aspects">
<h3>7.7.1. Use of Initial_Condition and Initializes Aspects<a class="headerlink" href="#use-of-initial-condition-and-initializes-aspects" title="Permalink to this headline">¶</a></h3>
<p class="centered">
<strong><strong>Static Semantics</strong></strong></p><p>To ensure the correct semantics of the Initializes and Initial_Condition
aspects, when applied to library units, language restrictions (described below)
are imposed in SPARK 2014 which have the following consequences:</p>
<ol class="arabic simple" id="tu-cbatu-use-of-initial-condition-and-initializes-aspects-01">
<li>During the elaboration of a library unit package (spec or body),
library-level variables declared outside of that package cannot
be modified and library-level variables declared outside of that
package can only be read if<ol class="loweralpha">
<li>the variable (or its state abstraction) is mentioned in the
Initializes aspect of its enclosing package (from
<a class="reference internal" href="#initializes-aspect"><span class="std std-ref">Initializes Aspects</span></a>); and</li>
<li>either the variable is declared and initialized during the
elaboration of the specification of its enclosing library unit package
or the elaboration of the body of that library unit is
known to precede the elaboration of the spec or body which reads
the variable.</li>
</ol>
</li>
</ol>
<ol class="arabic simple" id="tu-cbatu-use-of-initial-condition-and-initializes-aspects-02" start="2">
<li>From the end of the elaboration of a library package&#8217;s body to the
invocation of the main program (i.e., during subsequent library
unit elaboration), variables declared in the package (and
constituents of state abstractions declared in the package) remain
unchanged. The Initial_Condition aspect is an assertion which is
checked at the end of the elaboration of a package body (but occurs
textually in the package spec; see <a class="reference internal" href="#initial-condition-aspect"><span class="std std-ref">Initial_Condition Aspects</span></a>).
The initial condition of a library-level package will remain true
from this point until the invocation of the main subprogram
(because none of the inputs used in computing the condition can
change during this interval).  This means that a package&#8217;s initial
condition can be assumed to be true both upon entry to the main
subprogram itself and during elaboration of any other unit (spec or body)
whose elaboration is known to follow that of the body of the package
(see preceding definition of &#8220;known to precede&#8221;; <em>known to follow</em>
is, by definition, the inverse relationship). An Initial_Condition which
depends on no variable inputs can also be assumed to be true throughout
the execution of the main subprogram.</li>
</ol>
<ol class="arabic simple" id="tu-cbatu-use-of-initial-condition-and-initializes-aspects-03" start="3">
<li>If a package&#8217;s Initializes aspect mentions a state abstraction
whose refinement includes constituents declared outside of that
package, then the elaboration of bodies of the enclosing packages
of those constituents will precede the elaboration of the body of
the package declaring the abstraction (as a consequence of the
rules given in <a class="reference internal" href="#elaboration-issues"><span class="std std-ref">Elaboration Issues</span></a>). The idea here is that
all constituents of a state abstraction whose initialization has
been promised are in fact initialized by the end of the elaboration
of the body of the abstraction&#8217;s unit - we don&#8217;t have to wait for
the elaboration of other units (e.g., private children) which
contribute to the abstraction.</li>
</ol>
<p class="centered" id="etu-use-of-initial-condition-and-initializes-aspects-ss">
<strong><strong>Verification Rules</strong></strong></p><ol class="arabic" id="tu-nt-use-of-initial-condition-and-initializes-aspects-04" start="4">
<li><p class="first">If a read of a variable (or state abstraction, in the case of a
call to a subprogram which takes an abstraction as an input) declared in
another library unit is executable during elaboration (as defined above),
then either</p>
<ul class="simple">
<li>the entity being read shall be a variable (i.e., not a state abstraction)
and shall be initialized (perhaps by default) during the elaboration of
its enclosing library unit specification; or</li>
<li>the elaboration of the compilation unit which performs the read
shall be known to follow that of the body of the unit declaring
the variable or state abstraction.</li>
</ul>
<p>In either case, the variable or state abstraction shall be specified
as being initialized in the Initializes aspect of the declaring package.
[This is needed to ensure that the variable has been initialized at the
time of the read.]</p>
</li>
</ol>
<ol class="arabic simple" id="tu-nt-use-of-initial-condition-and-initializes-aspects-05" start="5">
<li>If a variable is declared (immediately or not) within a library unit
package specification, and if that variable is initialized (perhaps
by default) during the elaboration of that specification, and if any
part of that variable is also assigned to during the elaboration of
the corresponding library unit package body, then that library unit&#8217;s
Elaborate_Body aspect shall be True. [This is needed to ensure that
the variable remains unread between the elaboration of the
specification and of the body of its enclosing library unit.]</li>
</ol>
<ol class="arabic simple" id="tu-nt-use-of-initial-condition-and-initializes-aspects-06" start="6">
<li>The elaboration of a package&#8217;s specification and body shall not
write to a variable (or state abstraction, in the case of a call to
a procedure which takes an abstraction as an output) declared
outside of the package. The output associated with a read of an
external state with the property Effective_Reads is permitted.
[This rule applies to all packages: library-level or not,
instantiations or not.] The inputs and outputs of a package&#8217;s
elaboration (including the elaboration of any private descendants
of a library unit package) shall be as described in the Initializes
aspect of the package.</li>
</ol>
<p class="centered" id="etu-use-of-initial-condition-and-initializes-aspects-vr">
<strong><strong>Legality Rules</strong></strong></p><ol class="arabic simple" id="tu-nt-use-of-initial-condition-and-initializes-aspects-07" start="7">
<li>The elaboration of a package body shall be known to follow the
elaboration of the body of each of the
library units [(typically private children)] which provide
constituents for a state abstraction denoted in the Initializes
aspect of the given package.</li>
</ol>
<p class="centered" id="etu-use-of-initial-condition-and-initializes-aspects-lr">
<strong><strong>Examples</strong></strong></p><div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">P</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">Initializes</span> <span class="o">=&gt;</span> <span class="n">VP</span>
<span class="kr">is</span><span class="p"></span>
   <span class="kr">pragma</span><span class="p"> </span><span class="n">Elaborate_Body</span><span class="p">;</span>  <span class="c">--  Needed because VP is</span>
   <span class="n">VP</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>           <span class="c">--  Initialized in the body</span>
<span class="k">end </span><span class="nf">P</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">P</span><span class="p">;</span>
<span class="kr">pragma</span><span class="p"> </span><span class="n">Elaborate_All</span> <span class="o">(</span><span class="n">P</span><span class="o">)</span><span class="p">;</span>  <span class="c">--  P.VP is used in initialization of V</span>

<span class="k">package </span><span class="nf">Initialization_And_Elaboration</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">Abstract_State</span>    <span class="o">=&gt;</span> <span class="n">State</span><span class="p">,</span>
       <span class="n">Initializes</span>       <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State</span><span class="p">,</span>
                             <span class="n">V</span> <span class="o">=&gt;</span> <span class="n">P.VP</span><span class="o">)</span><span class="p">,</span>  <span class="c">-- Initializing V depends on P.VP</span>
       <span class="n">Initial_Condition</span> <span class="o">=&gt;</span> <span class="n">V</span> <span class="o">=</span> <span class="n">P.VP</span> <span class="kr">and</span><span class="p"> </span><span class="n">Get_It</span> <span class="o">=</span> <span class="mi">0</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">V</span> <span class="o">:</span> <span class="n">Integer</span> <span class="o">:=</span> <span class="n">P.VP</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Do_It</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Get_It</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Initialization_And_Elaboration</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">private</span><span class="p"> </span><span class="k">package </span><span class="nf">Initialization_And_Elaboration.Private_Child</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">Abstract_State</span>    <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State</span> <span class="kr">with</span><span class="p"> </span><span class="n">Part_Of</span> <span class="o">=&gt;</span>
                               <span class="n">Initialization_And_Elaboration.State</span><span class="o">)</span><span class="p">,</span>
       <span class="n">Initializes</span>       <span class="o">=&gt;</span> <span class="n">State</span><span class="p">,</span>
       <span class="n">Initial_Condition</span> <span class="o">=&gt;</span> <span class="n">Get_Something</span> <span class="o">=</span> <span class="mi">0</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Do_Something</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="o">)</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Get_Something</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Global</span> <span class="o">=&gt;</span> <span class="n">State</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Initialization_And_Elaboration.Private_Child</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">Initialization_And_Elaboration.Private_Child</span><span class="p">;</span>
<span class="kr">pragma</span><span class="p"> </span><span class="n">Elaborate</span> <span class="o">(</span><span class="n">Initialization_And_Elaboration.Private_Child</span><span class="o">)</span><span class="p">;</span>
<span class="c">--  pragma Elaborate for the private child is required because it is a</span>
<span class="c">--  constituent of the state abstraction</span>
<span class="c">--  Initialization_And_Elaboration.State, which is mentioned in the</span>
<span class="c">--  Initializes aspect of the package.</span>

<span class="k">package body </span><span class="nf">Initialization_And_Elaboration</span>
  <span class="kr">with</span><span class="p"> </span><span class="n">Refined_State</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">State</span> <span class="o">=&gt;</span> <span class="n">Private_Child.State</span><span class="o">)</span>
  <span class="c">--  State is initialized</span>
  <span class="c">--  Private child must be elaborated.</span>
<span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Do_It</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">In_Out</span> <span class="o">=&gt;</span> <span class="n">Private_Child.State</span><span class="o">)</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Private_Child.Do_Something</span> <span class="o">(</span><span class="n">I</span><span class="o">)</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Do_It</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Get_It</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">=&gt;</span> <span class="n">Private_Child.State</span>
   <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="kr">return</span><span class="p"> </span><span class="n">Private_Child.Get_Something</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Get_It</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Initialization_And_Elaboration</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="visibility-rules.html" title="8. Visibility Rules"
             >next</a> |</li>
        <li class="right" >
          <a href="subprograms.html" title="6. Subprograms"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">SPARK 2014 Reference Manual 2019</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2013-2019, AdaCore and Altran UK Ltd.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.2.
    </div>
  </body>
</html>