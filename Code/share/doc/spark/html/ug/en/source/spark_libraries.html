<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>5.10. SPARK Libraries &#8212; SPARK 2014 User&#39;s Guide 2019</title>
    
    <link rel="stylesheet" href="../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '2019',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="6. SPARK Tutorial" href="../tutorial.html" />
    <link rel="prev" title="5.9. Concurrency and Ravenscar Profile" href="concurrency.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../tutorial.html" title="6. SPARK Tutorial"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="concurrency.html" title="5.9. Concurrency and Ravenscar Profile"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">SPARK 2014 User&#39;s Guide 2019</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../spark_2014.html" accesskey="U">5. Overview of SPARK Language</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">5.10. SPARK Libraries</a><ul>
<li><a class="reference internal" href="#functional-containers-library">5.10.1. Functional Containers Library</a></li>
<li><a class="reference internal" href="#formal-containers-library">5.10.2. Formal Containers Library</a><ul>
<li><a class="reference internal" href="#modified-api-of-formal-containers">5.10.2.1. Modified API of Formal Containers</a></li>
<li><a class="reference internal" href="#quantification-over-formal-containers">5.10.2.2. Quantification over Formal Containers</a></li>
</ul>
</li>
<li><a class="reference internal" href="#spark-lemma-library">5.10.3. SPARK Lemma Library</a></li>
<li><a class="reference internal" href="#higher-order-function-library">5.10.4. Higher Order Function Library</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="concurrency.html"
                        title="previous chapter">5.9. Concurrency and Ravenscar Profile</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../tutorial.html"
                        title="next chapter">6. SPARK Tutorial</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/en/source/spark_libraries.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="spark-libraries">
<span id="id1"></span><h1>5.10. SPARK Libraries<a class="headerlink" href="#spark-libraries" title="Permalink to this headline">¶</a></h1>
<div class="section" id="functional-containers-library">
<span id="id2"></span><h2>5.10.1. Functional Containers Library<a class="headerlink" href="#functional-containers-library" title="Permalink to this headline">¶</a></h2>
<p>To model complex data structures, one often needs simpler, mathematical like
containers. The mathematical containers provided in the SPARK library are
unbounded and may contain indefinite elements. Furthermore, to be usable in
every context, they are neither controlled nor limited. So that these containers
can be used safely, we have made them functional, that is, no primitives are
provided which would allow modifying an existing container. Instead, their API
features functions creating new containers from existing ones. As an example,
functional containers provide no <code class="docutils literal"><span class="pre">Insert</span></code> procedure but rather a function
<code class="docutils literal"><span class="pre">Add</span></code> which creates a new container with one more element than its parameter:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">function </span><span class="nf">Add</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">Container</span><span class="p">;</span> <span class="n">E</span> <span class="o">:</span> <span class="n">Element_Type</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Container</span><span class="p">;</span>
</pre></div>
</div>
<p>As a consequence, these containers are highly inefficient. They are also memory
consuming as the allocated memory is not reclaimed when the container is no
longer referenced. Thus, they should in general be used in ghost code and
annotations so that they can be removed from the final executable.</p>
<p>There are 3 functional containers, which are part of the GNAT standard
library:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">Ada.Containers.Functional_Maps</span></code></li>
<li><code class="docutils literal"><span class="pre">Ada.Containers.Functional_Sets</span></code></li>
<li><code class="docutils literal"><span class="pre">Ada.Containers.Functional_Vectors</span></code></li>
</ul>
<p>Sequences defined in <code class="docutils literal"><span class="pre">Functional_Vectors</span></code> are no more than ordered collections
of elements. In an Ada like manner, the user can choose the range used to index
the elements:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">function </span><span class="nf">Length</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Sequence</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Count_Type</span><span class="p">;</span>
<span class="k">function </span><span class="nf">Get</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Sequence</span><span class="p">;</span> <span class="n">N</span> <span class="o">:</span> <span class="n">Index_Type</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Element_Type</span><span class="p">;</span>
</pre></div>
</div>
<p>Functional sets offer standard mathematical set functionalities such as
inclusion, union, and intersection. They are neither ordered nor hashed:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">function </span><span class="nf">Contains</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">Set</span><span class="p">;</span> <span class="n">E</span> <span class="o">:</span> <span class="n">Element_Type</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span><span class="p">;</span>
<span class="kr">function</span><span class="p"> </span><span class="s">&quot;&lt;=&quot;</span> <span class="o">(</span><span class="n">Left</span> <span class="o">:</span> <span class="n">Set</span><span class="p">;</span> <span class="n">Right</span> <span class="o">:</span> <span class="n">Set</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span><span class="p">;</span>
</pre></div>
</div>
<p>Functional maps offer a dictionary between any two types of elements:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">function </span><span class="nf">Has_Key</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">Map</span><span class="p">;</span> <span class="n">K</span> <span class="o">:</span> <span class="n">Key_Type</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span><span class="p">;</span>
<span class="k">function </span><span class="nf">Get</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">Map</span><span class="p">;</span> <span class="n">K</span> <span class="o">:</span> <span class="n">Key_Type</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Element_Type</span><span class="p">;</span>
</pre></div>
</div>
<p>Each functional container type supports iteration as appropriate, so that its
elements can easily be quantified over.</p>
<p>These containers can easily be used to model user defined data structures. They
were used to this end to annotate and verify a package of allocators (see
<cite>allocators</cite> example in the <a class="reference internal" href="examples_in_the_toolset_distribution.html#examples-in-the-toolset-distribution"><span class="std std-ref">Examples in the Toolset Distribution</span></a>). In
this example, an allocator featuring a free list implemented in an array is
modeled by a record containing a set of allocated resources and a sequence of
available resources:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="p"> </span><span class="n">Status</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">Available</span><span class="p">,</span> <span class="n">Allocated</span><span class="o">)</span><span class="p">;</span>
<span class="kr">type</span><span class="p"> </span><span class="n">Cell</span> <span class="kr">is</span><span class="p"> </span><span class="kr">record</span><span class="p"></span>
   <span class="n">Stat</span> <span class="o">:</span> <span class="n">Status</span><span class="p">;</span>
   <span class="n">Next</span> <span class="o">:</span> <span class="n">Resource</span><span class="p">;</span>
<span class="k">end record</span><span class="p">;</span>
<span class="kr">type</span><span class="p"> </span><span class="n">Allocator</span> <span class="kr">is</span><span class="p"> </span><span class="kr">array</span><span class="p"> </span><span class="o">(</span><span class="n">Valid_Resource</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Cell</span><span class="p">;</span>
<span class="kr">type</span><span class="p"> </span><span class="n">Model</span> <span class="kr">is</span><span class="p"> </span><span class="kr">record</span><span class="p"></span>
   <span class="n">Available</span> <span class="o">:</span> <span class="n">Sequence</span><span class="p">;</span>
   <span class="n">Allocated</span> <span class="o">:</span> <span class="n">Set</span><span class="p">;</span>
<span class="k">end record</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Functional sets and maps represent elements modulo equivalence. For proof,
the range of quantification over their content includes all elements that
are equivalent to elements included in the container. On the other hand, for
execution, the iteration is only done on elements which have actually been
included in the container. This difference may make interaction between test
and proof tricky when the equivalence relation is not the equality.</p>
</div>
</div>
<div class="section" id="formal-containers-library">
<span id="id3"></span><h2>5.10.2. Formal Containers Library<a class="headerlink" href="#formal-containers-library" title="Permalink to this headline">¶</a></h2>
<p>Containers are generic data structures offering a high-level view of
collections of objects, while guaranteeing fast access to their content to
retrieve or modify it. The most common containers are lists, vectors, sets and
maps, which are defined as generic units in the Ada Standard Library. In
critical software where verification objectives severely restrict the use of
pointers, containers offer an attractive alternative to pointer-intensive data
structures.</p>
<p>The Ada Standard Library defines two kinds of containers:</p>
<ul class="simple">
<li>The controlled containers using dynamic allocation, for example
<code class="docutils literal"><span class="pre">Ada.Containers.Vectors</span></code>. They define containers as controlled tagged
types, so that memory for the container is automatic reallocated during
assignment and automatically freed when the container object&#8217;s scope ends.</li>
<li>The bounded containers not using dynamic allocation, for example
<code class="docutils literal"><span class="pre">Ada.Containers.Bounded_Vectors</span></code>. They define containers as discriminated
tagged types, so that the memory for the container can be reserved at
initialization.</li>
</ul>
<p>Although bounded containers are better suited to critical software development,
neither controlled containers nor bounded containers can be used in SPARK,
because their API does not lend itself to adding suitable contracts (in
particular preconditions) ensuring correct usage in client code.</p>
<p>The formal containers are a variation of the bounded containers with API
changes that allow adding suitable contracts, so that GNATprove can prove
that client code manipulates containers correctly. There are 7 formal
containers, which are part of the GNAT standard library:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">Ada.Containers.Formal_Vectors</span></code></li>
<li><code class="docutils literal"><span class="pre">Ada.Containers.Formal_Indefinite_Vectors</span></code></li>
<li><code class="docutils literal"><span class="pre">Ada.Containers.Formal_Doubly_Linked_Lists</span></code></li>
<li><code class="docutils literal"><span class="pre">Ada.Containers.Formal_Hashed_Sets</span></code></li>
<li><code class="docutils literal"><span class="pre">Ada.Containers.Formal_Ordered_Sets</span></code></li>
<li><code class="docutils literal"><span class="pre">Ada.Containers.Formal_Hashed_Maps</span></code></li>
<li><code class="docutils literal"><span class="pre">Ada.Containers.Formal_Ordered_Maps</span></code></li>
</ul>
<p>Lists, sets and maps can only be used with definite objects (objects for which
the compiler can compute the size in memory, hence not <code class="docutils literal"><span class="pre">String</span></code> nor
<code class="docutils literal"><span class="pre">T'Class</span></code>). Vectors come in two flavors for definite objects
(<code class="docutils literal"><span class="pre">Formal_Vectors</span></code>) and indefinite objects (<code class="docutils literal"><span class="pre">Formal_Indefinite_Vectors</span></code>).</p>
<p>Lists, sets, maps, and definite vectors are always bounded. Indefinite vectors
can be bounded or unbounded
depending on the value of the formal parameter <code class="docutils literal"><span class="pre">Bounded</span></code> when instantiating
the generic unit. Bounded containers do not use dynamic allocation. Unbounded
vectors use dynamic allocation to expand their internal block of memory.</p>
<div class="section" id="modified-api-of-formal-containers">
<h3>5.10.2.1. Modified API of Formal Containers<a class="headerlink" href="#modified-api-of-formal-containers" title="Permalink to this headline">¶</a></h3>
<p>The visible specification of formal containers is in SPARK, with suitable
contracts on subprograms to ensure correct usage, while their private part
and implementation is not in SPARK. Hence, GNATprove can be used to prove
correct usage of formal containers in client code, but not to prove that formal
containers implement their specification.</p>
<p>Procedures <code class="docutils literal"><span class="pre">Update_Element</span></code> or <code class="docutils literal"><span class="pre">Query_Element</span></code> that iterate over a
container are not defined on formal containers. Specification and analysis of
such procedures that take an access-to-procedure in parameter is beyond the
capabilities of SPARK and GNATprove. See <a class="reference internal" href="language_restrictions.html#excluded-ada-features"><span class="std std-ref">Excluded Ada Features</span></a>.</p>
<p>Procedures and functions that query the content of a container take the
container in parameter. For example, function <code class="docutils literal"><span class="pre">Has_Element</span></code> that queries if a
container has an element at a given position is declared as follows:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">function </span><span class="nf">Has_Element</span> <span class="o">(</span><span class="n">Container</span> <span class="o">:</span> <span class="n">T</span><span class="p">;</span> <span class="n">Position</span> <span class="o">:</span> <span class="n">Cursor</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span><span class="p">;</span>
</pre></div>
</div>
<p>This is different from the API of controlled containers and bounded containers,
where it is sufficient to pass a cursor to these subprograms, as the cursor
holds a reference to the underlying container:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">function </span><span class="nf">Has_Element</span> <span class="o">(</span><span class="n">Position</span> <span class="o">:</span> <span class="n">Cursor</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span><span class="p">;</span>
</pre></div>
</div>
<p>Cursors of formal containers do not hold a reference to a specific container,
as this would otherwise introduce aliasing between container and cursor
variables, which is not supported in SPARK. See <a class="reference internal" href="language_restrictions.html#absence-of-interferences"><span class="std std-ref">Absence of Interferences</span></a>. As a result, the same cursor can be applied to multiple
container objects.</p>
<p>For each container type, the library provides model functions that are used to
annotate subprograms from the API. The different models supply different levels
of abstraction of the container’s functionalities. These model functions are
grouped in <a class="reference internal" href="specification_features.html#ghost-packages"><span class="std std-ref">Ghost Packages</span></a> named <code class="docutils literal"><span class="pre">Formal_Model</span></code>.</p>
<p>The higher level view of a container is usually the mathematical structure of
element it represents. We use a sequence for ordered containers such as lists and
vectors and a mathematical map for imperative maps. This allows us to specify
the effects of a subprogram in a very high level way, not having to consider
cursors nor order of elements in a map:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">Increment_All</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">List</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Post</span> <span class="o">=&gt;</span>
    <span class="o">(</span><span class="kr">for</span><span class="p"> </span><span class="kr">all</span><span class="p"> </span><span class="n">N</span> <span class="kr">in</span><span class="p"> </span><span class="mi">1</span> <span class="o">..</span> <span class="n">Length</span> <span class="o">(</span><span class="n">L</span><span class="o">)</span> <span class="o">=&gt;</span>
       <span class="n">Element</span> <span class="o">(</span><span class="n">Model</span> <span class="o">(</span><span class="n">L</span><span class="o">)</span><span class="p">,</span> <span class="n">N</span><span class="o">)</span> <span class="o">=</span> <span class="n">Element</span> <span class="o">(</span><span class="n">Model</span> <span class="o">(</span><span class="n">L</span><span class="o">)</span><span class="na">&#39;Old</span><span class="p">,</span> <span class="n">N</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span><span class="p">;</span>

<span class="k">procedure </span><span class="nf">Increment_All</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Map</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Post</span> <span class="o">=&gt;</span>
    <span class="o">(</span><span class="kr">for</span><span class="p"> </span><span class="kr">all</span><span class="p"> </span><span class="n">K</span> <span class="kr">of</span><span class="p"> </span><span class="n">Model</span> <span class="o">(</span><span class="n">S</span><span class="o">)</span><span class="na">&#39;Old</span> <span class="o">=&gt;</span> <span class="n">Has_Key</span> <span class="o">(</span><span class="n">Model</span> <span class="o">(</span><span class="n">S</span><span class="o">)</span><span class="p">,</span> <span class="n">K</span><span class="o">))</span>
       <span class="kr">and</span><span class="p"></span>
    <span class="o">(</span><span class="kr">for</span><span class="p"> </span><span class="kr">all</span><span class="p"> </span><span class="n">K</span> <span class="kr">of</span><span class="p"> </span><span class="n">Model</span> <span class="o">(</span><span class="n">S</span><span class="o">)</span> <span class="o">=&gt;</span>
       <span class="n">Has_Key</span> <span class="o">(</span><span class="n">Model</span> <span class="o">(</span><span class="n">S</span><span class="o">)</span><span class="na">&#39;Old</span><span class="p">,</span> <span class="n">K</span><span class="o">)</span>
         <span class="kr">and</span><span class="p"> </span><span class="n">Get</span> <span class="o">(</span><span class="n">Model</span> <span class="o">(</span><span class="n">S</span><span class="o">)</span><span class="p">,</span> <span class="n">K</span><span class="o">)</span> <span class="o">=</span> <span class="n">Get</span> <span class="o">(</span><span class="n">Model</span> <span class="o">(</span><span class="n">S</span><span class="o">)</span><span class="na">&#39;Old</span><span class="p">,</span> <span class="n">K</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>For sets and maps, there is a lower level model representing the underlying
order used for iteration in the container, as well as the actual values of
elements/keys. It is a sequence of elements/keys. We can use it if we want to
specify in <code class="docutils literal"><span class="pre">Increment_All</span></code> on maps that the order and actual values of keys
are preserved:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">Increment_All</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Map</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Post</span> <span class="o">=&gt;</span>
    <span class="n">Keys</span> <span class="o">(</span><span class="n">S</span><span class="o">)</span> <span class="o">=</span> <span class="n">Keys</span> <span class="o">(</span><span class="n">S</span><span class="o">)</span><span class="na">&#39;Old</span>
      <span class="kr">and</span><span class="p"></span>
    <span class="o">(</span><span class="kr">for</span><span class="p"> </span><span class="kr">all</span><span class="p"> </span><span class="n">K</span> <span class="kr">of</span><span class="p"> </span><span class="n">Model</span> <span class="o">(</span><span class="n">S</span><span class="o">)</span> <span class="o">=&gt;</span>
       <span class="n">Get</span> <span class="o">(</span><span class="n">Model</span> <span class="o">(</span><span class="n">S</span><span class="o">)</span><span class="p">,</span> <span class="n">K</span><span class="o">)</span> <span class="o">=</span> <span class="n">Get</span> <span class="o">(</span><span class="n">Model</span> <span class="o">(</span><span class="n">S</span><span class="o">)</span><span class="na">&#39;Old</span><span class="p">,</span> <span class="n">K</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>Finally, cursors are modeled using a functional map linking them to their
position in the container. For example, we can state that the positions of
cursors in a list are not modified by a call to <code class="docutils literal"><span class="pre">Increment_All</span></code>:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">Increment_All</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">List</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Post</span> <span class="o">=&gt;</span>
    <span class="n">Positions</span> <span class="o">(</span><span class="n">L</span><span class="o">)</span> <span class="o">=</span> <span class="n">Positions</span> <span class="o">(</span><span class="n">L</span><span class="o">)</span><span class="na">&#39;Old</span>
      <span class="kr">and</span><span class="p"></span>
    <span class="o">(</span><span class="kr">for</span><span class="p"> </span><span class="kr">all</span><span class="p"> </span><span class="n">N</span> <span class="kr">in</span><span class="p"> </span><span class="mi">1</span> <span class="o">..</span> <span class="n">Length</span> <span class="o">(</span><span class="n">L</span><span class="o">)</span> <span class="o">=&gt;</span>
       <span class="n">Element</span> <span class="o">(</span><span class="n">Model</span> <span class="o">(</span><span class="n">L</span><span class="o">)</span><span class="p">,</span> <span class="n">N</span><span class="o">)</span> <span class="o">=</span> <span class="n">Element</span> <span class="o">(</span><span class="n">Model</span> <span class="o">(</span><span class="n">L</span><span class="o">)</span><span class="na">&#39;Old</span><span class="p">,</span> <span class="n">N</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>Switching between the different levels of model functions allows to express
precise considerations when needed without polluting upper level specifications.
For example, consider a variant of the <code class="docutils literal"><span class="pre">List.Find</span></code> function defined in the
API of formal containers, which returns a cursor holding the value searched if
there is one, and the special cursor <code class="docutils literal"><span class="pre">No_Element</span></code> otherwise:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">Element_Lists</span><span class="p">; </span><span class="kr">use</span><span class="nn"> Element_Lists;</span> <span class="kr">use</span><span class="p"> </span><span class="n">Element_Lists.Lists</span><span class="p">;</span>
<span class="kr">with</span><span class="nn"> Ada.Containers;</span> <span class="kr">use</span><span class="p"> </span><span class="n">Ada.Containers</span><span class="p">; </span><span class="kr">use</span><span class="nn"> Element_Lists.Lists.Formal_Model;</span>

<span class="k">function </span><span class="nf">My_Find</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">List</span><span class="p">;</span> <span class="n">E</span> <span class="o">:</span> <span class="n">Element_Type</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Cursor</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">SPARK_Mode</span><span class="p">,</span>
  <span class="n">Contract_Cases</span> <span class="o">=&gt;</span>
    <span class="o">(</span><span class="n">Contains</span> <span class="o">(</span><span class="n">L</span><span class="p">,</span> <span class="n">E</span><span class="o">)</span>     <span class="o">=&gt;</span> <span class="n">Has_Element</span> <span class="o">(</span><span class="n">L</span><span class="p">,</span> <span class="n">My_Find</span><span class="na">&#39;Result</span><span class="o">)</span> <span class="kr">and</span><span class="p"> </span><span class="kr">then</span><span class="p"></span>
                            <span class="n">Element</span> <span class="o">(</span><span class="n">L</span><span class="p">,</span> <span class="n">My_Find</span><span class="na">&#39;Result</span><span class="o">)</span> <span class="o">=</span> <span class="n">E</span><span class="p">,</span>
     <span class="kr">not</span><span class="p"> </span><span class="n">Contains</span> <span class="o">(</span><span class="n">L</span><span class="p">,</span> <span class="n">E</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">My_Find</span><span class="na">&#39;Result</span> <span class="o">=</span> <span class="n">No_Element</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>The ghost functions mentioned above are specially useful in <a class="reference internal" href="assertion_pragmas.html#loop-invariants"><span class="std std-ref">Loop Invariants</span></a> to refer to cursors, and positions of elements in the containers.
For example, here, ghost function <code class="docutils literal"><span class="pre">Positions</span></code> is used in the loop invariant to
query the position of the current cursor in the list, and <code class="docutils literal"><span class="pre">Model</span></code> is used to
specify that the value searched is not contained in the part of the container
already traversed (otherwise the loop would have exited):</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">function </span><span class="nf">My_Find</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">List</span><span class="p">;</span> <span class="n">E</span> <span class="o">:</span> <span class="n">Element_Type</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Cursor</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">SPARK_Mode</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">Cu</span> <span class="o">:</span> <span class="n">Cursor</span> <span class="o">:=</span> <span class="n">First</span> <span class="o">(</span><span class="n">L</span><span class="o">)</span><span class="p">;</span>

<span class="kr">begin</span><span class="p"></span>
   <span class="kr">while</span><span class="p"> </span><span class="n">Has_Element</span> <span class="o">(</span><span class="n">L</span><span class="p">,</span> <span class="n">Cu</span><span class="o">)</span> <span class="kr">loop</span><span class="p"></span>
      <span class="kr">pragma</span><span class="p"> </span><span class="n">Loop_Invariant</span> <span class="o">(</span><span class="kr">for</span><span class="p"> </span><span class="kr">all</span><span class="p"> </span><span class="n">I</span> <span class="kr">in</span><span class="p"> </span><span class="mi">1</span> <span class="o">..</span> <span class="n">P.Get</span> <span class="o">(</span><span class="n">Positions</span> <span class="o">(</span><span class="n">L</span><span class="o">)</span><span class="p">,</span> <span class="n">Cu</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">=&gt;</span>
                                <span class="n">Element</span> <span class="o">(</span><span class="n">Model</span> <span class="o">(</span><span class="n">L</span><span class="o">)</span><span class="p">,</span> <span class="n">I</span><span class="o">)</span> <span class="o">/=</span> <span class="n">E</span><span class="o">)</span><span class="p">;</span>

      <span class="kr">if</span><span class="p"> </span><span class="n">Element</span> <span class="o">(</span><span class="n">L</span><span class="p">,</span> <span class="n">Cu</span><span class="o">)</span> <span class="o">=</span> <span class="n">E</span> <span class="kr">then</span><span class="p"></span>
         <span class="kr">return</span><span class="p"> </span><span class="n">Cu</span><span class="p">;</span>
      <span class="k">end if</span><span class="p">;</span>

      <span class="n">Next</span> <span class="o">(</span><span class="n">L</span><span class="p">,</span> <span class="n">Cu</span><span class="o">)</span><span class="p">;</span>
   <span class="k">end loop</span><span class="p">;</span>

   <span class="kr">return</span><span class="p"> </span><span class="n">No_Element</span><span class="p">;</span>
<span class="k">end </span><span class="nf">My_Find</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>GNATprove proves that function <code class="docutils literal"><span class="pre">My_Find</span></code> implements its specification:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>my_find.adb:8:30: info: loop invariant initialization proved
my_find.adb:8:30: info: loop invariant preservation proved
my_find.adb:8:49: info: precondition proved
my_find.adb:9:33: info: precondition proved
my_find.adb:11:10: info: precondition proved
my_find.adb:15:07: info: precondition proved
my_find.ads:6:03: info: complete contract cases proved
my_find.ads:6:03: info: disjoint contract cases proved
my_find.ads:7:26: info: contract case proved
my_find.ads:8:29: info: precondition proved
my_find.ads:9:26: info: contract case proved
</pre></div>
</div>
</div>
<div class="section" id="quantification-over-formal-containers">
<h3>5.10.2.2. Quantification over Formal Containers<a class="headerlink" href="#quantification-over-formal-containers" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="specification_features.html#quantified-expressions"><span class="std std-ref">Quantified Expressions</span></a> can be used over the content of a formal
container to express that a property holds for all elements of a container
(using <code class="docutils literal"><span class="pre">for</span> <span class="pre">all</span></code>) or that a property holds for at least one element of a
container (using <code class="docutils literal"><span class="pre">for</span> <span class="pre">some</span></code>).</p>
<p>For example, we can express that all elements of a formal list of integers are
prime as follows:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="o">(</span><span class="kr">for</span><span class="p"> </span><span class="kr">all</span><span class="p"> </span><span class="n">Cu</span> <span class="kr">in</span><span class="p"> </span><span class="n">My_List</span> <span class="o">=&gt;</span> <span class="n">Is_Prime</span> <span class="o">(</span><span class="n">Element</span> <span class="o">(</span><span class="n">My_List</span><span class="p">,</span> <span class="n">Cu</span><span class="o">)))</span>
</pre></div>
</div>
<p>On this expression, the GNAT compiler generates code that iterates over
<code class="docutils literal"><span class="pre">My_List</span></code> using the functions <code class="docutils literal"><span class="pre">First</span></code>, <code class="docutils literal"><span class="pre">Has_Element</span></code> and <code class="docutils literal"><span class="pre">Next</span></code> given
in the <code class="docutils literal"><span class="pre">Iterable</span></code> aspect applying to the type of formal lists, so the
quantified expression above is equivalent to:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="kr">declare</span><span class="p"></span>
   <span class="n">Cu</span>     <span class="o">:</span> <span class="n">Cursor_Type</span> <span class="o">:=</span> <span class="n">First</span> <span class="o">(</span><span class="n">My_List</span><span class="o">)</span><span class="p">;</span>
   <span class="n">Result</span> <span class="o">:</span> <span class="n">Boolean</span> <span class="o">:=</span> <span class="kc">True</span><span class="p">;</span>
<span class="kr">begin</span><span class="p"></span>
   <span class="kr">while</span><span class="p"> </span><span class="n">Result</span> <span class="kr">and</span><span class="p"> </span><span class="kr">then</span><span class="p"> </span><span class="n">Has_Element</span> <span class="o">(</span><span class="n">My_List</span><span class="p">,</span> <span class="n">Cu</span><span class="o">)</span> <span class="kr">loop</span><span class="p"></span>
      <span class="n">Result</span> <span class="o">:=</span> <span class="n">Is_Prime</span> <span class="o">(</span><span class="n">Element</span> <span class="o">(</span><span class="n">My_List</span><span class="p">,</span> <span class="n">Cu</span><span class="o">))</span><span class="p">;</span>
      <span class="n">Cu</span>     <span class="o">:=</span> <span class="n">Next</span> <span class="o">(</span><span class="n">My_List</span><span class="p">,</span> <span class="n">Cu</span><span class="o">)</span><span class="p">;</span>
   <span class="k">end loop</span><span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">Result</span></code> is the value of the quantified expression. See GNAT
Reference Manual for details on aspect <code class="docutils literal"><span class="pre">Iterable</span></code>.</p>
</div>
</div>
<div class="section" id="spark-lemma-library">
<span id="id4"></span><h2>5.10.3. SPARK Lemma Library<a class="headerlink" href="#spark-lemma-library" title="Permalink to this headline">¶</a></h2>
<p>As part of the SPARK product, a library of lemmas is available through the
project file <code class="file docutils literal"><span class="pre">&lt;spark-install&gt;/lib/gnat/spark_lemmas.gpr</span></code>. To use this
library in a program, you need to add a corresponding dependency in your
project file, for example:</p>
<div class="highlight-gpr"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="s">&quot;spark_lemmas&quot;</span><span class="p">;</span>
<span class="k">project </span><span class="nf">My_Project</span> <span class="kr">is</span><span class="p"></span>
   <span class="o">...</span>
<span class="k">end </span><span class="nf">My_Project</span><span class="p">;</span>
</pre></div>
</div>
<p>You may need to update the environment variable <code class="docutils literal"><span class="pre">GPR_PROJECT_PATH</span></code> for the
lemma library project to be found by GNAT compiler, as described in
<a class="reference internal" href="../install.html#installation-of-gnatprove"><span class="std std-ref">Installation of GNATprove</span></a>.</p>
<p>You also need to set the environment variable <code class="docutils literal"><span class="pre">SPARK_LEMMAS_OBJECT_DIR</span></code> to
the absolute path of the object directory where you want compilation and
verification artefacts for the lemma library to be created. This should be an
absolute path (not a relative one) otherwise these artefacts will be created
inside you SPARK install.</p>
<p>Finally, if you instantiate in your code a generic from the lemma library, you
also need to pass <code class="docutils literal"><span class="pre">-gnateDSPARK_BODY_MODE=Off</span></code> as a compilation switch for
these generic units.</p>
<p>This library consists in a set of ghost null procedures with contracts (called
<cite>lemmas</cite>). Here is an example of such a lemma:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">Lemma_Div_Is_Monotonic</span>
  <span class="o">(</span><span class="n">Val1</span>  <span class="o">:</span> <span class="n">Int</span><span class="p">;</span>
   <span class="n">Val2</span>  <span class="o">:</span> <span class="n">Int</span><span class="p">;</span>
   <span class="n">Denom</span> <span class="o">:</span> <span class="n">Pos</span><span class="o">)</span>
<span class="kr">with</span><span class="p"></span>
  <span class="n">Global</span> <span class="o">=&gt;</span> <span class="kr">null</span><span class="p">,</span>
  <span class="n">Pre</span>  <span class="o">=&gt;</span> <span class="n">Val1</span> <span class="o">&lt;=</span> <span class="n">Val2</span><span class="p">,</span>
  <span class="n">Post</span> <span class="o">=&gt;</span> <span class="n">Val1</span> <span class="o">/</span> <span class="n">Denom</span> <span class="o">&lt;=</span> <span class="n">Val2</span> <span class="o">/</span> <span class="n">Denom</span><span class="p">;</span>
</pre></div>
</div>
<p>whose body is simply a null procedure:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">Lemma_Div_Is_Monotonic</span>
  <span class="o">(</span><span class="n">Val1</span>  <span class="o">:</span> <span class="n">Int</span><span class="p">;</span>
   <span class="n">Val2</span>  <span class="o">:</span> <span class="n">Int</span><span class="p">;</span>
   <span class="n">Denom</span> <span class="o">:</span> <span class="n">Pos</span><span class="o">)</span>
<span class="kr">is</span><span class="p"> </span><span class="kr">null</span><span class="p">;</span>
</pre></div>
</div>
<p>This procedure is ghost (as part of a ghost package), which means that the
procedure body and all calls to the procedure are compiled away when producing
the final executable without assertions (when switch <cite>-gnata</cite> is not set). On
the contrary, when compiling with assertions for testing (when switch <cite>-gnata</cite>
is set) the precondition of the procedure is executed, possibly detecting
invalid uses of the lemma. However, the main purpose of such a lemma is to
facilitate automatic proof, by providing the prover specific properties
expressed in the postcondition. In the case of <code class="docutils literal"><span class="pre">Lemma_Div_Is_Monotonic</span></code>, the
postcondition expresses an inequality between two expressions. You may use this
lemma in your program by calling it on specific expressions, for example:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="n">R1</span> <span class="o">:=</span> <span class="n">X1</span> <span class="o">/</span> <span class="n">Y</span><span class="p">;</span>
<span class="n">R2</span> <span class="o">:=</span> <span class="n">X2</span> <span class="o">/</span> <span class="n">Y</span><span class="p">;</span>
<span class="n">Lemma_Div_Is_Monotonic</span> <span class="o">(</span><span class="n">X1</span><span class="p">,</span> <span class="n">X2</span><span class="p">,</span> <span class="n">Y</span><span class="o">)</span><span class="p">;</span>
<span class="c">--  at this program point, the prover knows that R1 &lt;= R2</span>
<span class="c">--  the following assertion is proved automatically:</span>
<span class="kr">pragma</span><span class="p"> </span><span class="n">Assert</span> <span class="o">(</span><span class="n">R1</span> <span class="o">&lt;=</span> <span class="n">R2</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that the lemma may have a precondition, stating in which contexts the
lemma holds, which you will need to prove when calling it. For example, a
precondition check is generated in the code above to show that <code class="docutils literal"><span class="pre">X1</span> <span class="pre">&lt;=</span>
<span class="pre">X2</span></code>. Similarly, the types of parameters in the lemma may restrict the contexts
in which the lemma holds. For example, the type <code class="docutils literal"><span class="pre">Pos</span></code> for parameter <code class="docutils literal"><span class="pre">Denom</span></code>
of <code class="docutils literal"><span class="pre">Lemma_Div_Is_Monotonic</span></code> is the type of positive integers. Hence, a range
check may be generated in the code above to show that <code class="docutils literal"><span class="pre">Y</span></code> is positive.</p>
<p>All the lemmas provided in the SPARK lemma library have been proved either
automatically or using Coq interactive prover. The Why3 session file recording
all proofs, as well as the individual Coq proof scripts, are available as part
of the SPARK product under directory
<code class="file docutils literal"><span class="pre">&lt;spark-install&gt;/lib/gnat/proof</span></code>. For example, the proof of lemma
<code class="docutils literal"><span class="pre">Lemma_Div_Is_Monotonic</span></code> is a Coq proof of the mathematical property (in Coq
syntax):</p>
<a class="reference internal image-reference" href="../../_images/div_is_monotonic_in_coq.png"><img alt="Property that division is monotonic in Coq syntax" class="align-center" src="../../_images/div_is_monotonic_in_coq.png" style="width: 400px;" /></a>
<p>Currenly, the SPARK lemma library provides the following lemmas:</p>
<ul class="simple">
<li>Lemmas on signed integer arithmetic in file <code class="docutils literal"><span class="pre">spark-arithmetic_lemmas.ads</span></code>,
that are instantiated for 32 bits signed integers (<code class="docutils literal"><span class="pre">Integer</span></code>) in file
<code class="docutils literal"><span class="pre">spark-integer_arithmetic_lemmas.ads</span></code> and for 64 bits signed integers
(<code class="docutils literal"><span class="pre">Long_Integer</span></code>) in file <code class="docutils literal"><span class="pre">spark-long_integer_arithmetic_lemmas.ads</span></code>.</li>
<li>Lemmas on modular integer arithmetic in file
<code class="docutils literal"><span class="pre">spark-mod_arithmetic_lemmas.ads</span></code>, that are instantiated for 32 bits
modular integers (<code class="docutils literal"><span class="pre">Interfaces.Unsigned_32</span></code>) in file
<code class="docutils literal"><span class="pre">spark-mod32_arithmetic_lemmas.ads</span></code> and for 64 bits modular integers
(<code class="docutils literal"><span class="pre">Interfaces.Unsigned_64</span></code>) in file <code class="docutils literal"><span class="pre">spark-mod64_arithmetic_lemmas.ads</span></code>.</li>
<li>GNAT-specific lemmas on fixed-point arithmetic in file
<code class="docutils literal"><span class="pre">spark-fixed_point_arithmetic_lemmas.ads</span></code>, that need to be instantiated by
the user for her specific fixed-point type.</li>
<li>Lemmas on floating point arithmetic in file
<code class="docutils literal"><span class="pre">spark-floating_point_arithmetic_lemmas.ads</span></code>, that are instantiated for
single-precision floats (<code class="docutils literal"><span class="pre">Float</span></code>) in file
<code class="docutils literal"><span class="pre">spark-float_arithmetic_lemmas.ads</span></code> and for double-precision floats
(<code class="docutils literal"><span class="pre">Long_Float</span></code>) in file <code class="docutils literal"><span class="pre">spark-long_float_arithmetic_lemmas.ads</span></code>.</li>
<li>Lemmas on unconstrained arrays in file
<code class="docutils literal"><span class="pre">spark-unconstrained_array_lemmas.ads</span></code>, that need to be instantiated by the
user for her specific type of index and element, and specific ordering
function between elements.</li>
</ul>
<p>To apply lemmas to signed or modular integers of different types than the ones
used in the instances provided in the library, just convert the expressions
passed in arguments, as follows:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="n">R1</span> <span class="o">:=</span> <span class="n">X1</span> <span class="o">/</span> <span class="n">Y</span><span class="p">;</span>
<span class="n">R2</span> <span class="o">:=</span> <span class="n">X2</span> <span class="o">/</span> <span class="n">Y</span><span class="p">;</span>
<span class="n">Lemma_Div_Is_Monotonic</span> <span class="o">(</span><span class="n">Integer</span><span class="o">(</span><span class="n">X1</span><span class="o">)</span><span class="p">,</span> <span class="n">Integer</span><span class="o">(</span><span class="n">X2</span><span class="o">)</span><span class="p">,</span> <span class="n">Integer</span><span class="o">(</span><span class="n">Y</span><span class="o">))</span><span class="p">;</span>
<span class="c">--  at this program point, the prover knows that R1 &lt;= R2</span>
<span class="c">--  the following assertion is proved automatically:</span>
<span class="kr">pragma</span><span class="p"> </span><span class="n">Assert</span> <span class="o">(</span><span class="n">R1</span> <span class="o">&lt;=</span> <span class="n">R2</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="higher-order-function-library">
<span id="id5"></span><h2>5.10.4. Higher Order Function Library<a class="headerlink" href="#higher-order-function-library" title="Permalink to this headline">¶</a></h2>
<p>The SPARK product also includes a library of higher order functions for
unconstrained arrays. It is available using the same project file as the
<a class="reference internal" href="#spark-lemma-library"><span class="std std-ref">SPARK Lemma Library</span></a>.</p>
<p>This library consists in a set of generic entities defining usual operations on
arrays. As an example, here is a generic function for the map higher-level
function on arrays. It applies a given function <code class="docutils literal"><span class="pre">F</span></code> to each element of an
array, returning an array of results in the same order.</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="kr">generic</span><span class="p"></span>
   <span class="kr">type</span><span class="p"> </span><span class="n">Index_Type</span> <span class="kr">is</span><span class="p"> </span><span class="kr">range</span><span class="p"> </span><span class="o">&lt;&gt;</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span><span class="n">Element_In</span> <span class="kr">is</span><span class="p"> </span><span class="kr">private</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span><span class="n">Array_In</span> <span class="kr">is</span><span class="p"> </span><span class="kr">array</span><span class="p"> </span><span class="o">(</span><span class="n">Index_Type</span> <span class="kr">range</span><span class="p"> </span><span class="o">&lt;&gt;)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Element_In</span><span class="p">;</span>

   <span class="kr">type</span><span class="p"> </span><span class="n">Element_Out</span> <span class="kr">is</span><span class="p"> </span><span class="kr">private</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span><span class="n">Array_Out</span> <span class="kr">is</span><span class="p"> </span><span class="kr">array</span><span class="p"> </span><span class="o">(</span><span class="n">Index_Type</span> <span class="kr">range</span><span class="p"> </span><span class="o">&lt;&gt;)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Element_Out</span><span class="p">;</span>

   <span class="kr">with</span><span class="p"> </span><span class="k">function </span><span class="nf">Init_Prop</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Element_In</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span><span class="p">;</span>
   <span class="c">--  Potential additional constraint on values of the array to allow Map</span>

   <span class="kr">with</span><span class="p"> </span><span class="k">function </span><span class="nf">F</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Element_In</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Element_Out</span><span class="p">;</span>
   <span class="c">--  Function that should be applied to elements of Array_In</span>

<span class="k">function </span><span class="nf">Map</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Array_In</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Array_Out</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Pre</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="kr">for</span><span class="p"> </span><span class="kr">all</span><span class="p"> </span><span class="n">I</span> <span class="kr">in</span><span class="p"> </span><span class="n">A</span><span class="na">&#39;Range</span> <span class="o">=&gt;</span> <span class="n">Init_Prop</span> <span class="o">(</span><span class="n">A</span> <span class="o">(</span><span class="n">I</span><span class="o">)))</span><span class="p">,</span>
  <span class="n">Post</span> <span class="o">=&gt;</span> <span class="n">Map</span><span class="na">&#39;Result&#39;First</span> <span class="o">=</span> <span class="n">A</span><span class="na">&#39;First</span>
  <span class="kr">and</span><span class="p"> </span><span class="kr">then</span><span class="p"> </span><span class="n">Map</span><span class="na">&#39;Result&#39;Last</span> <span class="o">=</span> <span class="n">A</span><span class="na">&#39;Last</span>
  <span class="kr">and</span><span class="p"> </span><span class="kr">then</span><span class="p"> </span><span class="o">(</span><span class="kr">for</span><span class="p"> </span><span class="kr">all</span><span class="p"> </span><span class="n">I</span> <span class="kr">in</span><span class="p"> </span><span class="n">A</span><span class="na">&#39;Range</span> <span class="o">=&gt;</span>
              <span class="n">Map</span><span class="na">&#39;Result</span> <span class="o">(</span><span class="n">I</span><span class="o">)</span> <span class="o">=</span> <span class="n">F</span> <span class="o">(</span><span class="n">A</span> <span class="o">(</span><span class="n">I</span><span class="o">)))</span><span class="p">;</span>
</pre></div>
</div>
<p>This function can be instantiated by providing two unconstrained array types
ranging over the same index type and a function <code class="docutils literal"><span class="pre">F</span></code> mapping a component of the
first array type to a component of the second array type. Additionally, a
constraint <code class="docutils literal"><span class="pre">Init_Prop</span></code> can be supplied for the components of the first array
to be allowed to apply <code class="docutils literal"><span class="pre">F</span></code>. If no such constraint is needed, <code class="docutils literal"><span class="pre">Init_Prop</span></code> can
be instantiated with an always <code class="docutils literal"><span class="pre">True</span></code> function.</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="p"> </span><span class="n">Nat_Array</span> <span class="kr">is</span><span class="p"> </span><span class="kr">array</span><span class="p"> </span><span class="o">(</span><span class="n">Positive</span> <span class="kr">range</span><span class="p"> </span><span class="o">&lt;&gt;)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Natural</span><span class="p">;</span>

<span class="k">function </span><span class="nf">Small_Enough</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Natural</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span> <span class="kr">is</span><span class="p"></span>
  <span class="o">(</span><span class="n">X</span> <span class="o">&lt;</span> <span class="n">Integer</span><span class="na">&#39;Last</span><span class="o">)</span><span class="p">;</span>

<span class="k">function </span><span class="nf">Increment_One</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">X</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Pre</span> <span class="o">=&gt;</span> <span class="n">X</span> <span class="o">&lt;</span> <span class="n">Integer</span><span class="na">&#39;Last</span><span class="p">;</span>

<span class="k">function </span><span class="nf">Increment_All</span> <span class="kr">is</span><span class="p"> </span><span class="kr">new</span><span class="p"> </span><span class="n">SPARK.Higher_Order.Map</span>
  <span class="o">(</span><span class="n">Index_Type</span>  <span class="o">=&gt;</span> <span class="n">Positive</span><span class="p">,</span>
   <span class="n">Element_In</span>  <span class="o">=&gt;</span> <span class="n">Natural</span><span class="p">,</span>
   <span class="n">Array_In</span>    <span class="o">=&gt;</span> <span class="n">Nat_Array</span><span class="p">,</span>
   <span class="n">Element_Out</span> <span class="o">=&gt;</span> <span class="n">Natural</span><span class="p">,</span>
   <span class="n">Array_Out</span>   <span class="o">=&gt;</span> <span class="n">Nat_Array</span><span class="p">,</span>
   <span class="n">Init_Prop</span>   <span class="o">=&gt;</span> <span class="n">Small_Enough</span><span class="p">,</span>
   <span class="n">F</span>           <span class="o">=&gt;</span> <span class="n">Increment_One</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">Increment_All</span></code> function above will take as an argument an array of
natural numbers small enough to be incremented and will return an array
containing the result of incrementing each number by one:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">function </span><span class="nf">Increment_All</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Nat_Array</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Nat_Array</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Pre</span>  <span class="o">=&gt;</span> <span class="o">(</span><span class="kr">for</span><span class="p"> </span><span class="kr">all</span><span class="p"> </span><span class="n">I</span> <span class="kr">in</span><span class="p"> </span><span class="n">A</span><span class="na">&#39;Range</span> <span class="o">=&gt;</span> <span class="n">Small_Enough</span> <span class="o">(</span><span class="n">A</span> <span class="o">(</span><span class="n">I</span><span class="o">)))</span><span class="p">,</span>
  <span class="n">Post</span> <span class="o">=&gt;</span> <span class="n">Increment_All</span><span class="na">&#39;Result&#39;First</span> <span class="o">=</span> <span class="n">A</span><span class="na">&#39;First</span>
  <span class="kr">and</span><span class="p"> </span><span class="kr">then</span><span class="p"> </span><span class="n">Increment_All</span><span class="na">&#39;Result&#39;Last</span> <span class="o">=</span> <span class="n">A</span><span class="na">&#39;Last</span>
  <span class="kr">and</span><span class="p"> </span><span class="kr">then</span><span class="p"> </span><span class="o">(</span><span class="kr">for</span><span class="p"> </span><span class="kr">all</span><span class="p"> </span><span class="n">I</span> <span class="kr">in</span><span class="p"> </span><span class="n">A</span><span class="na">&#39;Range</span> <span class="o">=&gt;</span>
              <span class="n">Increment_All</span><span class="na">&#39;Result</span> <span class="o">(</span><span class="n">I</span><span class="o">)</span> <span class="o">=</span> <span class="n">Increment_One</span> <span class="o">(</span><span class="n">A</span> <span class="o">(</span><span class="n">I</span><span class="o">)))</span><span class="p">;</span>
</pre></div>
</div>
<p>Currently, the higher-order function library provides the following functions:</p>
<ul class="simple">
<li>Map functions over unconstrained one-dimensional arrays in file
<code class="docutils literal"><span class="pre">spark-higher_order.ads</span></code>. These include both in place and functional
map subprograms, with and without an additional position parameter.</li>
<li>Fold functions over unconstrained one-dimensional and two-dimensional arrays
in file <code class="docutils literal"><span class="pre">spark-higher_order-fold.ads</span></code>. Both left to right and right to left
fold functions are available for one-dimensional arrays. For two-dimensional
arrays, fold functions go on a line by line, left to right, top-to-bottom
way. For ease of use, these functions have been instantiated for the most
common cases. <code class="docutils literal"><span class="pre">Sum</span></code> and <code class="docutils literal"><span class="pre">Sum_2</span></code> respectively compute the sum of all the
elements of a one-dimensional or two-dimensional array, and <code class="docutils literal"><span class="pre">Count</span></code> and
<code class="docutils literal"><span class="pre">Count_2</span></code> the number of elements with a given <code class="docutils literal"><span class="pre">Choose</span></code> property.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Unlike the <a class="reference internal" href="#spark-lemma-library"><span class="std std-ref">SPARK Lemma Library</span></a>, these generic functions are
not verified once and for all as their correction depends on the functions
provided at each instance. As a result, each instance should be verified by
running the SPARK tools.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../tutorial.html" title="6. SPARK Tutorial"
             >next</a> |</li>
        <li class="right" >
          <a href="concurrency.html" title="5.9. Concurrency and Ravenscar Profile"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">SPARK 2014 User&#39;s Guide 2019</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../spark_2014.html" >5. Overview of SPARK Language</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2011-2019, AdaCore and Altran UK Ltd.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.2.
    </div>
  </body>
</html>