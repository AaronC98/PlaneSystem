<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>5.5. Specification Features &#8212; SPARK 2014 User&#39;s Guide 2019</title>
    
    <link rel="stylesheet" href="../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '2019',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="5.6. Assertion Pragmas" href="assertion_pragmas.html" />
    <link rel="prev" title="5.4. Type Contracts" href="type_contracts.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="assertion_pragmas.html" title="5.6. Assertion Pragmas"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="type_contracts.html" title="5.4. Type Contracts"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">SPARK 2014 User&#39;s Guide 2019</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../spark_2014.html" accesskey="U">5. Overview of SPARK Language</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">5.5. Specification Features</a><ul>
<li><a class="reference internal" href="#aspect-constant-after-elaboration">5.5.1. Aspect <code class="docutils literal"><span class="pre">Constant_After_Elaboration</span></code></a></li>
<li><a class="reference internal" href="#attribute-old">5.5.2. Attribute <code class="docutils literal"><span class="pre">Old</span></code></a><ul>
<li><a class="reference internal" href="#in-a-postcondition">5.5.2.1. In a Postcondition</a></li>
<li><a class="reference internal" href="#in-contract-cases">5.5.2.2. In Contract Cases</a></li>
<li><a class="reference internal" href="#in-a-potentially-unevaluated-expression">5.5.2.3. In a Potentially Unevaluated Expression</a></li>
</ul>
</li>
<li><a class="reference internal" href="#attribute-result">5.5.3. Attribute <code class="docutils literal"><span class="pre">Result</span></code></a></li>
<li><a class="reference internal" href="#attribute-loop-entry">5.5.4. Attribute <code class="docutils literal"><span class="pre">Loop_Entry</span></code></a></li>
<li><a class="reference internal" href="#attribute-update">5.5.5. Attribute <code class="docutils literal"><span class="pre">Update</span></code></a></li>
<li><a class="reference internal" href="#conditional-expressions">5.5.6. Conditional Expressions</a></li>
<li><a class="reference internal" href="#quantified-expressions">5.5.7. Quantified Expressions</a></li>
<li><a class="reference internal" href="#expression-functions">5.5.8. Expression Functions</a></li>
<li><a class="reference internal" href="#ghost-code">5.5.9. Ghost Code</a><ul>
<li><a class="reference internal" href="#ghost-functions">5.5.9.1. Ghost Functions</a></li>
<li><a class="reference internal" href="#ghost-variables">5.5.9.2. Ghost Variables</a><ul>
<li><a class="reference internal" href="#case-1-keeping-intermediate-values">Case 1: Keeping Intermediate Values</a></li>
<li><a class="reference internal" href="#case-2-keeping-memory-of-previous-state">Case 2: Keeping Memory of Previous State</a></li>
<li><a class="reference internal" href="#case-3-logging-previous-events">Case 3: Logging Previous Events</a></li>
<li><a class="reference internal" href="#case-4-expressing-existentially-quantified-properties">Case 4: Expressing Existentially Quantified Properties</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ghost-types">5.5.9.3. Ghost Types</a></li>
<li><a class="reference internal" href="#ghost-procedures">5.5.9.4. Ghost Procedures</a></li>
<li><a class="reference internal" href="#ghost-packages">5.5.9.5. Ghost Packages</a></li>
<li><a class="reference internal" href="#imported-ghost-subprograms">5.5.9.6. Imported Ghost Subprograms</a></li>
<li><a class="reference internal" href="#ghost-models">5.5.9.7. Ghost Models</a><ul>
<li><a class="reference internal" href="#models-of-control-flow">Models of Control Flow</a></li>
<li><a class="reference internal" href="#models-of-data-structures">Models of Data Structures</a></li>
</ul>
</li>
<li><a class="reference internal" href="#removal-of-ghost-code">5.5.9.8. Removal of Ghost Code</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="type_contracts.html"
                        title="previous chapter">5.4. Type Contracts</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="assertion_pragmas.html"
                        title="next chapter">5.6. Assertion Pragmas</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/en/source/specification_features.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="specification-features">
<span id="id1"></span><h1>5.5. Specification Features<a class="headerlink" href="#specification-features" title="Permalink to this headline">¶</a></h1>
<p>SPARK contains many features for specifying the intended behavior of
programs. Some of these features come from Ada 2012 (<a class="reference internal" href="#attribute-old"><span class="std std-ref">Attribute Old</span></a> and
<a class="reference internal" href="#expression-functions"><span class="std std-ref">Expression Functions</span></a> for example). Other features are specific to
SPARK (<a class="reference internal" href="#attribute-loop-entry"><span class="std std-ref">Attribute Loop_Entry</span></a> and <a class="reference internal" href="#ghost-code"><span class="std std-ref">Ghost Code</span></a> for example). In
this section, we describe these features and their impact on execution and
formal verification.</p>
<div class="section" id="aspect-constant-after-elaboration">
<span id="id2"></span><h2>5.5.1. Aspect <code class="docutils literal"><span class="pre">Constant_After_Elaboration</span></code><a class="headerlink" href="#aspect-constant-after-elaboration" title="Permalink to this headline">¶</a></h2>
<p>Aspect <code class="docutils literal"><span class="pre">Constant_After_Elaboration</span></code> can be specified on a library level
variable that has an initialization expression. When specified, the
corresponding variable can only be changed during the elaboration of its
enclosing package. SPARK ensures that users of the package do not change the
variable. This feature can be particularly useful in tasking code since
variables that are Constant_After_Elaboration are guaranteed to prevent
unsynchronized modifications (see <a class="reference internal" href="concurrency.html#tasks-and-data-races"><span class="std std-ref">Tasks and Data Races</span></a>).</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">CAE</span> <span class="kr">is</span><span class="p"></span>
   <span class="n">Var</span> <span class="o">:</span> <span class="n">Integer</span> <span class="o">:=</span> <span class="mi">0</span> <span class="kr">with</span><span class="p"></span>
     <span class="n">Constant_After_Elaboration</span><span class="p">;</span>

   <span class="c">--  The following is illegal because users of CAE could call Illegal</span>
   <span class="c">--  and that would cause an update of Var after CAE has been</span>
   <span class="c">--  elaborated.</span>
   <span class="k">procedure </span><span class="nf">Illegal</span> <span class="kr">with</span><span class="p"></span>
      <span class="n">Global</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Output</span> <span class="o">=&gt;</span> <span class="n">Var</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">CAE</span><span class="p">;</span>

<span class="k">package body </span><span class="nf">CAE</span> <span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Illegal</span> <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Var</span> <span class="o">:=</span> <span class="mi">10</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Illegal</span><span class="p">;</span>

   <span class="c">--  The following subprogram is legal because it is declared inside</span>
   <span class="c">--  the body of CAE and therefore it cannot be directly called</span>
   <span class="c">--  from a user of CAE.</span>
   <span class="k">procedure </span><span class="nf">Legal</span> <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Var</span> <span class="o">:=</span> <span class="n">Var</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Legal</span><span class="p">;</span>

<span class="kr">begin</span><span class="p"></span>
   <span class="c">--  The following statements are legal since they take place during</span>
   <span class="c">--  the elaboration of CAE.</span>
   <span class="n">Var</span> <span class="o">:=</span> <span class="n">Var</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">Legal</span><span class="p">;</span>
<span class="k">end </span><span class="nf">CAE</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="attribute-old">
<span id="id3"></span><h2>5.5.2. Attribute <code class="docutils literal"><span class="pre">Old</span></code><a class="headerlink" href="#attribute-old" title="Permalink to this headline">¶</a></h2>
<p>[Ada 2012]</p>
<div class="section" id="in-a-postcondition">
<h3>5.5.2.1. In a Postcondition<a class="headerlink" href="#in-a-postcondition" title="Permalink to this headline">¶</a></h3>
<p>Inside <a class="reference internal" href="subprogram_contracts.html#postconditions"><span class="std std-ref">Postconditions</span></a>, attribute <code class="docutils literal"><span class="pre">Old</span></code> refers to the values that
expressions had at subprogram entry. For example, the postcondition of
procedure <code class="docutils literal"><span class="pre">Increment</span></code> might specify that the value of parameter <code class="docutils literal"><span class="pre">X</span></code> upon
returning from the procedure has been incremented:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">Increment</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Post</span> <span class="o">=&gt;</span> <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="na">&#39;Old</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>At run time, a copy of the variable <code class="docutils literal"><span class="pre">X</span></code> is made when entering the
subprogram. This copy is then read when evaluating the expression <code class="docutils literal"><span class="pre">X'Old</span></code> in
the postcondition. Because it requires copying the value of <code class="docutils literal"><span class="pre">X</span></code>, the type of
<code class="docutils literal"><span class="pre">X</span></code> cannot be limited.</p>
<p>Strictly speaking, attribute <code class="docutils literal"><span class="pre">Old</span></code> must apply to a <em>name</em> in Ada syntax, for
example a variable, a component selection, a call, but not an addition like
<code class="docutils literal"><span class="pre">X</span> <span class="pre">+</span> <span class="pre">Y</span></code>. For expressions that are not <em>names</em>, attribute <code class="docutils literal"><span class="pre">Old</span></code> can be applied
to their qualified version, for example:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">Increment_One_Of</span> <span class="o">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Post</span> <span class="o">=&gt;</span> <span class="n">X</span> <span class="o">+</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">&#39;(</span><span class="n">X</span> <span class="o">+</span> <span class="n">Y</span><span class="o">)</span><span class="na">&#39;Old</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>Because the compiler unconditionally creates a copy of the expression to which
attribute <code class="docutils literal"><span class="pre">Old</span></code> is applied at subprogram entry, there is a risk that this feature
might confuse users in more complex postconditions. Take the example of a
procedure <code class="docutils literal"><span class="pre">Extract</span></code>, which copies the value of array <code class="docutils literal"><span class="pre">A</span></code> at index <code class="docutils literal"><span class="pre">J</span></code> into
parameter <code class="docutils literal"><span class="pre">V</span></code>, and zeroes out this value in the array, but only if <code class="docutils literal"><span class="pre">J</span></code> is
in the bounds of <code class="docutils literal"><span class="pre">A</span></code>:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">Extract</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">My_Array</span><span class="p">;</span> <span class="n">J</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span> <span class="n">V</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Value</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Post</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="kr">if</span><span class="p"> </span><span class="n">J</span> <span class="kr">in</span><span class="p"> </span><span class="n">A</span><span class="na">&#39;Range</span> <span class="kr">then</span><span class="p"> </span><span class="n">V</span> <span class="o">=</span> <span class="n">A</span><span class="o">(</span><span class="n">J</span><span class="o">)</span><span class="na">&#39;Old</span><span class="o">)</span><span class="p">;</span>  <span class="c">--  INCORRECT</span>
</pre></div>
</div>
<p>Clearly, the value of <code class="docutils literal"><span class="pre">A(J)</span></code> at subprogram entry is only meaningful if <code class="docutils literal"><span class="pre">J</span></code>
is in the bounds of <code class="docutils literal"><span class="pre">A</span></code>. If the code above was allowed, then a copy of
<code class="docutils literal"><span class="pre">A(J)</span></code> would be made on entry to subprogram <code class="docutils literal"><span class="pre">Extract</span></code>, even when <code class="docutils literal"><span class="pre">J</span></code> is
out of bounds, which would raise a run-time error. To avoid this common
pitfall, use of attribute <code class="docutils literal"><span class="pre">Old</span></code> in expressions that are potentially unevaluated
(like the then-part in an if-expression, or the right argument of a shortcut
boolean expression - See Ada RM 6.1.1) is restricted to
plain variables: <code class="docutils literal"><span class="pre">A</span></code> is allowed, but not <code class="docutils literal"><span class="pre">A(J)</span></code>. The GNAT compiler
issues the following error on the code above:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">prefix</span> <span class="n">of</span> <span class="n">attribute</span> <span class="s2">&quot;Old&quot;</span> <span class="n">that</span> <span class="ow">is</span> <span class="n">potentially</span> <span class="n">unevaluated</span> <span class="n">must</span> <span class="n">denote</span> <span class="n">an</span> <span class="n">entity</span>
</pre></div>
</div>
<p>The correct way to specify the postcondition in the case above is to apply
attribute <code class="docutils literal"><span class="pre">Old</span></code> to the entity prefix <code class="docutils literal"><span class="pre">A</span></code>:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">Extract</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">My_Array</span><span class="p">;</span> <span class="n">J</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span> <span class="n">V</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Value</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Post</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="kr">if</span><span class="p"> </span><span class="n">J</span> <span class="kr">in</span><span class="p"> </span><span class="n">A</span><span class="na">&#39;Range</span> <span class="kr">then</span><span class="p"> </span><span class="n">V</span> <span class="o">=</span> <span class="n">A</span><span class="na">&#39;Old</span><span class="o">(</span><span class="n">J</span><span class="o">))</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="in-contract-cases">
<h3>5.5.2.2. In Contract Cases<a class="headerlink" href="#in-contract-cases" title="Permalink to this headline">¶</a></h3>
<p>The rule for attribute <code class="docutils literal"><span class="pre">Old</span></code> inside <a class="reference internal" href="subprogram_contracts.html#contract-cases"><span class="std std-ref">Contract Cases</span></a> is more
permissive. Take for example the same contract as above for procedure
<code class="docutils literal"><span class="pre">Extract</span></code>, expressed with contract cases:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">Extract</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">My_Array</span><span class="p">;</span> <span class="n">J</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span> <span class="n">V</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Value</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Contract_Cases</span> <span class="o">=&gt;</span> <span class="o">((</span><span class="n">J</span> <span class="kr">in</span><span class="p"> </span><span class="n">A</span><span class="na">&#39;Range</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">V</span> <span class="o">=</span> <span class="n">A</span><span class="o">(</span><span class="n">J</span><span class="o">)</span><span class="na">&#39;Old</span><span class="p">,</span>
                     <span class="kr">others</span><span class="p"> </span>        <span class="o">=&gt;</span> <span class="kc">True</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>Only the expressions used as prefixes of attribute <code class="docutils literal"><span class="pre">Old</span></code> in the <em>currently
enabled case</em> are copied on entry to the subprogram. So if <code class="docutils literal"><span class="pre">Extract</span></code> is
called with <code class="docutils literal"><span class="pre">J</span></code> out of the range of <code class="docutils literal"><span class="pre">A</span></code>, then the second case is enabled,
so <code class="docutils literal"><span class="pre">A(J)</span></code> is not copied when entering procedure <code class="docutils literal"><span class="pre">Extract</span></code>. Hence, the above
code is allowed.</p>
<p>It may still be the case that some contracts refer to the value of objects at
subprogram entry inside potentially unevaluated expressions. For example, an
incorrect variation of the above contract would be:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">Extract</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">My_Array</span><span class="p">;</span> <span class="n">J</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span> <span class="n">V</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Value</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Contract_Cases</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">J</span> <span class="o">&gt;=</span> <span class="n">A</span><span class="na">&#39;First</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="kr">if</span><span class="p"> </span><span class="n">J</span> <span class="o">&lt;=</span> <span class="n">A</span><span class="na">&#39;Last</span> <span class="kr">then</span><span class="p"> </span><span class="n">V</span> <span class="o">=</span> <span class="n">A</span><span class="o">(</span><span class="n">J</span><span class="o">)</span><span class="na">&#39;Old</span><span class="o">)</span><span class="p">,</span>  <span class="c">--  INCORRECT</span>
                     <span class="kr">others</span><span class="p"> </span>      <span class="o">=&gt;</span> <span class="kc">True</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>For the same reason that such uses are forbidden by Ada RM inside
postconditions, the SPARK RM forbids these uses inside contract cases (see
SPARK RM 6.1.3(2)). The GNAT compiler issues the following error on the code
above:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">prefix</span> <span class="n">of</span> <span class="n">attribute</span> <span class="s2">&quot;Old&quot;</span> <span class="n">that</span> <span class="ow">is</span> <span class="n">potentially</span> <span class="n">unevaluated</span> <span class="n">must</span> <span class="n">denote</span> <span class="n">an</span> <span class="n">entity</span>
</pre></div>
</div>
<p>The correct way to specify the consequence expression in the case above is to
apply attribute <code class="docutils literal"><span class="pre">Old</span></code> to the entity prefix <code class="docutils literal"><span class="pre">A</span></code>:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">Extract</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">My_Array</span><span class="p">;</span> <span class="n">J</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span> <span class="n">V</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Value</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Contract_Cases</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">J</span> <span class="o">&gt;=</span> <span class="n">A</span><span class="na">&#39;First</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="kr">if</span><span class="p"> </span><span class="n">J</span> <span class="o">&lt;=</span> <span class="n">A</span><span class="na">&#39;Last</span> <span class="kr">then</span><span class="p"> </span><span class="n">V</span> <span class="o">=</span> <span class="n">A</span><span class="na">&#39;Old</span><span class="o">(</span><span class="n">J</span><span class="o">))</span><span class="p">,</span>
                     <span class="kr">others</span><span class="p"> </span>      <span class="o">=&gt;</span> <span class="kc">True</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="in-a-potentially-unevaluated-expression">
<span id="id4"></span><h3>5.5.2.3. In a Potentially Unevaluated Expression<a class="headerlink" href="#in-a-potentially-unevaluated-expression" title="Permalink to this headline">¶</a></h3>
<p>In some cases, the compiler issues the error discussed above (on attribute <code class="docutils literal"><span class="pre">Old</span></code>
applied to a non-entity in a potentially unevaluated context) on an expression
that can safely be evaluated on subprogram entry, for example:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">Extract</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">My_Array</span><span class="p">;</span> <span class="n">J</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span> <span class="n">V</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Value</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Post</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="kr">if</span><span class="p"> </span><span class="n">J</span> <span class="kr">in</span><span class="p"> </span><span class="n">A</span><span class="na">&#39;Range</span> <span class="kr">then</span><span class="p"> </span><span class="n">V</span> <span class="o">=</span> <span class="n">Get_If_In_Range</span><span class="o">(</span><span class="n">A</span><span class="p">,</span><span class="n">J</span><span class="o">)</span><span class="na">&#39;Old</span><span class="o">)</span><span class="p">;</span>  <span class="c">--  ERROR</span>
</pre></div>
</div>
<p>where function <code class="docutils literal"><span class="pre">Get_If_In_Range</span></code> returns the value <code class="docutils literal"><span class="pre">A(J)</span></code> when <code class="docutils literal"><span class="pre">J</span></code> is in
the bounds of <code class="docutils literal"><span class="pre">A</span></code>, and a default value otherwise.</p>
<p>In that case, the solution is either to rewrite the postcondition using
non-shortcut boolean operators, so that the expression is not <em>potentially
evaluated</em> anymore, for example:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">Extract</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">My_Array</span><span class="p">;</span> <span class="n">J</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span> <span class="n">V</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Value</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Post</span> <span class="o">=&gt;</span> <span class="n">J</span> <span class="kr">not</span><span class="p"> </span><span class="kr">in</span><span class="p"> </span><span class="n">A</span><span class="na">&#39;Range</span> <span class="kr">or</span><span class="p"> </span><span class="n">V</span> <span class="o">=</span> <span class="n">Get_If_In_Range</span><span class="o">(</span><span class="n">A</span><span class="p">,</span><span class="n">J</span><span class="o">)</span><span class="na">&#39;Old</span><span class="p">;</span>
</pre></div>
</div>
<p>or to rewrite the postcondition using an intermediate expression function, so
that the expression is not <em>potentially evaluated</em> anymore, for example:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">function </span><span class="nf">Extract_Post</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">My_Array</span><span class="p">;</span> <span class="n">J</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span> <span class="n">V</span><span class="p">,</span> <span class="n">Get_V</span> <span class="o">:</span> <span class="n">Value</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span> <span class="kr">is</span><span class="p"></span>
  <span class="o">(</span><span class="kr">if</span><span class="p"> </span><span class="n">J</span> <span class="kr">in</span><span class="p"> </span><span class="n">A</span><span class="na">&#39;Range</span> <span class="kr">then</span><span class="p"> </span><span class="n">V</span> <span class="o">=</span> <span class="n">Get_V</span><span class="o">)</span><span class="p">;</span>

<span class="k">procedure </span><span class="nf">Extract</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">My_Array</span><span class="p">;</span> <span class="n">J</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span> <span class="n">V</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Value</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Post</span> <span class="o">=&gt;</span> <span class="n">Extract_Post</span> <span class="o">(</span><span class="n">A</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">Get_If_In_Range</span><span class="o">(</span><span class="n">A</span><span class="p">,</span><span class="n">J</span><span class="o">)</span><span class="na">&#39;Old</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>or to use the GNAT pragma <code class="docutils literal"><span class="pre">Unevaluated_Use_Of_Old</span></code> to allow such uses
of attribute <code class="docutils literal"><span class="pre">Old</span></code> in potentially unevaluated expressions:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Unevaluated_Use_Of_Old</span> <span class="o">(</span><span class="n">Allow</span><span class="o">)</span><span class="p">;</span>

<span class="k">procedure </span><span class="nf">Extract</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">My_Array</span><span class="p">;</span> <span class="n">J</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span> <span class="n">V</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Value</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Post</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="kr">if</span><span class="p"> </span><span class="n">J</span> <span class="kr">in</span><span class="p"> </span><span class="n">A</span><span class="na">&#39;Range</span> <span class="kr">then</span><span class="p"> </span><span class="n">V</span> <span class="o">=</span> <span class="n">Get_If_In_Range</span><span class="o">(</span><span class="n">A</span><span class="p">,</span><span class="n">J</span><span class="o">)</span><span class="na">&#39;Old</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>GNAT does not issue an error on the code above, and always evaluates the
call to <code class="docutils literal"><span class="pre">Get_If_In_Range</span></code> on entry to procedure <code class="docutils literal"><span class="pre">Extract</span></code>, even if this
value may not be used when executing the postcondition. Note that the formal
verification tool GNATprove correctly generates all required checks to prove
that this evaluation on subprogram entry does not fail a run-time check or a
contract (like the precondition of <code class="docutils literal"><span class="pre">Get_If_In_Range</span></code> if any).</p>
<p>Pragma <code class="docutils literal"><span class="pre">Unevaluated_Use_Of_Old</span></code> applies to uses of attribute <code class="docutils literal"><span class="pre">Old</span></code> both
inside postconditions and inside contract cases. See GNAT RM for a
detailed description of this pragma.</p>
</div>
</div>
<div class="section" id="attribute-result">
<span id="id5"></span><h2>5.5.3. Attribute <code class="docutils literal"><span class="pre">Result</span></code><a class="headerlink" href="#attribute-result" title="Permalink to this headline">¶</a></h2>
<p>[Ada 2012]</p>
<p>Inside <a class="reference internal" href="subprogram_contracts.html#postconditions"><span class="std std-ref">Postconditions</span></a> of functions, attribute <code class="docutils literal"><span class="pre">Result</span></code> refers to the
value returned by the function. For example, the postcondition of function
<code class="docutils literal"><span class="pre">Increment</span></code> might specify that it returns the value of parameter <code class="docutils literal"><span class="pre">X</span></code> plus
one:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">function </span><span class="nf">Increment</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Post</span> <span class="o">=&gt;</span> <span class="n">Increment</span><span class="na">&#39;Result</span> <span class="o">=</span> <span class="n">X</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>Contrary to <code class="docutils literal"><span class="pre">Attribute</span> <span class="pre">Old</span></code>, attribute <code class="docutils literal"><span class="pre">Result</span></code> does not require copying
the value, hence it can be applied to functions that return a limited
type. Attribute <code class="docutils literal"><span class="pre">Result</span></code> can also be used inside consequence expressions in
<a class="reference internal" href="subprogram_contracts.html#contract-cases"><span class="std std-ref">Contract Cases</span></a>.</p>
</div>
<div class="section" id="attribute-loop-entry">
<span id="id6"></span><h2>5.5.4. Attribute <code class="docutils literal"><span class="pre">Loop_Entry</span></code><a class="headerlink" href="#attribute-loop-entry" title="Permalink to this headline">¶</a></h2>
<p>[SPARK]</p>
<p>It is sometimes convenient to refer to the value of variables at loop entry. In
many cases, the variable has not been modified between the subprogram entry and
the start of the loop, so this value is the same as the value at subprogram
entry. But <a class="reference internal" href="#attribute-old"><span class="std std-ref">Attribute Old</span></a> cannot be used in that case. Instead, we can
use attribute <code class="docutils literal"><span class="pre">Loop_Entry</span></code>. For example, we can express that after <code class="docutils literal"><span class="pre">J</span></code>
iterations of the loop, the value of parameter array <code class="docutils literal"><span class="pre">X</span></code> at index <code class="docutils literal"><span class="pre">J</span></code> is
equal to its value at loop entry plus one:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">Increment_Array</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Integer_Array</span><span class="o">)</span> <span class="kr">is</span><span class="p"></span>
<span class="kr">begin</span><span class="p"></span>
   <span class="kr">for</span><span class="p"> </span><span class="n">J</span> <span class="kr">in</span><span class="p"> </span><span class="n">X</span><span class="na">&#39;Range</span> <span class="kr">loop</span><span class="p"></span>
      <span class="n">X</span><span class="o">(</span><span class="n">J</span><span class="o">)</span> <span class="o">:=</span> <span class="n">X</span><span class="o">(</span><span class="n">J</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="kr">pragma</span><span class="p"> </span><span class="n">Assert</span> <span class="o">(</span><span class="n">X</span><span class="o">(</span><span class="n">J</span><span class="o">)</span> <span class="o">=</span> <span class="n">X</span><span class="na">&#39;Loop_Entry</span><span class="o">(</span><span class="n">J</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span><span class="p">;</span>
   <span class="k">end loop</span>
<span class="k">end </span><span class="nf">Increment_Array</span><span class="p">;</span>
</pre></div>
</div>
<p>At run time, a copy of the variable <code class="docutils literal"><span class="pre">X</span></code> is made when entering the loop. This
copy is then read when evaluating the expression <code class="docutils literal"><span class="pre">X'Loop_Entry</span></code>. No copy is
made if the loop is never entered. Because it requires copying the value of
<code class="docutils literal"><span class="pre">X</span></code>, the type of <code class="docutils literal"><span class="pre">X</span></code> cannot be limited.</p>
<p>Attribute <code class="docutils literal"><span class="pre">Loop_Entry</span></code> can only be used in top-level <a class="reference internal" href="assertion_pragmas.html#assertion-pragmas"><span class="std std-ref">Assertion Pragmas</span></a>
inside a loop. It is mostly useful for expressing complex <a class="reference internal" href="assertion_pragmas.html#loop-invariants"><span class="std std-ref">Loop Invariants</span></a> which relate the value of a variable at a given iteration of the
loop and its value at loop entry. For example, we can express that after <code class="docutils literal"><span class="pre">J</span></code>
iterations of the loop, the value of parameter array <code class="docutils literal"><span class="pre">X</span></code> at all indexes
already seen is equal to its value at loop entry plus one, and that its value
at all indexes not yet seen is unchanged, using <a class="reference internal" href="#quantified-expressions"><span class="std std-ref">Quantified Expressions</span></a>:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">Increment_Array</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Integer_Array</span><span class="o">)</span> <span class="kr">is</span><span class="p"></span>
<span class="kr">begin</span><span class="p"></span>
   <span class="kr">for</span><span class="p"> </span><span class="n">J</span> <span class="kr">in</span><span class="p"> </span><span class="n">X</span><span class="na">&#39;Range</span> <span class="kr">loop</span><span class="p"></span>
      <span class="n">X</span><span class="o">(</span><span class="n">J</span><span class="o">)</span> <span class="o">:=</span> <span class="n">X</span><span class="o">(</span><span class="n">J</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="kr">pragma</span><span class="p"> </span><span class="n">Loop_Invariant</span> <span class="o">(</span><span class="kr">for</span><span class="p"> </span><span class="kr">all</span><span class="p"> </span><span class="n">K</span> <span class="kr">in</span><span class="p"> </span><span class="n">X</span><span class="na">&#39;First</span> <span class="o">..</span> <span class="n">J</span> <span class="o">=&gt;</span> <span class="n">X</span><span class="o">(</span><span class="n">K</span><span class="o">)</span> <span class="o">=</span> <span class="n">X</span><span class="na">&#39;Loop_Entry</span><span class="o">(</span><span class="n">K</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span><span class="p">;</span>
      <span class="kr">pragma</span><span class="p"> </span><span class="n">Loop_Invariant</span> <span class="o">(</span><span class="kr">for</span><span class="p"> </span><span class="kr">all</span><span class="p"> </span><span class="n">K</span> <span class="kr">in</span><span class="p"> </span><span class="n">J</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">..</span> <span class="n">X</span><span class="na">&#39;Last</span> <span class="o">=&gt;</span> <span class="n">X</span><span class="o">(</span><span class="n">K</span><span class="o">)</span> <span class="o">=</span> <span class="n">X</span><span class="na">&#39;Loop_Entry</span><span class="o">(</span><span class="n">K</span><span class="o">))</span><span class="p">;</span>
   <span class="k">end loop</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Increment_Array</span><span class="p">;</span>
</pre></div>
</div>
<p>Attribute <code class="docutils literal"><span class="pre">Loop_Entry</span></code> may be indexed by the name of the loop to which it
applies, which is useful to refer to the value of a variable on entry to an
outter loop. When used without loop name, the attribute applies to the closest
enclosing loop. For examples, <code class="docutils literal"><span class="pre">X'Loop_Entry</span></code> is the same as
<code class="docutils literal"><span class="pre">X'Loop_Entry(Inner)</span></code> in the loop below, which is not the same as
<code class="docutils literal"><span class="pre">X'Loop_Entry(Outter)</span></code> (although all three assertions are true):</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">Increment_Matrix</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Integer_Matrix</span><span class="o">)</span> <span class="kr">is</span><span class="p"></span>
<span class="kr">begin</span><span class="p"></span>
   <span class="n">Outter</span><span class="o">:</span> <span class="kr">for</span><span class="p"> </span><span class="n">J</span> <span class="kr">in</span><span class="p"> </span><span class="n">X</span><span class="na">&#39;Range</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="kr">loop</span><span class="p"></span>
      <span class="n">Inner</span><span class="o">:</span> <span class="kr">for</span><span class="p"> </span><span class="n">K</span> <span class="kr">in</span><span class="p"> </span><span class="n">X</span><span class="na">&#39;Range</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="kr">loop</span><span class="p"></span>
         <span class="n">X</span><span class="o">(</span><span class="n">J</span><span class="p">,</span><span class="n">K</span><span class="o">)</span> <span class="o">:=</span> <span class="n">X</span><span class="o">(</span><span class="n">J</span><span class="p">,</span><span class="n">K</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
         <span class="kr">pragma</span><span class="p"> </span><span class="n">Assert</span> <span class="o">(</span><span class="n">X</span><span class="o">(</span><span class="n">J</span><span class="p">,</span><span class="n">K</span><span class="o">)</span> <span class="o">=</span> <span class="n">X</span><span class="na">&#39;Loop_Entry</span><span class="o">(</span><span class="n">J</span><span class="p">,</span><span class="n">K</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span><span class="p">;</span>
         <span class="kr">pragma</span><span class="p"> </span><span class="n">Assert</span> <span class="o">(</span><span class="n">X</span><span class="o">(</span><span class="n">J</span><span class="p">,</span><span class="n">K</span><span class="o">)</span> <span class="o">=</span> <span class="n">X</span><span class="na">&#39;Loop_Entry</span><span class="o">(</span><span class="n">Inner</span><span class="o">)(</span><span class="n">J</span><span class="p">,</span><span class="n">K</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span><span class="p">;</span>
         <span class="kr">pragma</span><span class="p"> </span><span class="n">Assert</span> <span class="o">(</span><span class="n">X</span><span class="o">(</span><span class="n">J</span><span class="p">,</span><span class="n">K</span><span class="o">)</span> <span class="o">=</span> <span class="n">X</span><span class="na">&#39;Loop_Entry</span><span class="o">(</span><span class="n">Outter</span><span class="o">)(</span><span class="n">J</span><span class="p">,</span><span class="n">K</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span><span class="p">;</span>
      <span class="k">end loop</span> <span class="n">Inner</span><span class="p">;</span>
   <span class="k">end loop</span> <span class="n">Outter</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Increment_Matrix</span><span class="p">;</span>
</pre></div>
</div>
<p>By default, similar restrictions exist for the use of attribute <code class="docutils literal"><span class="pre">Loop_Entry</span></code>
and the use of attribute <code class="docutils literal"><span class="pre">Old</span></code> <a class="reference internal" href="#in-a-potentially-unevaluated-expression"><span class="std std-ref">In a Potentially Unevaluated Expression</span></a>. The same solutions apply here, in particular the use of GNAT
pragma <code class="docutils literal"><span class="pre">Unevaluated_Use_Of_Old</span></code>.</p>
</div>
<div class="section" id="attribute-update">
<span id="id7"></span><h2>5.5.5. Attribute <code class="docutils literal"><span class="pre">Update</span></code><a class="headerlink" href="#attribute-update" title="Permalink to this headline">¶</a></h2>
<p>[SPARK]</p>
<p>It is quite common in <a class="reference internal" href="subprogram_contracts.html#postconditions"><span class="std std-ref">Postconditions</span></a> to relate the input and output
values of parameters. While this can be as easy as <code class="docutils literal"><span class="pre">X</span> <span class="pre">=</span> <span class="pre">X'Old</span> <span class="pre">+</span> <span class="pre">1</span></code> in the
case of scalar parameters, it is more complex to express for array and record
parameters. Attribute <code class="docutils literal"><span class="pre">Update</span></code> is useful in that case, to denote the updated
value of a composite variable. For example, we can express more clearly that
procedure <code class="docutils literal"><span class="pre">Zero_Range</span></code> zeroes out the elements of its array parameter <code class="docutils literal"><span class="pre">X</span></code>
between <code class="docutils literal"><span class="pre">From</span></code> and <code class="docutils literal"><span class="pre">To</span></code> by using attribute <code class="docutils literal"><span class="pre">Update</span></code>:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">Zero_Range</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Integer_Array</span><span class="p">;</span> <span class="n">From</span><span class="p">,</span> <span class="n">To</span> <span class="o">:</span> <span class="n">Positive</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Post</span> <span class="o">=&gt;</span> <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="na">&#39;Old&#39;Update</span><span class="o">(</span><span class="n">From</span> <span class="o">..</span> <span class="n">To</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>than with an equivalent postcondition using <a class="reference internal" href="#quantified-expressions"><span class="std std-ref">Quantified Expressions</span></a> and
<a class="reference internal" href="#conditional-expressions"><span class="std std-ref">Conditional Expressions</span></a>:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">Zero_Range</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Integer_Array</span><span class="p">;</span> <span class="n">From</span><span class="p">,</span> <span class="n">To</span> <span class="o">:</span> <span class="n">Positive</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Post</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="kr">for</span><span class="p"> </span><span class="kr">all</span><span class="p"> </span><span class="n">J</span> <span class="kr">in</span><span class="p"> </span><span class="n">X</span><span class="na">&#39;Range</span> <span class="o">=&gt;</span>
             <span class="o">(</span><span class="kr">if</span><span class="p"> </span><span class="n">J</span> <span class="kr">in</span><span class="p"> </span><span class="n">From</span> <span class="o">..</span> <span class="n">To</span> <span class="kr">then</span><span class="p"> </span><span class="n">X</span><span class="o">(</span><span class="n">J</span><span class="o">)</span> <span class="o">=</span> <span class="mi">0</span> <span class="kr">else</span><span class="p"> </span><span class="n">X</span><span class="o">(</span><span class="n">J</span><span class="o">)</span> <span class="o">=</span> <span class="n">X</span><span class="na">&#39;Old</span><span class="o">(</span><span class="n">J</span><span class="o">)))</span><span class="p">;</span>
</pre></div>
</div>
<p>Attribute <code class="docutils literal"><span class="pre">Update</span></code> takes in argument a list of associations between indexes
(for arrays) or components (for records) and values. Components can only be
mentioned once, with the semantics that all values are evaluated before any
update. Array indexes may be mentioned more than once, with the semantics that
updates are applied in left-to-right order. For example, the postcondition of
procedure <code class="docutils literal"><span class="pre">Swap</span></code> expresses that the values at indexes <code class="docutils literal"><span class="pre">J</span></code> and <code class="docutils literal"><span class="pre">K</span></code> in
array <code class="docutils literal"><span class="pre">X</span></code> have been swapped:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">Swap</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Integer_Array</span><span class="p">;</span> <span class="n">J</span><span class="p">,</span> <span class="n">K</span> <span class="o">:</span> <span class="n">Positive</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Post</span> <span class="o">=&gt;</span> <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="na">&#39;Old&#39;Update</span><span class="o">(</span><span class="n">J</span> <span class="o">=&gt;</span> <span class="n">X</span><span class="na">&#39;Old</span><span class="o">(</span><span class="n">K</span><span class="o">)</span><span class="p">,</span> <span class="n">K</span> <span class="o">=&gt;</span> <span class="n">X</span><span class="na">&#39;Old</span><span class="o">(</span><span class="n">J</span><span class="o">))</span><span class="p">;</span>
</pre></div>
</div>
<p>and the postcondition of procedure <code class="docutils literal"><span class="pre">Rotate_Clockwize_Z</span></code> expresses that the
point <code class="docutils literal"><span class="pre">P</span></code> given in parameter has been rotated 90 degrees clockwise around the
Z axis (thus component <code class="docutils literal"><span class="pre">Z</span></code> is preserved while components <code class="docutils literal"><span class="pre">X</span></code> and <code class="docutils literal"><span class="pre">Y</span></code> are
modified):</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">Rotate_Clockwize_Z</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Point_3D</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Post</span> <span class="o">=&gt;</span> <span class="n">P</span> <span class="o">=</span> <span class="n">P</span><span class="na">&#39;Old&#39;Update</span><span class="o">(</span><span class="n">X</span> <span class="o">=&gt;</span> <span class="n">P.Y</span><span class="na">&#39;Old</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=&gt;</span> <span class="o">-</span> <span class="n">P.X</span><span class="na">&#39;Old</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>Similarly to its use in combination with attribute <code class="docutils literal"><span class="pre">Old</span></code> in postconditions,
attribute <code class="docutils literal"><span class="pre">Update</span></code> is useful in combination with <a class="reference internal" href="#attribute-loop-entry"><span class="std std-ref">Attribute Loop_Entry</span></a>
inside <a class="reference internal" href="assertion_pragmas.html#loop-invariants"><span class="std std-ref">Loop Invariants</span></a>. For example, we can express the property that,
after iteration <code class="docutils literal"><span class="pre">J</span></code> in the main loop in procedure <code class="docutils literal"><span class="pre">Zero_Range</span></code>, the value
of parameter array <code class="docutils literal"><span class="pre">X</span></code> at all indexes already seen is equal to zero:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">Zero_Range</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Integer_Array</span><span class="p">;</span> <span class="n">From</span><span class="p">,</span> <span class="n">To</span> <span class="o">:</span> <span class="n">Positive</span><span class="o">)</span> <span class="kr">is</span><span class="p"></span>
<span class="kr">begin</span><span class="p"></span>
   <span class="kr">for</span><span class="p"> </span><span class="n">J</span> <span class="kr">in</span><span class="p"> </span><span class="n">From</span> <span class="o">..</span> <span class="n">To</span> <span class="kr">loop</span><span class="p"></span>
      <span class="n">X</span><span class="o">(</span><span class="n">J</span><span class="o">)</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="kr">pragma</span><span class="p"> </span><span class="n">Loop_Invariant</span> <span class="o">(</span><span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="na">&#39;Loop_Entry&#39;Update</span><span class="o">(</span><span class="n">From</span> <span class="o">..</span> <span class="n">J</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">))</span><span class="p">;</span>
   <span class="k">end loop</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Zero_Range</span><span class="p">;</span>
</pre></div>
</div>
<p>Attribute <code class="docutils literal"><span class="pre">Update</span></code> can also be used outside of assertions. It is particularly
useful in expression functions. For example, the functionality in procedure
<code class="docutils literal"><span class="pre">Rotate_Clockwize_Z</span></code> could be expressed equivalently as an expression
function:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">function </span><span class="nf">Rotate_Clockwize_Z</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">Point_3D</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Point_3D</span> <span class="kr">is</span><span class="p"></span>
  <span class="o">(</span><span class="n">P</span><span class="na">&#39;Update</span><span class="o">(</span><span class="n">X</span> <span class="o">=&gt;</span> <span class="n">P.Y</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=&gt;</span> <span class="o">-</span> <span class="n">P.X</span><span class="o">))</span><span class="p">;</span>
</pre></div>
</div>
<p>Because it requires copying the value of <code class="docutils literal"><span class="pre">P</span></code>, the type of <code class="docutils literal"><span class="pre">P</span></code> cannot be
limited.</p>
</div>
<div class="section" id="conditional-expressions">
<span id="id8"></span><h2>5.5.6. Conditional Expressions<a class="headerlink" href="#conditional-expressions" title="Permalink to this headline">¶</a></h2>
<p>[Ada 2012]</p>
<p>A conditional expression is a way to express alternative possibilities in an
expression. It is like the ternary conditional expression <code class="docutils literal"><span class="pre">cond</span> <span class="pre">?</span> <span class="pre">expr1</span> <span class="pre">:</span>
<span class="pre">expr2</span></code> in C or Java, except more powerful. There are two kinds of conditional
expressions in Ada:</p>
<ul class="simple">
<li>if-expressions are the counterpart of if-statements in expressions</li>
<li>case-expressions are the counterpart of case-statements in expressions</li>
</ul>
<p>For example, consider the variant of procedure <code class="docutils literal"><span class="pre">Add_To_Total</span></code> seen in
<a class="reference internal" href="subprogram_contracts.html#contract-cases"><span class="std std-ref">Contract Cases</span></a>, which saturates at a given threshold. Its postcondition
can be expressed with an if-expression as follows:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">Add_To_Total</span> <span class="o">(</span><span class="n">Incr</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Post</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="kr">if</span><span class="p"> </span><span class="n">Total</span><span class="na">&#39;Old</span> <span class="o">+</span> <span class="n">Incr</span> <span class="o">&lt;</span> <span class="n">Threshold</span>  <span class="kr">then</span><span class="p"></span>
             <span class="n">Total</span> <span class="o">=</span> <span class="n">Total</span><span class="na">&#39;Old</span> <span class="o">+</span> <span class="n">Incr</span>
           <span class="kr">else</span><span class="p"></span>
             <span class="n">Total</span> <span class="o">=</span> <span class="n">Threshold</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>Each branch of an if-expression (there may be one, two or more branches when
<code class="docutils literal"><span class="pre">elsif</span></code> is used) can be seen as a logical implication, which explains why the
above postcondition can also be written:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">Add_To_Total</span> <span class="o">(</span><span class="n">Incr</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Post</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="kr">if</span><span class="p"> </span><span class="n">Total</span><span class="na">&#39;Old</span> <span class="o">+</span> <span class="n">Incr</span> <span class="o">&lt;</span> <span class="n">Threshold</span> <span class="kr">then</span><span class="p"> </span><span class="n">Total</span> <span class="o">=</span> <span class="n">Total</span><span class="na">&#39;Old</span> <span class="o">+</span> <span class="n">Incr</span><span class="o">)</span> <span class="kr">and</span><span class="p"></span>
          <span class="o">(</span><span class="kr">if</span><span class="p"> </span><span class="n">Total</span><span class="na">&#39;Old</span> <span class="o">+</span> <span class="n">Incr</span> <span class="o">&gt;=</span> <span class="n">Threshold</span> <span class="kr">then</span><span class="p"> </span><span class="n">Total</span> <span class="o">=</span> <span class="n">Threshold</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>or equivalently (as the absence of <code class="docutils literal"><span class="pre">else</span></code> branch above is implicitly the same
as <code class="docutils literal"><span class="pre">else</span> <span class="pre">True</span></code>):</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">Add_To_Total</span> <span class="o">(</span><span class="n">Incr</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Post</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="kr">if</span><span class="p"> </span><span class="n">Total</span><span class="na">&#39;Old</span> <span class="o">+</span> <span class="n">Incr</span> <span class="o">&lt;</span> <span class="n">Threshold</span> <span class="kr">then</span><span class="p"> </span><span class="n">Total</span> <span class="o">=</span> <span class="n">Total</span><span class="na">&#39;Old</span> <span class="o">+</span> <span class="n">Incr</span> <span class="kr">else</span><span class="p"> </span><span class="kc">True</span><span class="o">)</span> <span class="kr">and</span><span class="p"></span>
          <span class="o">(</span><span class="kr">if</span><span class="p"> </span><span class="n">Total</span><span class="na">&#39;Old</span> <span class="o">+</span> <span class="n">Incr</span> <span class="o">&gt;=</span> <span class="n">Threshold</span> <span class="kr">then</span><span class="p"> </span><span class="n">Total</span> <span class="o">=</span> <span class="n">Threshold</span> <span class="kr">else</span><span class="p"> </span><span class="kc">True</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>If-expressions are not necessarily of boolean type, in which case they must
have an <code class="docutils literal"><span class="pre">else</span></code> branch that gives the value of the expression for cases not
covered in previous conditions (as there is no implicit <code class="docutils literal"><span class="pre">else</span> <span class="pre">True</span></code> in such
a case). For example, here is a postcondition equivalent to the above, that
uses an if-expression of <code class="docutils literal"><span class="pre">Integer</span></code> type:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">Add_To_Total</span> <span class="o">(</span><span class="n">Incr</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Post</span> <span class="o">=&gt;</span> <span class="n">Total</span> <span class="o">=</span> <span class="o">(</span><span class="kr">if</span><span class="p"> </span><span class="n">Total</span><span class="na">&#39;Old</span> <span class="o">+</span> <span class="n">Incr</span> <span class="o">&lt;</span> <span class="n">Threshold</span> <span class="kr">then</span><span class="p"> </span><span class="n">Total</span><span class="na">&#39;Old</span> <span class="o">+</span> <span class="n">Incr</span> <span class="kr">else</span><span class="p"> </span><span class="n">Threshold</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>Although case-expressions can be used to cover cases of any scalar type, they
are mostly used with enumerations, and the compiler checks that all cases are
disjoint and that together they cover all possible cases. For example, consider
a variant of procedure <code class="docutils literal"><span class="pre">Add_To_Total</span></code> which takes an additional <code class="docutils literal"><span class="pre">Mode</span></code>
global input of enumeration value <code class="docutils literal"><span class="pre">Single</span></code>, <code class="docutils literal"><span class="pre">Double</span></code>, <code class="docutils literal"><span class="pre">Negate</span></code> or
<code class="docutils literal"><span class="pre">Ignore</span></code>, with the intuitive corresponding leverage effect on the
addition. The postcondition of this variant can be expressed using a
case-expression as follows:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">Add_To_Total</span> <span class="o">(</span><span class="n">Incr</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Post</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="kr">case</span><span class="p"> </span><span class="n">Mode</span> <span class="kr">is</span><span class="p"></span>
             <span class="kr">when</span><span class="p"> </span><span class="n">Single</span> <span class="o">=&gt;</span> <span class="n">Total</span> <span class="o">=</span> <span class="n">Total</span><span class="na">&#39;Old</span> <span class="o">+</span> <span class="n">Incr</span><span class="p">,</span>
             <span class="kr">when</span><span class="p"> </span><span class="n">Double</span> <span class="o">=&gt;</span> <span class="n">Total</span> <span class="o">=</span> <span class="n">Total</span><span class="na">&#39;Old</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">Incr</span><span class="p">,</span>
             <span class="kr">when</span><span class="p"> </span><span class="n">Ignore</span> <span class="o">=&gt;</span> <span class="n">Total</span> <span class="o">=</span> <span class="n">Total</span><span class="na">&#39;Old</span><span class="p">,</span>
             <span class="kr">when</span><span class="p"> </span><span class="n">Negate</span> <span class="o">=&gt;</span> <span class="n">Total</span> <span class="o">=</span> <span class="n">Total</span><span class="na">&#39;Old</span> <span class="o">-</span> <span class="n">Incr</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>Like if-expressions, case-expressions are not necessarily of boolean type. For
example, here is a postcondition equivalent to the above, that uses a
case-expression of <code class="docutils literal"><span class="pre">Integer</span></code> type:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">Add_To_Total</span> <span class="o">(</span><span class="n">Incr</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Post</span> <span class="o">=&gt;</span> <span class="n">Total</span> <span class="o">=</span> <span class="n">Total</span><span class="na">&#39;Old</span> <span class="o">+</span> <span class="o">(</span><span class="kr">case</span><span class="p"> </span><span class="n">Mode</span> <span class="kr">is</span><span class="p"></span>
                                 <span class="kr">when</span><span class="p"> </span><span class="n">Single</span> <span class="o">=&gt;</span> <span class="n">Incr</span><span class="p">,</span>
                                 <span class="kr">when</span><span class="p"> </span><span class="n">Double</span> <span class="o">=&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">Incr</span><span class="p">,</span>
                                 <span class="kr">when</span><span class="p"> </span><span class="n">Ignore</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">,</span>
                                 <span class="kr">when</span><span class="p"> </span><span class="n">Negate</span> <span class="o">=&gt;</span> <span class="o">-</span> <span class="n">Incr</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>A last case of <code class="docutils literal"><span class="pre">others</span></code> can be used to denote all cases not covered by
previous conditions. If-expressions and case-expressions should always be
parenthesized.</p>
</div>
<div class="section" id="quantified-expressions">
<span id="id9"></span><h2>5.5.7. Quantified Expressions<a class="headerlink" href="#quantified-expressions" title="Permalink to this headline">¶</a></h2>
<p>[Ada 2012]</p>
<p>A quantified expression is a way to express a property over a collection,
either an array or a container (see <a class="reference internal" href="spark_libraries.html#formal-containers-library"><span class="std std-ref">Formal Containers Library</span></a>):</p>
<ul class="simple">
<li>a <cite>universally quantified expression</cite> using <code class="docutils literal"><span class="pre">for</span> <span class="pre">all</span></code> expresses a property
that holds for all elements of a collection</li>
<li>an <cite>existentially quantified expression</cite> using <code class="docutils literal"><span class="pre">for</span> <span class="pre">some</span></code> expresses a
property that holds for at least one element of a collection</li>
</ul>
<p>For example, consider the procedure <code class="docutils literal"><span class="pre">Increment_Array</span></code> that increments each
element of its array parameter <code class="docutils literal"><span class="pre">X</span></code> by one. Its postcondition can be expressed
using a universally quantified expression as follows:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">Increment_Array</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Integer_Array</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Post</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="kr">for</span><span class="p"> </span><span class="kr">all</span><span class="p"> </span><span class="n">J</span> <span class="kr">in</span><span class="p"> </span><span class="n">X</span><span class="na">&#39;Range</span> <span class="o">=&gt;</span> <span class="n">X</span><span class="o">(</span><span class="n">J</span><span class="o">)</span> <span class="o">=</span> <span class="n">X</span><span class="na">&#39;Old</span><span class="o">(</span><span class="n">J</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>The negation of a universal property being an existential property (the
opposite is true too), the postcondition above can be expressed also using an
existentially quantified expression as follows:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">Increment_Array</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Integer_Array</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Post</span> <span class="o">=&gt;</span> <span class="kr">not</span><span class="p"> </span><span class="o">(</span><span class="kr">for</span><span class="p"> </span><span class="kr">some</span><span class="p"> </span><span class="n">J</span> <span class="kr">in</span><span class="p"> </span><span class="n">X</span><span class="na">&#39;Range</span> <span class="o">=&gt;</span> <span class="n">X</span><span class="o">(</span><span class="n">J</span><span class="o">)</span> <span class="o">/=</span> <span class="n">X</span><span class="na">&#39;Old</span><span class="o">(</span><span class="n">J</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>At run time, a quantified expression is executed like a loop, which exits as
soon as the value of the expression is known: if the property does not hold
(resp. holds) for a given element of a universally (resp. existentially)
quantified expression, execution of the loop does not proceed with remaining
elements and returns the value <code class="docutils literal"><span class="pre">False</span></code> (resp. <code class="docutils literal"><span class="pre">True</span></code>) for the expression.</p>
<p>When a quantified expression is analyzed with GNATprove, it uses the logical
counterpart of the quantified expression. GNATprove also checks that the
expression is free from run-time errors. For this checking, GNATprove checks
that the enclosed expression is free from run-time errors over the <em>entire
range</em> of the quantification, not only at points that would actually be reached
at run time. As an example, consider the following expression:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="o">(</span><span class="kr">for</span><span class="p"> </span><span class="kr">all</span><span class="p"> </span><span class="n">I</span> <span class="kr">in</span><span class="p"> </span><span class="mi">1</span> <span class="o">..</span> <span class="mi">10</span> <span class="o">=&gt;</span> <span class="mi">1</span> <span class="o">/</span> <span class="o">(</span><span class="n">I</span> <span class="o">-</span> <span class="mi">3</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
</pre></div>
</div>
<p>This quantified expression cannot raise a run-time error, because the enclosed
expression <code class="docutils literal"><span class="pre">1</span> <span class="pre">/</span> <span class="pre">(I</span> <span class="pre">-</span> <span class="pre">3)</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> is false for the first value of the range <code class="docutils literal"><span class="pre">I</span> <span class="pre">=</span>
<span class="pre">1</span></code>, so the execution of the loop exits immediately with the value <code class="docutils literal"><span class="pre">False</span></code>
for the quantified expression. GNATprove is stricter and requires the
enclosed expression <code class="docutils literal"><span class="pre">1</span> <span class="pre">/</span> <span class="pre">(I</span> <span class="pre">-</span> <span class="pre">3)</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> to be free from run-time errors over
the entire range <code class="docutils literal"><span class="pre">I</span> <span class="pre">in</span> <span class="pre">1</span> <span class="pre">..</span> <span class="pre">10</span></code> (including <code class="docutils literal"><span class="pre">I</span> <span class="pre">=</span> <span class="pre">3</span></code>) so it issues a check
message for a possible division by zero in this case.</p>
<p>Quantified expressions should always be parenthesized.</p>
</div>
<div class="section" id="expression-functions">
<span id="id10"></span><h2>5.5.8. Expression Functions<a class="headerlink" href="#expression-functions" title="Permalink to this headline">¶</a></h2>
<p>[Ada 2012]</p>
<p>An expression function is a function whose implementation is given by a single
expression. For example, the function <code class="docutils literal"><span class="pre">Increment</span></code> can be defined as an
expression function as follows:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">function </span><span class="nf">Increment</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">X</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>For compilation and execution, this definition is equivalent to:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">function </span><span class="nf">Increment</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">is</span><span class="p"></span>
<span class="kr">begin</span><span class="p"></span>
   <span class="kr">return</span><span class="p"> </span><span class="n">X</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Increment</span><span class="p">;</span>
</pre></div>
</div>
<p>For GNATprove, this definition as expression function is equivalent to the
same function body as above, plus a postcondition:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">function </span><span class="nf">Increment</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Post</span> <span class="o">=&gt;</span> <span class="n">Increment</span><span class="na">&#39;Result</span> <span class="o">=</span> <span class="n">X</span> <span class="o">+</span> <span class="mi">1</span>
<span class="kr">is</span><span class="p"></span>
<span class="kr">begin</span><span class="p"></span>
   <span class="kr">return</span><span class="p"> </span><span class="n">X</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Increment</span><span class="p">;</span>
</pre></div>
</div>
<p>Thus, a user does not need in general to add a postcondition to an expression
function, as the implicit postcondition generated by GNATprove is the most
precise one. If a user adds a postcondition to an expression function,
GNATprove uses this postcondition to analyze the function&#8217;s callers as well
as the most precise implicit postcondition.</p>
<p>On the contrary, it may be useful in general to add a precondition to an
expression function, to constrain the contexts in which it can be called. For
example, parameter <code class="docutils literal"><span class="pre">X</span></code> passed to function <code class="docutils literal"><span class="pre">Increment</span></code> should be less than
the maximal integer value, otherwise an overflow would occur. We can specify
this property in <code class="docutils literal"><span class="pre">Increment</span></code>&#8216;s precondition as follows:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">function </span><span class="nf">Increment</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">X</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Pre</span> <span class="o">=&gt;</span> <span class="n">X</span> <span class="o">&lt;</span> <span class="n">Integer</span><span class="na">&#39;Last</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that the contract of an expression function follows its expression.</p>
<p>Expression functions can be defined in package declarations, hence they are
well suited for factoring out common properties that are referred to in
contracts. For example, consider the procedure <code class="docutils literal"><span class="pre">Increment_Array</span></code> that
increments each element of its array parameter <code class="docutils literal"><span class="pre">X</span></code> by one. Its precondition
can be expressed using expression functions as follows:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Increment_Utils</span> <span class="kr">is</span><span class="p"></span>

   <span class="k">function </span><span class="nf">Not_Max</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">X</span> <span class="o">&lt;</span> <span class="n">Integer</span><span class="na">&#39;Last</span><span class="o">)</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">None_Max</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Integer_Array</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span> <span class="kr">is</span><span class="p"></span>
     <span class="o">(</span><span class="kr">for</span><span class="p"> </span><span class="kr">all</span><span class="p"> </span><span class="n">J</span> <span class="kr">in</span><span class="p"> </span><span class="n">X</span><span class="na">&#39;Range</span> <span class="o">=&gt;</span> <span class="n">Not_Max</span> <span class="o">(</span><span class="n">X</span><span class="o">(</span><span class="n">J</span><span class="o">)))</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Increment_Array</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Integer_Array</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
     <span class="n">Pre</span> <span class="o">=&gt;</span> <span class="n">None_Max</span> <span class="o">(</span><span class="n">X</span><span class="o">)</span><span class="p">;</span>

<span class="k">end </span><span class="nf">Increment_Utils</span><span class="p">;</span>
</pre></div>
</div>
<p>Expression functions can be defined over private types, and still be used in
the contracts of publicly visible subprograms of the package, by declaring the
function publicly and defining it in the private part. For example:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Increment_Utils</span> <span class="kr">is</span><span class="p"></span>

   <span class="kr">type</span><span class="p"> </span><span class="n">Integer_Array</span> <span class="kr">is</span><span class="p"> </span><span class="kr">private</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">None_Max</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Integer_Array</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Increment_Array</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Integer_Array</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
     <span class="n">Pre</span> <span class="o">=&gt;</span> <span class="n">None_Max</span> <span class="o">(</span><span class="n">X</span><span class="o">)</span><span class="p">;</span>

<span class="kr">private</span><span class="p"></span>

   <span class="kr">type</span><span class="p"> </span><span class="n">Integer_Array</span> <span class="kr">is</span><span class="p"> </span><span class="kr">array</span><span class="p"> </span><span class="o">(</span><span class="n">Positive</span> <span class="kr">range</span><span class="p"> </span><span class="o">&lt;&gt;)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Not_Max</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">X</span> <span class="o">&lt;</span> <span class="n">Integer</span><span class="na">&#39;Last</span><span class="o">)</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">None_Max</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Integer_Array</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span> <span class="kr">is</span><span class="p"></span>
     <span class="o">(</span><span class="kr">for</span><span class="p"> </span><span class="kr">all</span><span class="p"> </span><span class="n">J</span> <span class="kr">in</span><span class="p"> </span><span class="n">X</span><span class="na">&#39;Range</span> <span class="o">=&gt;</span> <span class="n">Not_Max</span> <span class="o">(</span><span class="n">X</span><span class="o">(</span><span class="n">J</span><span class="o">)))</span><span class="p">;</span>

<span class="k">end </span><span class="nf">Increment_Utils</span><span class="p">;</span>
</pre></div>
</div>
<p>If an expression function is defined in a unit spec, GNATprove can use its
implicit postcondition at every call. If an expression function is defined in a
unit body, GNATprove can use its implicit postcondition at every call in the
same unit, but not at calls inside other units. This is true even if the
expression function is declared in the unit spec and defined in the unit body.</p>
</div>
<div class="section" id="ghost-code">
<span id="id11"></span><h2>5.5.9. Ghost Code<a class="headerlink" href="#ghost-code" title="Permalink to this headline">¶</a></h2>
<p>[SPARK]</p>
<p>Sometimes, the variables and functions that are present in a program are not
sufficient to specify intended properties and to verify these properties with
GNATprove. In such a case, it is possible in SPARK to insert in the program
additional code useful for specification and verification, specially identified
with the aspect <code class="docutils literal"><span class="pre">Ghost</span></code> so that it can be discarded during
compilation. So-called <cite>ghost code</cite> in SPARK are these parts of the code that
are only meant for specification and verification, and have no effect on the
functional behavior of the program.</p>
<p>Various kinds of ghost code are useful in different situations:</p>
<ul class="simple">
<li><cite>Ghost functions</cite> are typically used to express properties used in contracts.</li>
<li><cite>Global ghost variables</cite> are typically used to keep track of the current
state of a program, or to maintain a log of past events of some type. This
information can then be referred to in contracts.</li>
<li><cite>Local ghost variables</cite> are typically used to hold intermediate values during
computation, which can then be referred to in assertion pragmas like loop
invariants.</li>
<li><cite>Ghost types</cite> are those types only useful for defining ghost variables.</li>
<li><cite>Ghost procedures</cite> can be used to factor out common treatments on ghost
variables. Ghost procedures should not have non-ghost outputs, either output
parameters or global outputs.</li>
<li><cite>Ghost packages</cite> provide a means to encapsulate all types and operations for
a specific kind of ghost code.</li>
<li><cite>Imported ghost subprograms</cite> are used to provide placeholders for properties
that are defined in a logical language, when using manual proof.</li>
</ul>
<p>When the program is compiled with assertions (for example with switch
<code class="docutils literal"><span class="pre">-gnata</span></code> in GNAT), ghost code is executed like normal code. Ghost code
can also be selectively enabled by setting pragma <code class="docutils literal"><span class="pre">Assertion_Policy</span></code> as
follows:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Assertion_Policy</span> <span class="o">(</span><span class="n">Ghost</span> <span class="o">=&gt;</span> <span class="n">Check</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>GNATprove checks that ghost code cannot have an effect on the behavior of the
program. GNAT compiler also performs some of these checks, although not
all of them. Apart from these checks, GNATprove treats ghost code like normal
code during its analyses.</p>
<div class="section" id="ghost-functions">
<span id="id12"></span><h3>5.5.9.1. Ghost Functions<a class="headerlink" href="#ghost-functions" title="Permalink to this headline">¶</a></h3>
<p>Ghost functions are useful to express properties only used in contracts, and to
factor out common expressions used in contracts. For example, function
<code class="docutils literal"><span class="pre">Get_Total</span></code> introduced in <a class="reference internal" href="subprogram_contracts.html#state-abstraction-and-functional-contracts"><span class="std std-ref">State Abstraction and Functional Contracts</span></a>
to retrieve the value of variable <code class="docutils literal"><span class="pre">Total</span></code> in the contract of <code class="docutils literal"><span class="pre">Add_To_Total</span></code>
could be marked as a ghost function as follows:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">function </span><span class="nf">Get_Total</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">with</span><span class="p"> </span><span class="n">Ghost</span><span class="p">;</span>
</pre></div>
</div>
<p>and still be used exactly as seen in <a class="reference internal" href="subprogram_contracts.html#state-abstraction-and-functional-contracts"><span class="std std-ref">State Abstraction and Functional Contracts</span></a>:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">Add_To_Total</span> <span class="o">(</span><span class="n">Incr</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Pre</span>  <span class="o">=&gt;</span> <span class="n">Incr</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="kr">and</span><span class="p"> </span><span class="kr">then</span><span class="p"> </span><span class="n">Get_Total</span> <span class="kr">in</span><span class="p"> </span><span class="mi">0</span> <span class="o">..</span> <span class="n">Integer</span><span class="na">&#39;Last</span> <span class="o">-</span> <span class="n">Incr</span><span class="p">,</span>
  <span class="n">Post</span> <span class="o">=&gt;</span> <span class="n">Get_Total</span> <span class="o">=</span> <span class="n">Get_Total</span><span class="na">&#39;Old</span> <span class="o">+</span> <span class="n">Incr</span><span class="p">;</span>
</pre></div>
</div>
<p>The definition of <code class="docutils literal"><span class="pre">Get_Total</span></code> would be also the same:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="n">Total</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>

<span class="k">function </span><span class="nf">Get_Total</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">Total</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>Although it is more common to define ghost functions as <a class="reference internal" href="#expression-functions"><span class="std std-ref">Expression Functions</span></a>, a regular function might be used too:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">function </span><span class="nf">Get_Total</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">is</span><span class="p"></span>
<span class="kr">begin</span><span class="p"></span>
   <span class="kr">return</span><span class="p"> </span><span class="n">Total</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Get_Total</span><span class="p">;</span>
</pre></div>
</div>
<p>In that case, GNATprove uses only the contract of <code class="docutils literal"><span class="pre">Get_Total</span></code> (either
user-specified or the default one) when analyzing its callers, like for a
non-ghost regular function. (The same exception applies as for regular
functions, when GNATprove can analyze a subprogram in the context of its
callers, as described in <a class="reference internal" href="how_to_write_subprogram_contracts.html#contextual-analysis-of-subprograms-without-contracts"><span class="std std-ref">Contextual Analysis of Subprograms Without Contracts</span></a>.)</p>
<p>All functions which are only used in specification can be marked as ghost, but
most don&#8217;t need to. However, there are cases where marking a specification-only
function as ghost really brings something. First, as ghost entities are not
allowed to interfere with normal code, marking a function as ghost avoids having
to break state abstraction for the purpose of specification. For example,
marking <code class="docutils literal"><span class="pre">Get_Total</span></code> as ghost will prevent users of the package <code class="docutils literal"><span class="pre">Account</span></code>
from accessing the value of <code class="docutils literal"><span class="pre">Total</span></code> from non-ghost code.</p>
<p>Then, in the usual context where ghost code is not kept in the final executable,
the user is given more freedom to use in ghost code constructs that are less
efficient than in normal code, which may be useful to express rich
properties. For example, the ghost functions defined in the <a class="reference internal" href="spark_libraries.html#formal-containers-library"><span class="std std-ref">Formal Containers Library</span></a> in GNAT typically copy the entire content of the
argument container, which would not be acceptable for non-ghost functions.</p>
</div>
<div class="section" id="ghost-variables">
<span id="id13"></span><h3>5.5.9.2. Ghost Variables<a class="headerlink" href="#ghost-variables" title="Permalink to this headline">¶</a></h3>
<p>Ghost variables are useful to keep track of local or global information during
the computation, which can then be referred to in contracts or assertion
pragmas.</p>
<div class="section" id="case-1-keeping-intermediate-values">
<h4>Case 1: Keeping Intermediate Values<a class="headerlink" href="#case-1-keeping-intermediate-values" title="Permalink to this headline">¶</a></h4>
<p>Local ghost variables are commonly used to keep intermediate values. For
example, we can define a local ghost variable <code class="docutils literal"><span class="pre">Init_Total</span></code> to hold the
initial value of variable <code class="docutils literal"><span class="pre">Total</span></code> in procedure <code class="docutils literal"><span class="pre">Add_To_Total</span></code>, which allows
checking the relation between the initial and final values of <code class="docutils literal"><span class="pre">Total</span></code> in an
assertion:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">Add_To_Total</span> <span class="o">(</span><span class="n">Incr</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span> <span class="kr">is</span><span class="p"></span>
   <span class="n">Init_Total</span> <span class="o">:</span> <span class="n">Integer</span> <span class="o">:=</span> <span class="n">Total</span> <span class="kr">with</span><span class="p"> </span><span class="n">Ghost</span><span class="p">;</span>
<span class="kr">begin</span><span class="p"></span>
   <span class="n">Total</span> <span class="o">:=</span> <span class="n">Total</span> <span class="o">+</span> <span class="n">Incr</span><span class="p">;</span>
   <span class="kr">pragma</span><span class="p"> </span><span class="n">Assert</span> <span class="o">(</span><span class="n">Total</span> <span class="o">=</span> <span class="n">Init_Total</span> <span class="o">+</span> <span class="n">Incr</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Add_To_Total</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="case-2-keeping-memory-of-previous-state">
<h4>Case 2: Keeping Memory of Previous State<a class="headerlink" href="#case-2-keeping-memory-of-previous-state" title="Permalink to this headline">¶</a></h4>
<p>Global ghost variables are commonly used to memorize the value of a previous
state. For example, we can define a global ghost variable <code class="docutils literal"><span class="pre">Last_Incr</span></code> to hold
the previous value passed in argument when calling procedure <code class="docutils literal"><span class="pre">Add_To_Total</span></code>,
which allows checking in its precondition that the sequence of values passed in
argument is non-decreasing:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="n">Last_Incr</span> <span class="o">:</span> <span class="n">Integer</span> <span class="o">:=</span> <span class="n">Integer</span><span class="na">&#39;First</span> <span class="kr">with</span><span class="p"> </span><span class="n">Ghost</span><span class="p">;</span>

<span class="k">procedure </span><span class="nf">Add_To_Total</span> <span class="o">(</span><span class="n">Incr</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Pre</span> <span class="o">=&gt;</span> <span class="n">Incr</span> <span class="o">&gt;=</span> <span class="n">Last_Incr</span><span class="p">;</span>

<span class="k">procedure </span><span class="nf">Add_To_Total</span> <span class="o">(</span><span class="n">Incr</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span> <span class="kr">is</span><span class="p"></span>
<span class="kr">begin</span><span class="p"></span>
   <span class="n">Total</span> <span class="o">:=</span> <span class="n">Total</span> <span class="o">+</span> <span class="n">Incr</span><span class="p">;</span>
   <span class="n">Last_Incr</span> <span class="o">:=</span> <span class="n">Incr</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Add_To_Total</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="case-3-logging-previous-events">
<h4>Case 3: Logging Previous Events<a class="headerlink" href="#case-3-logging-previous-events" title="Permalink to this headline">¶</a></h4>
<p>Going beyond the previous case, global ghost variables can be used to store a
complete log of events. For example, we can define global ghost variables
<code class="docutils literal"><span class="pre">Log</span></code> and <code class="docutils literal"><span class="pre">Log_Size</span></code> to hold the sequence of values passed in argument to
procedure <code class="docutils literal"><span class="pre">Add_To_Total</span></code>, as in <a class="reference internal" href="package_contracts.html#state-abstraction"><span class="std std-ref">State Abstraction</span></a>:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="n">Log</span>      <span class="o">:</span> <span class="n">Integer_Array</span> <span class="kr">with</span><span class="p"> </span><span class="n">Ghost</span><span class="p">;</span>
<span class="n">Log_Size</span> <span class="o">:</span> <span class="n">Natural</span> <span class="kr">with</span><span class="p"> </span><span class="n">Ghost</span><span class="p">;</span>

<span class="k">procedure </span><span class="nf">Add_To_Total</span> <span class="o">(</span><span class="n">Incr</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Post</span> <span class="o">=&gt;</span> <span class="n">Log_Size</span> <span class="o">=</span> <span class="n">Log_Size</span><span class="na">&#39;Old</span> <span class="o">+</span> <span class="mi">1</span> <span class="kr">and</span><span class="p"> </span><span class="n">Log</span> <span class="o">=</span> <span class="n">Log</span><span class="na">&#39;Old&#39;Update</span> <span class="o">(</span><span class="n">Log_Size</span> <span class="o">=&gt;</span> <span class="n">Incr</span><span class="o">)</span><span class="p">;</span>

<span class="k">procedure </span><span class="nf">Add_To_Total</span> <span class="o">(</span><span class="n">Incr</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span> <span class="kr">is</span><span class="p"></span>
<span class="kr">begin</span><span class="p"></span>
   <span class="n">Total</span> <span class="o">:=</span> <span class="n">Total</span> <span class="o">+</span> <span class="n">Incr</span><span class="p">;</span>
   <span class="n">Log_Size</span> <span class="o">:=</span> <span class="n">Log_Size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">Log</span> <span class="o">(</span><span class="n">Log_Size</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Incr</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Add_To_Total</span><span class="p">;</span>
</pre></div>
</div>
<p>The postcondition of <code class="docutils literal"><span class="pre">Add_To_Total</span></code> above expresses that <code class="docutils literal"><span class="pre">Log_Size</span></code> is
incremented by one at each call, and that the current value of parameter
<code class="docutils literal"><span class="pre">Incr</span></code> is appended to <code class="docutils literal"><span class="pre">Log</span></code> at each call (using <a class="reference internal" href="#attribute-old"><span class="std std-ref">Attribute Old</span></a> and
<a class="reference internal" href="#attribute-update"><span class="std std-ref">Attribute Update</span></a>).</p>
</div>
<div class="section" id="case-4-expressing-existentially-quantified-properties">
<h4>Case 4: Expressing Existentially Quantified Properties<a class="headerlink" href="#case-4-expressing-existentially-quantified-properties" title="Permalink to this headline">¶</a></h4>
<p>In SPARK, universal quantification is only allowed in restricted cases
(over integer ranges and over the content of a container). To express the
existence of a particular object, it is sometimes easier to simply provide it.
This can be done using a global ghost variable. This can be used in particular
to split the specification of a complex procedure into smaller parts:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="n">X_Interm</span> <span class="o">:</span> <span class="n">T</span> <span class="kr">with</span><span class="p"> </span><span class="n">Ghost</span><span class="p">;</span>

<span class="k">procedure </span><span class="nf">Do_Two_Thing</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">T</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Post</span> <span class="o">=&gt;</span> <span class="n">First_Thing_Done</span> <span class="o">(</span><span class="n">X</span><span class="na">&#39;Old</span><span class="p">,</span> <span class="n">X_Interm</span><span class="o">)</span> <span class="kr">and</span><span class="p"> </span><span class="kr">then</span><span class="p"></span>
          <span class="n">Second_Thing_Done</span> <span class="o">(</span><span class="n">X_Interm</span><span class="p">,</span> <span class="n">X</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
  <span class="n">X_Init</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="n">T</span> <span class="o">:=</span> <span class="n">X</span> <span class="kr">with</span><span class="p"> </span><span class="n">Ghost</span><span class="p">;</span>
<span class="kr">begin</span><span class="p"></span>
  <span class="n">Do_Something</span> <span class="o">(</span><span class="n">X</span><span class="o">)</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Assert</span> <span class="o">(</span><span class="n">First_Thing_Done</span> <span class="o">(</span><span class="n">X_Init</span><span class="p">,</span> <span class="n">X</span><span class="o">))</span><span class="p">;</span>
  <span class="n">X_Interm</span> <span class="o">:=</span> <span class="n">X</span><span class="p">;</span>

  <span class="n">Do_Something_Else</span> <span class="o">(</span><span class="n">X</span><span class="o">)</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Assert</span> <span class="o">(</span><span class="n">Second_Thing_Done</span> <span class="o">(</span><span class="n">X_Interm</span><span class="p">,</span> <span class="n">X</span><span class="o">))</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Do_Two_Things</span><span class="p">;</span>
</pre></div>
</div>
<p>More complicated uses can also be envisioned, up to constructing ghost data
structures reflecting complex properties. For example, we can express that two
arrays are a permutation of each other by constructing a permutation from one
to the other:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="n">Perm</span> <span class="o">:</span> <span class="n">Permutation</span> <span class="kr">with</span><span class="p"> </span><span class="n">Ghost</span><span class="p">;</span>

<span class="k">procedure </span><span class="nf">Permutation_Sort</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Nat_Array</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Post</span> <span class="o">=&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">Apply_Perm</span> <span class="o">(</span><span class="n">Perm</span><span class="p">,</span> <span class="n">A</span><span class="na">&#39;Old</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
<span class="kr">begin</span><span class="p"></span>
  <span class="c">--  Initalize Perm with the identity</span>
  <span class="n">Perm</span> <span class="o">:=</span> <span class="n">Identity_Perm</span><span class="p">;</span>

  <span class="kr">for</span><span class="p"> </span><span class="n">Current</span> <span class="kr">in</span><span class="p"> </span><span class="n">A</span><span class="na">&#39;First</span> <span class="o">..</span> <span class="n">A</span><span class="na">&#39;Last</span> <span class="o">-</span> <span class="mi">1</span> <span class="kr">loop</span><span class="p"></span>
    <span class="n">Smallest</span> <span class="o">:=</span> <span class="n">Index_Of_Minimum_Value</span> <span class="o">(</span><span class="n">A</span><span class="p">,</span> <span class="n">Current</span><span class="p">,</span> <span class="n">A</span><span class="na">&#39;Last</span><span class="o">)</span><span class="p">;</span>
    <span class="kr">if</span><span class="p"> </span><span class="n">Smallest</span> <span class="o">/=</span> <span class="n">Current</span> <span class="kr">then</span><span class="p"></span>
      <span class="n">Swap</span> <span class="o">(</span><span class="n">A</span><span class="p">,</span> <span class="n">Current</span><span class="p">,</span> <span class="n">Smallest</span><span class="o">)</span><span class="p">;</span>

      <span class="c">--  Update Perm each time we permute two elements in A</span>
      <span class="n">Permute</span> <span class="o">(</span><span class="n">Perm</span><span class="p">,</span> <span class="n">Current</span><span class="p">,</span> <span class="n">Smallest</span><span class="o">)</span><span class="p">;</span>
    <span class="k">end if</span><span class="p">;</span>
   <span class="k">end loop</span><span class="p">;</span>
 <span class="k">end </span><span class="nf">Permutation_Sort</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="ghost-types">
<span id="id14"></span><h3>5.5.9.3. Ghost Types<a class="headerlink" href="#ghost-types" title="Permalink to this headline">¶</a></h3>
<p>Ghost types can only be used to define ghost variables. For example, we can
define ghost types <code class="docutils literal"><span class="pre">Log_Type</span></code> and <code class="docutils literal"><span class="pre">Log_Size_Type</span></code> that specialize the types
<code class="docutils literal"><span class="pre">Integer_Array</span></code> and <code class="docutils literal"><span class="pre">Natural</span></code> for ghost variables:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="kr">subtype</span><span class="p"> </span><span class="n">Log_Type</span> <span class="kr">is</span><span class="p"> </span><span class="n">Integer_Array</span> <span class="kr">with</span><span class="p"> </span><span class="n">Ghost</span><span class="p">;</span>
<span class="kr">subtype</span><span class="p"> </span><span class="n">Log_Size_Type</span> <span class="kr">is</span><span class="p"> </span><span class="n">Natural</span> <span class="kr">with</span><span class="p"> </span><span class="n">Ghost</span><span class="p">;</span>

<span class="n">Log</span>      <span class="o">:</span> <span class="n">Log_Type</span> <span class="kr">with</span><span class="p"> </span><span class="n">Ghost</span><span class="p">;</span>
<span class="n">Log_Size</span> <span class="o">:</span> <span class="n">Log_Size_Type</span> <span class="kr">with</span><span class="p"> </span><span class="n">Ghost</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="ghost-procedures">
<h3>5.5.9.4. Ghost Procedures<a class="headerlink" href="#ghost-procedures" title="Permalink to this headline">¶</a></h3>
<p>Ghost procedures are useful to factor out common treatments on ghost
variables. For example, we can define a ghost procedure <code class="docutils literal"><span class="pre">Append_To_Log</span></code> to
append a value to the log as seen previously.</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="n">Log</span>      <span class="o">:</span> <span class="n">Integer_Array</span> <span class="kr">with</span><span class="p"> </span><span class="n">Ghost</span><span class="p">;</span>
<span class="n">Log_Size</span> <span class="o">:</span> <span class="n">Natural</span> <span class="kr">with</span><span class="p"> </span><span class="n">Ghost</span><span class="p">;</span>

<span class="k">procedure </span><span class="nf">Append_To_Log</span> <span class="o">(</span><span class="n">Incr</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Ghost</span><span class="p">,</span>
  <span class="n">Post</span> <span class="o">=&gt;</span> <span class="n">Log_Size</span> <span class="o">=</span> <span class="n">Log_Size</span><span class="na">&#39;Old</span> <span class="o">+</span> <span class="mi">1</span> <span class="kr">and</span><span class="p"> </span><span class="n">Log</span> <span class="o">=</span> <span class="n">Log</span><span class="na">&#39;Old&#39;Update</span> <span class="o">(</span><span class="n">Log_Size</span> <span class="o">=&gt;</span> <span class="n">Incr</span><span class="o">)</span><span class="p">;</span>

<span class="k">procedure </span><span class="nf">Append_To_Log</span> <span class="o">(</span><span class="n">Incr</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span> <span class="kr">is</span><span class="p"></span>
<span class="kr">begin</span><span class="p"></span>
   <span class="n">Log_Size</span> <span class="o">:=</span> <span class="n">Log_Size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">Log</span> <span class="o">(</span><span class="n">Log_Size</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Incr</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Append_To_Log</span><span class="p">;</span>
</pre></div>
</div>
<p>Then, this procedure can be called in <code class="docutils literal"><span class="pre">Add_To_Total</span></code> as follows:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">Add_To_Total</span> <span class="o">(</span><span class="n">Incr</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span> <span class="kr">is</span><span class="p"></span>
<span class="kr">begin</span><span class="p"></span>
   <span class="n">Total</span> <span class="o">:=</span> <span class="n">Total</span> <span class="o">+</span> <span class="n">Incr</span><span class="p">;</span>
   <span class="n">Append_To_Log</span> <span class="o">(</span><span class="n">Incr</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Add_To_Total</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="ghost-packages">
<span id="id15"></span><h3>5.5.9.5. Ghost Packages<a class="headerlink" href="#ghost-packages" title="Permalink to this headline">¶</a></h3>
<p>Ghost packages are useful to encapsulate all types and operations for a
specific kind of ghost code. For example, we can define a ghost package
<code class="docutils literal"><span class="pre">Logging</span></code> to deal with all logging operations on package <code class="docutils literal"><span class="pre">Account</span></code>:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Logging</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Ghost</span>
<span class="kr">is</span><span class="p"></span>
   <span class="n">Log</span>      <span class="o">:</span> <span class="n">Integer_Array</span><span class="p">;</span>
   <span class="n">Log_Size</span> <span class="o">:</span> <span class="n">Natural</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Append_To_Log</span> <span class="o">(</span><span class="n">Incr</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
     <span class="n">Post</span> <span class="o">=&gt;</span> <span class="n">Log_Size</span> <span class="o">=</span> <span class="n">Log_Size</span><span class="na">&#39;Old</span> <span class="o">+</span> <span class="mi">1</span> <span class="kr">and</span><span class="p"> </span><span class="n">Log</span> <span class="o">=</span> <span class="n">Log</span><span class="na">&#39;Old&#39;Update</span> <span class="o">(</span><span class="n">Log_Size</span> <span class="o">=&gt;</span> <span class="n">Incr</span><span class="o">)</span><span class="p">;</span>

   <span class="o">...</span>

<span class="k">end </span><span class="nf">Logging</span><span class="p">;</span>
</pre></div>
</div>
<p>The implementation of package <code class="docutils literal"><span class="pre">Logging</span></code> is the same as if it was not a ghost
package. In particular, a <code class="docutils literal"><span class="pre">Ghost</span></code> aspect is implicitly added to all
declarations in <code class="docutils literal"><span class="pre">Logging</span></code>, so it is not necessary to specify it explicitly.
<code class="docutils literal"><span class="pre">Logging</span></code> can be defined either as a local ghost package or as a separate
unit. In the latter case, unit <code class="docutils literal"><span class="pre">Account</span></code> needs to reference unit <code class="docutils literal"><span class="pre">Logging</span></code>
in a with-clause like for a non-ghost unit:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">Logging</span><span class="p">;</span>

<span class="k">package </span><span class="nf">Account</span> <span class="kr">is</span><span class="p"></span>
   <span class="o">...</span>
<span class="k">end </span><span class="nf">Account</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="imported-ghost-subprograms">
<h3>5.5.9.6. Imported Ghost Subprograms<a class="headerlink" href="#imported-ghost-subprograms" title="Permalink to this headline">¶</a></h3>
<p>When using manual proof (see <a class="reference internal" href="how_to_run_gnatprove.html#gnatprove-and-manual-proof"><span class="std std-ref">GNATprove and Manual Proof</span></a>), it may be more
convenient to define some properties in the logical language of the prover
rather than in SPARK. In that case, ghost functions might be marked as
imported, so that no implementation is needed. For example, the ghost procedure
<code class="docutils literal"><span class="pre">Append_To_Log</span></code> seen previously may be defined equivalently as a ghost
imported function as follows:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">function </span><span class="nf">Append_To_Log</span> <span class="o">(</span><span class="n">Log</span> <span class="o">:</span> <span class="n">Log_type</span><span class="p">;</span> <span class="n">Incr</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Log_Type</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Ghost</span><span class="p">,</span>
  <span class="n">Import</span><span class="p">;</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">Log_Type</span></code> is an Ada type used also as placeholder for a type in the
logical language of the prover. To avoid any inconsistency between the
interpretations of <code class="docutils literal"><span class="pre">Log_Type</span></code> in GNATprove and in the manual prover, it is
preferable in such a case to mark the definition of <code class="docutils literal"><span class="pre">Log_Type</span></code> as not in
SPARK, so that GNATprove does not make any assumptions on its content. This
can be achieved by defining <code class="docutils literal"><span class="pre">Log_Type</span></code> as a private type and marking the
private part of the enclosing package as not in SPARK:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Logging</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">SPARK_Mode</span><span class="p">,</span>
  <span class="n">Ghost</span>
<span class="kr">is</span><span class="p"></span>
   <span class="kr">type</span><span class="p"> </span><span class="n">Log_Type</span> <span class="kr">is</span><span class="p"> </span><span class="kr">private</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Append_To_Log</span> <span class="o">(</span><span class="n">Log</span> <span class="o">:</span> <span class="n">Log_type</span><span class="p">;</span> <span class="n">Incr</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Log_Type</span> <span class="kr">with</span><span class="p"></span>
     <span class="n">Import</span><span class="p">;</span>

   <span class="o">...</span>

<span class="kr">private</span><span class="p"></span>
   <span class="kr">pragma</span><span class="p"> </span><span class="n">SPARK_Mode</span> <span class="o">(</span><span class="n">Off</span><span class="o">)</span><span class="p">;</span>

   <span class="kr">type</span><span class="p"> </span><span class="n">Log_Type</span> <span class="kr">is</span><span class="p"> </span><span class="kr">new</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>  <span class="c">--  Any definition is fine here</span>
<span class="k">end </span><span class="nf">Logging</span><span class="p">;</span>
</pre></div>
</div>
<p>A ghost imported subprogram cannot be executed, so calls to <code class="docutils literal"><span class="pre">Append_To_Log</span></code>
above should not be enabled during compilation, otherwise a compilation error
is issued. Note also that GNATprove will not attempt proving the contract of
a ghost imported subprogram, as it does not have its body.</p>
</div>
<div class="section" id="ghost-models">
<span id="id16"></span><h3>5.5.9.7. Ghost Models<a class="headerlink" href="#ghost-models" title="Permalink to this headline">¶</a></h3>
<p>When specifying a program, it is common to use a model, that is, an alternative,
simpler view of a part of the program. As they are only used in annotations,
models can be computed using ghost code.</p>
<div class="section" id="models-of-control-flow">
<h4>Models of Control Flow<a class="headerlink" href="#models-of-control-flow" title="Permalink to this headline">¶</a></h4>
<p>Global variables can be used to enforce properties over call cahains in the
program. For example, we may want to express that <code class="docutils literal"><span class="pre">Total</span></code> cannot be
incremented twice in a row without registering the transaction in between. This
can be done by introducing a ghost global variable
<code class="docutils literal"><span class="pre">Last_Transaction_Registered</span></code>, used to encode whether <code class="docutils literal"><span class="pre">Register_Transaction</span></code>
was called since the last call to <code class="docutils literal"><span class="pre">Add_To_Total</span></code>:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="n">Last_Transaction_Registered</span> <span class="o">:</span> <span class="n">Boolean</span> <span class="o">:=</span> <span class="kc">True</span> <span class="kr">with</span><span class="p"> </span><span class="n">Ghost</span><span class="p">;</span>

<span class="k">procedure </span><span class="nf">Add_To_Total</span> <span class="o">(</span><span class="n">Incr</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Pre</span>  <span class="o">=&gt;</span> <span class="n">Last_Transaction_Registered</span><span class="p">,</span>
  <span class="n">Post</span> <span class="o">=&gt;</span> <span class="kr">not</span><span class="p"> </span><span class="n">Last_Transaction_Registered</span><span class="p">;</span>

<span class="k">procedure </span><span class="nf">Register_Transaction</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Post</span> <span class="o">=&gt;</span> <span class="n">Last_Transaction_Registered</span><span class="p">;</span>
</pre></div>
</div>
<p>The value of Last_Transaction_Registered should also be updated in the body of
<code class="docutils literal"><span class="pre">Add_To_Total</span></code> and <code class="docutils literal"><span class="pre">Register_Transaction</span></code> to reflect their contracts:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">Add_To_Total</span> <span class="o">(</span><span class="n">Incr</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Integer</span><span class="o">)</span> <span class="kr">is</span><span class="p"></span>
<span class="kr">begin</span><span class="p"></span>
   <span class="n">Total</span> <span class="o">:=</span> <span class="n">Total</span> <span class="o">+</span> <span class="n">Incr</span><span class="p">;</span>
   <span class="n">Last_Transaction_Registered</span> <span class="o">:=</span> <span class="kc">False</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Add_To_Total</span><span class="p">;</span>
</pre></div>
</div>
<p>More generally, the expected control flow of a program can be modeled using an
automaton. We can take as an example a mailbox containing only one message.
The expected way <code class="docutils literal"><span class="pre">Receive</span></code> and <code class="docutils literal"><span class="pre">Send</span></code> should be interleaved can be expressed
as a two state automaton. The mailbox can either be full, in which case
<code class="docutils literal"><span class="pre">Receive</span></code> can be called but not <code class="docutils literal"><span class="pre">Send</span></code>, or it can be empty, in which case it
is <code class="docutils literal"><span class="pre">Send</span></code> that can be called and not <code class="docutils literal"><span class="pre">Receive</span></code>. To express this property, we
can define a ghost global variable of a ghost enumeration type to hold the
state of the automaton:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="p"> </span><span class="n">Mailbox_Status_Kind</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">Empty</span><span class="p">,</span> <span class="n">Full</span><span class="o">)</span> <span class="kr">with</span><span class="p"> </span><span class="n">Ghost</span><span class="p">;</span>
<span class="n">Mailbox_Status</span> <span class="o">:</span> <span class="n">Mailbox_Status_Kind</span> <span class="o">:=</span> <span class="n">Empty</span> <span class="kr">with</span><span class="p"> </span><span class="n">Ghost</span><span class="p">;</span>

<span class="k">procedure </span><span class="nf">Receive</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Message</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Pre</span>  <span class="o">=&gt;</span> <span class="n">Mailbox_Status</span> <span class="o">=</span> <span class="n">Full</span><span class="p">,</span>
  <span class="n">Post</span> <span class="o">=&gt;</span> <span class="n">Mailbox_Status</span> <span class="o">=</span> <span class="n">Empty</span><span class="p">;</span>

<span class="k">procedure </span><span class="nf">Send</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Message</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Pre</span>  <span class="o">=&gt;</span> <span class="n">Mailbox_Status</span> <span class="o">=</span> <span class="n">Empty</span><span class="p">,</span>
  <span class="n">Post</span> <span class="o">=&gt;</span> <span class="n">Mailbox_Status</span> <span class="o">=</span> <span class="n">Full</span><span class="p">;</span>
</pre></div>
</div>
<p>Like before, <code class="docutils literal"><span class="pre">Receive</span></code> and <code class="docutils literal"><span class="pre">Send</span></code> should update <code class="docutils literal"><span class="pre">Mailbox_Status</span></code> in their
bodies.
Note that all the transitions of the automaton need not be specified, only the
part which are relevant to the properties we want to express.</p>
<p>If the program also has some regular state, an invariant can be used to link
the value of this state to the value of the ghost state of the automaton. For
example, in our mailbox, we may have a regular variable <code class="docutils literal"><span class="pre">Message_Content</span></code>
holding the content of the current message, which is only known to be valid
after a call to <code class="docutils literal"><span class="pre">Send</span></code>. We can introduce a ghost function linking the value
of <code class="docutils literal"><span class="pre">Message_Content</span></code> to the value of <code class="docutils literal"><span class="pre">Mailbox_Status</span></code>, so that we can
ensure that <code class="docutils literal"><span class="pre">Message_Content</span></code> is always valid when accessed from <code class="docutils literal"><span class="pre">Receive</span></code>:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">function </span><span class="nf">Invariant</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span> <span class="kr">is</span><span class="p"></span>
  <span class="o">(</span><span class="kr">if</span><span class="p"> </span><span class="n">Mailbox_Status</span> <span class="o">=</span> <span class="n">Full</span> <span class="kr">then</span><span class="p"> </span><span class="n">Valid</span> <span class="o">(</span><span class="n">Message_Content</span><span class="o">))</span><span class="p"></span>
<span class="kr">with</span><span class="nn"> Ghost;</span>

<span class="k">procedure </span><span class="nf">Receive</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">Message</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Pre</span>  <span class="o">=&gt;</span> <span class="n">Invariant</span> <span class="kr">and</span><span class="p"> </span><span class="kr">then</span><span class="p"> </span><span class="n">Mailbox_Status</span> <span class="o">=</span> <span class="n">Full</span><span class="p">,</span>
  <span class="n">Post</span> <span class="o">=&gt;</span> <span class="n">Invariant</span> <span class="kr">and</span><span class="p"> </span><span class="kr">then</span><span class="p"> </span><span class="n">Mailbox_Status</span> <span class="o">=</span> <span class="n">Empty</span>
      <span class="kr">and</span><span class="p"> </span><span class="kr">then</span><span class="p"> </span><span class="n">Valid</span> <span class="o">(</span><span class="n">X</span><span class="o">)</span>
<span class="kr">is</span><span class="p"></span>
  <span class="n">X</span> <span class="o">:=</span> <span class="n">Message_Content</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Receive</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="models-of-data-structures">
<h4>Models of Data Structures<a class="headerlink" href="#models-of-data-structures" title="Permalink to this headline">¶</a></h4>
<p>For specifying programs that use complex data structures (doubly-linked lists,
maps...), it can be useful to supply a model for the data structure. A model
is an alternative, simpler view of the data-structure which allows to write
properties more easily. For example, a ring buffer, or a doubly-linked list, can
be modeled using an array containing the elements from the buffer or the list in
the right order. Typically, though simpler to reason with, the model is less
efficient than the regular data structure. For example, inserting an element at
the beginning of a doubly-linked list or at the beginning of a ring buffer can
be done in constant time whereas inserting an element at the beginning of an
array requires to slide all the elements to the right. As a result, models of
data structures are usually supplied using ghost code. As an example, the
package <code class="docutils literal"><span class="pre">Ring_Buffer</span></code> offers an implementation of a single instance ring
buffer. A ghost variable <code class="docutils literal"><span class="pre">Buffer_Model</span></code> is used to write the specification of
the <code class="docutils literal"><span class="pre">Enqueue</span></code> procedure:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Ring_Buffer</span> <span class="kr">is</span><span class="p"></span>
  <span class="k">function </span><span class="nf">Get_Model</span> <span class="kr">return</span><span class="p"> </span><span class="n">Nat_Array</span> <span class="kr">with</span><span class="p"> </span><span class="n">Ghost</span><span class="p">;</span>

  <span class="k">procedure </span><span class="nf">Enqueue</span> <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="n">Natural</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
    <span class="n">Post</span> <span class="o">=&gt;</span> <span class="n">Get_Model</span> <span class="o">=</span> <span class="n">E</span> <span class="o">&amp;</span> <span class="n">Get_Model</span><span class="na">&#39;Old</span> <span class="o">(</span><span class="mi">1</span> <span class="o">..</span> <span class="n">Max</span> – <span class="mi">1</span><span class="o">)</span><span class="p">;</span>
<span class="kr">private</span><span class="p"></span>
  <span class="n">Buffer_Content</span> <span class="o">:</span> <span class="n">Nat_Array</span><span class="p">;</span>
  <span class="n">Buffer_Top</span>     <span class="o">:</span> <span class="n">Natural</span><span class="p">;</span>
  <span class="n">Buffer_Model</span>   <span class="o">:</span> <span class="n">Nat_Array</span> <span class="kr">with</span><span class="p"> </span><span class="n">Ghost</span><span class="p">;</span>

  <span class="k">function </span><span class="nf">Get_Model</span> <span class="kr">return</span><span class="p"> </span><span class="n">Nat_Array</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">Buffer_Model</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Ring_Buffer</span><span class="p">;</span>
</pre></div>
</div>
<p>Then, just like for models of control flow, an invariant should be supplied to
link the regular data structure to its model:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Ring_Buffer</span> <span class="kr">is</span><span class="p"></span>
  <span class="k">function </span><span class="nf">Get_Model</span> <span class="kr">return</span><span class="p"> </span><span class="n">Nat_Array</span> <span class="kr">with</span><span class="p"> </span><span class="n">Ghost</span><span class="p">;</span>
  <span class="k">function </span><span class="nf">Invariant</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span> <span class="kr">with</span><span class="p"> </span><span class="n">Ghost</span><span class="p">;</span>

  <span class="k">procedure </span><span class="nf">Enqueue</span> <span class="o">(</span><span class="n">E</span> <span class="o">:</span> <span class="n">Natural</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
    <span class="n">Pre</span>  <span class="o">=&gt;</span> <span class="n">Invariant</span><span class="p">,</span>
    <span class="n">Post</span> <span class="o">=&gt;</span> <span class="n">Invariant</span> <span class="kr">and</span><span class="p"> </span><span class="kr">then</span><span class="p"> </span><span class="n">Get_Model</span> <span class="o">=</span> <span class="n">E</span> <span class="o">&amp;</span> <span class="n">Get_Model</span><span class="na">&#39;Old</span> <span class="o">(</span><span class="mi">1</span> <span class="o">..</span> <span class="n">Max</span> – <span class="mi">1</span><span class="o">)</span><span class="p">;</span>
<span class="kr">private</span><span class="p"></span>
  <span class="n">Buffer_Content</span> <span class="o">:</span> <span class="n">Nat_Array</span><span class="p">;</span>
  <span class="n">Buffer_Top</span>     <span class="o">:</span> <span class="n">Natural</span><span class="p">;</span>
  <span class="n">Buffer_Model</span>   <span class="o">:</span> <span class="n">Nat_Array</span> <span class="kr">with</span><span class="p"> </span><span class="n">Ghost</span><span class="p">;</span>

  <span class="k">function </span><span class="nf">Get_Model</span> <span class="kr">return</span><span class="p"> </span><span class="n">Nat_Array</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">Buffer_Model</span><span class="o">)</span><span class="p">;</span>
  <span class="k">function </span><span class="nf">Invariant</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span> <span class="kr">is</span><span class="p"></span>
    <span class="o">(</span><span class="n">Buffer_Model</span> <span class="o">=</span> <span class="n">Buffer_Content</span> <span class="o">(</span><span class="n">Buffer_Top</span> <span class="o">..</span> <span class="n">Max</span><span class="o">)</span>
                  <span class="o">&amp;</span> <span class="n">Buffer_Content</span> <span class="o">(</span><span class="mi">1</span> <span class="o">..</span> <span class="n">Buffer_Top</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Ring_Buffer</span><span class="p">;</span>
</pre></div>
</div>
<p>If a data structure type is defined, a ghost function can be provided to
compute a model for objects of the data structure type, and the invariant can
be stated as a postcondition of this function:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Ring_Buffer</span> <span class="kr">is</span><span class="p"></span>
  <span class="kr">type</span><span class="p"> </span><span class="n">Buffer_Type</span> <span class="kr">is</span><span class="p"> </span><span class="kr">private</span><span class="p">;</span>
  <span class="kr">subtype</span><span class="p"> </span><span class="n">Model_Type</span> <span class="kr">is</span><span class="p"> </span><span class="n">Nat_Array</span> <span class="kr">with</span><span class="p"> </span><span class="n">Ghost</span><span class="p">;</span>

  <span class="k">function </span><span class="nf">Invariant</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Buffer_Type</span><span class="p">;</span> <span class="n">M</span> <span class="o">:</span> <span class="n">Model_Type</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span> <span class="kr">with</span><span class="p"></span>
    <span class="n">Ghost</span><span class="p">;</span>
  <span class="k">function </span><span class="nf">Get_Model</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Buffer_Type</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Model_Type</span> <span class="kr">with</span><span class="p"></span>
    <span class="n">Ghost</span><span class="p">,</span>
    <span class="n">Post</span> <span class="o">=&gt;</span> <span class="n">Invariant</span> <span class="o">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Get_Model</span><span class="na">&#39;Result</span><span class="o">)</span><span class="p">;</span>

  <span class="k">procedure </span><span class="nf">Enqueue</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Buffer_Type</span><span class="p">;</span> <span class="n">E</span> <span class="o">:</span> <span class="n">Natural</span><span class="o">)</span> <span class="kr">with</span><span class="p"></span>
    <span class="n">Post</span> <span class="o">=&gt;</span> <span class="n">Get_Model</span> <span class="o">(</span><span class="n">X</span><span class="o">)</span> <span class="o">=</span> <span class="n">E</span> <span class="o">&amp;</span> <span class="n">Get_Model</span> <span class="o">(</span><span class="n">X</span><span class="o">)</span><span class="na">&#39;Old</span> <span class="o">(</span><span class="mi">1</span> <span class="o">..</span> <span class="n">Max</span> – <span class="mi">1</span><span class="o">)</span><span class="p">;</span>
<span class="kr">private</span><span class="p"></span>
  <span class="kr">type</span><span class="p"> </span><span class="n">Buffer_Type</span> <span class="kr">is</span><span class="p"> </span><span class="kr">record</span><span class="p"></span>
    <span class="n">Content</span> <span class="o">:</span> <span class="n">Nat_Array</span><span class="p">;</span>
    <span class="n">Top</span>     <span class="o">:</span> <span class="n">Natural</span><span class="p">;</span>
  <span class="k">end record</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Ring_Buffer</span><span class="p">;</span>
</pre></div>
</div>
<p>More complex examples of models of data structure can be found in the
<a class="reference internal" href="spark_libraries.html#formal-containers-library"><span class="std std-ref">Formal Containers Library</span></a>.</p>
</div>
</div>
<div class="section" id="removal-of-ghost-code">
<span id="id17"></span><h3>5.5.9.8. Removal of Ghost Code<a class="headerlink" href="#removal-of-ghost-code" title="Permalink to this headline">¶</a></h3>
<p>By default, GNAT completely discards ghost code during compilation, so
that no ghost code is present in the object code or the executable. This
ensures that, even if parts of the ghost could have side-effects when executed
(writing to variables, performing system calls, raising exceptions, etc.), by
default the compiler ensures that it cannot have any effect on the behavior of
the program.</p>
<p>This is also essential in domains submitted to certification where all
instructions in the object code should be traceable to source code and
requirements, and where testing should ensure coverage of the object code. As
ghost code is not present in the object code, there is no additional cost for
maintaining its traceability and ensuring its coverage by tests.</p>
<p>GNAT provides an easy means to check that no ignored ghost code is
present in a given object code or executable, which relies on the property
that, by definition, each ghost declaration or ghost statement mentions at
least one ghost entity. GNAT prefixes all names of such ignored ghost
entities in the object code with the string <code class="docutils literal"><span class="pre">___ghost_</span></code> (except for names of
ghost compilation units). The initial triple underscore ensures that this
substring cannot appear anywhere in the name of non-ghost entities or ghost
entities that are not ignored. Thus, one only needs to check that the substring
<code class="docutils literal"><span class="pre">___ghost_</span></code> does not appear in the list of names from the object code or
executable.</p>
<p>On Unix-like platforms, this can done by checking that the following command
does not output anything:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">nm</span> <span class="o">&lt;</span><span class="nb">object</span> <span class="n">files</span> <span class="ow">or</span> <span class="n">executable</span><span class="o">&gt;</span> <span class="o">|</span> <span class="n">grep</span> <span class="n">___ghost_</span>
</pre></div>
</div>
<p>The same can be done to check that a ghost compilation unit called <code class="docutils literal"><span class="pre">my_unit</span></code>
(whatever the capitalization) is not included at all (entities in that unit
would have been detected by the previous check) in the object code or
executable. For example on Unix-like platforms:</p>
<blockquote>
<div>nm &lt;object files or executable&gt; | grep my_unit</div></blockquote>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="assertion_pragmas.html" title="5.6. Assertion Pragmas"
             >next</a> |</li>
        <li class="right" >
          <a href="type_contracts.html" title="5.4. Type Contracts"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">SPARK 2014 User&#39;s Guide 2019</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../spark_2014.html" >5. Overview of SPARK Language</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2011-2019, AdaCore and Altran UK Ltd.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.2.
    </div>
  </body>
</html>