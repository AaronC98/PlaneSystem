<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>8. Applying SPARK in Practice &#8212; SPARK 2014 User&#39;s Guide 2019</title>
    
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2019',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Command Line Invocation" href="appendix/command_line_invocation.html" />
    <link rel="prev" title="7.10. Examples in the Toolset Distribution" href="source/examples_in_the_toolset_distribution.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="appendix/command_line_invocation.html" title="Command Line Invocation"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="source/examples_in_the_toolset_distribution.html" title="7.10. Examples in the Toolset Distribution"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">SPARK 2014 User&#39;s Guide 2019</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">8. Applying SPARK in Practice</a><ul>
<li><a class="reference internal" href="#objectives-of-using-spark">8.1. Objectives of Using SPARK</a><ul>
<li><a class="reference internal" href="#safe-coding-standard-for-critical-software">8.1.1. Safe Coding Standard for Critical Software</a><ul>
<li><a class="reference internal" href="#exclusion-of-unsafe-ada-features">8.1.1.1. Exclusion of Unsafe Ada Features</a></li>
<li><a class="reference internal" href="#early-detection-of-errors">8.1.1.2. Early Detection of Errors</a></li>
</ul>
</li>
<li><a class="reference internal" href="#prove-absence-of-run-time-errors-aorte">8.1.2. Prove Absence of Run-Time Errors (AoRTE)</a><ul>
<li><a class="reference internal" href="#with-proof-only">8.1.2.1. With Proof Only</a></li>
<li><a class="reference internal" href="#with-a-combination-of-proof-and-test">8.1.2.2. With a Combination of Proof and Test</a><ul>
<li><a class="reference internal" href="#at-the-level-of-individual-run-time-checks">At the Level of Individual Run-Time Checks</a></li>
<li><a class="reference internal" href="#between-proof-and-integration-testing">Between Proof and Integration Testing</a></li>
<li><a class="reference internal" href="#between-proof-and-unit-testing">Between Proof and Unit Testing</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#prove-correct-integration-between-components">8.1.3. Prove Correct Integration Between Components</a><ul>
<li><a class="reference internal" href="#in-new-developments">8.1.3.1. In New Developments</a></li>
<li><a class="reference internal" href="#in-replacement-of-comments">8.1.3.2. In Replacement of Comments</a></li>
<li><a class="reference internal" href="#in-replacement-of-defensive-coding">8.1.3.3. In Replacement of Defensive Coding</a></li>
</ul>
</li>
<li><a class="reference internal" href="#prove-functional-correctness">8.1.4. Prove Functional Correctness</a><ul>
<li><a class="reference internal" href="#id7">8.1.4.1. In New Developments</a></li>
<li><a class="reference internal" href="#in-replacement-of-unit-testing">8.1.4.2. In Replacement of Unit Testing</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ensure-correct-behavior-of-parameterized-software">8.1.5. Ensure Correct Behavior of Parameterized Software</a></li>
<li><a class="reference internal" href="#safe-optimization-of-run-time-checks">8.1.6. Safe Optimization of Run-Time Checks</a></li>
<li><a class="reference internal" href="#address-data-and-control-coupling">8.1.7. Address Data and Control Coupling</a></li>
<li><a class="reference internal" href="#ensure-portability-of-programs">8.1.8. Ensure Portability of Programs</a><ul>
<li><a class="reference internal" href="#portability-of-ada-programs">8.1.8.1. Portability of Ada Programs</a><ul>
<li><a class="reference internal" href="#portability-of-programs-without-errors">Portability of Programs Without Errors</a></li>
<li><a class="reference internal" href="#portability-of-programs-with-errors">Portability of Programs With Errors</a></li>
</ul>
</li>
<li><a class="reference internal" href="#benefits-of-using-spark-for-portability">8.1.8.2. Benefits of Using SPARK for Portability</a></li>
<li><a class="reference internal" href="#how-to-use-spark-for-portability">8.1.8.3. How to Use SPARK for Portability</a><ul>
<li><a class="reference internal" href="#avoiding-non-portable-features">Avoiding Non-Portable Features</a></li>
<li><a class="reference internal" href="#avoiding-errors-to-enhance-portability">Avoiding Errors to Enhance Portability</a></li>
<li><a class="reference internal" href="#portability-of-fixed-point-and-floating-point-computations">Portability of Fixed-Point and Floating-Point Computations</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#project-scenarios">8.2. Project Scenarios</a><ul>
<li><a class="reference internal" href="#maintenance-and-evolution-of-existing-ada-software">8.2.1. Maintenance and Evolution of Existing Ada Software</a><ul>
<li><a class="reference internal" href="#identifying-violations-of-spark-restrictions">8.2.1.1. Identifying Violations of SPARK Restrictions</a></li>
<li><a class="reference internal" href="#rewriting-the-code-in-spark">8.2.1.2. Rewriting the Code in SPARK</a></li>
<li><a class="reference internal" href="#using-spark-mode-to-select-or-exclude-code">8.2.1.3. Using <code class="docutils literal"><span class="pre">SPARK_Mode</span></code> to Select or Exclude Code</a></li>
</ul>
</li>
<li><a class="reference internal" href="#new-developments-in-spark">8.2.2. New Developments in SPARK</a></li>
<li><a class="reference internal" href="#conversion-of-existing-spark-software-to-spark-2014">8.2.3. Conversion of Existing SPARK Software to SPARK 2014</a></li>
<li><a class="reference internal" href="#analysis-of-frozen-ada-software">8.2.4. Analysis of Frozen Ada Software</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="source/examples_in_the_toolset_distribution.html"
                        title="previous chapter">7.10. Examples in the Toolset Distribution</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="appendix/command_line_invocation.html"
                        title="next chapter">Command Line Invocation</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/en/usage_scenarios.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="applying-spark-in-practice">
<span id="id1"></span><h1>8. Applying SPARK in Practice<a class="headerlink" href="#applying-spark-in-practice" title="Permalink to this headline">Â¶</a></h1>
<p>SPARK tools offer different levels of analysis, which are relevant in
different contexts. This section starts with a description of the main
<a class="reference internal" href="#objectives-of-using-spark"><span class="std std-ref">Objectives of Using SPARK</span></a>. This list gathers the most commonly found
reasons for adopting SPARK in industrial projects, but it is not intended to
be an exhaustive list.</p>
<p>Whatever the objective(s) of using SPARK, any project fits in one of four
possible <a class="reference internal" href="#project-scenarios"><span class="std std-ref">Project Scenarios</span></a>:</p>
<ul class="simple">
<li>the <cite>brown field</cite> scenario: <a class="reference internal" href="#maintenance-and-evolution-of-existing-ada-software"><span class="std std-ref">Maintenance and Evolution of Existing Ada Software</span></a></li>
<li>the <cite>green field</cite> scenario: <a class="reference internal" href="#new-developments-in-spark"><span class="std std-ref">New Developments in SPARK</span></a></li>
<li>the <cite>migration</cite> scenario: <a class="reference internal" href="#conversion-of-existing-spark-software-to-spark-2014"><span class="std std-ref">Conversion of Existing SPARK Software to SPARK 2014</span></a></li>
<li>the <cite>frozen</cite> scenario: <a class="reference internal" href="#analysis-of-frozen-ada-software"><span class="std std-ref">Analysis of Frozen Ada Software</span></a></li>
</ul>
<p>The end of this section examines each of these scenarios in turn and describes
how SPARK can be applied in each case.</p>
<div class="section" id="objectives-of-using-spark">
<span id="id2"></span><h2>8.1. Objectives of Using SPARK<a class="headerlink" href="#objectives-of-using-spark" title="Permalink to this headline">Â¶</a></h2>
<div class="section" id="safe-coding-standard-for-critical-software">
<span id="id3"></span><h3>8.1.1. Safe Coding Standard for Critical Software<a class="headerlink" href="#safe-coding-standard-for-critical-software" title="Permalink to this headline">Â¶</a></h3>
<p>SPARK is a subset of Ada meant for formal verification, by excluding features
that are difficult or impossible to analyze automatically. This means that
SPARK can also be used as a coding standard to restrict the set of features
used in critical software. As a safe coding standard checker, SPARK allows
both to prevent the introduction of errors by excluding unsafe Ada features,
and it facilitates their early detection with GNATprove&#8216;s flow analysis.</p>
<div class="section" id="exclusion-of-unsafe-ada-features">
<h4>8.1.1.1. Exclusion of Unsafe Ada Features<a class="headerlink" href="#exclusion-of-unsafe-ada-features" title="Permalink to this headline">Â¶</a></h4>
<p>Once the simple task of <a class="reference internal" href="spark_mode.html#identifying-spark-code"><span class="std std-ref">Identifying SPARK Code</span></a> has been completed, one
can use GNATprove in <code class="docutils literal"><span class="pre">check</span></code> mode to verify that SPARK restrictions are
respected in SPARK code. Here we list some of the most error-prone Ada
features that are excluded from SPARK (see <a class="reference internal" href="source/language_restrictions.html#excluded-ada-features"><span class="std std-ref">Excluded Ada Features</span></a> for
the complete list).</p>
<ul class="simple">
<li>All expressions, including function calls, are free of
side-effects. Expressions with side-effects are problematic because they hide
interactions that occur in the code, in the sense that a computation will not
only produce a value but also modify some hidden state in the program. In the
worst case, they may even introduce interferences between subexpressions of a
common expression, which results in different executions depending on the
order of evaluation of subexpressions chosen by the compiler.</li>
<li>Handling of exceptions is not permitted. Exception handling can create
complex and invisible control flows in a program, which increases the
likelihood of introducing errors during maintenance. What is more, when an
exception is raised, subprograms that are terminated abnormally leave their
variables in a possibly uninitialized or inconsistent state, in which data
invariants may be broken. This includes values of out parameters, which
additionally are not copied back when passed by copy, thus introducing a
dependency on the parameter mode chosen by the compiler.</li>
<li>The use of access types and allocators is not permitted. Pointers can
introduce aliasing, that is, they can allow the same object to be visible
through different names at the same program point. This makes it difficult to
reason about a program as modifying the object under one of the names will
also modify the other names.  What is more, access types come with their own
load of common mistakes, like double frees and dangling pointers.</li>
<li>SPARK also prevents dependencies on the elaboration order by ensuring that
no package can write into variables declared in other packages during its
elaboration. The use of controlled types is also forbidden as they lead to
insertions of implicit calls by the compiler. Finally, goto statements are
not permitted as they obfuscate the control flow.</li>
</ul>
</div>
<div class="section" id="early-detection-of-errors">
<h4>8.1.1.2. Early Detection of Errors<a class="headerlink" href="#early-detection-of-errors" title="Permalink to this headline">Â¶</a></h4>
<p>GNATprove&#8216;s flow analysis will find all the occurrences of the following
errors:</p>
<ul class="simple">
<li>uses of uninitialized variables (see <a class="reference internal" href="source/language_restrictions.html#data-initialization-policy"><span class="std std-ref">Data Initialization Policy</span></a>)</li>
<li>aliasing of parameters that can cause interferences, which are often not
accounted for by programmers (see <a class="reference internal" href="source/language_restrictions.html#absence-of-interferences"><span class="std std-ref">Absence of Interferences</span></a>)</li>
</ul>
<p>It will also warn systematically about the following suspicious behaviors:</p>
<ul class="simple">
<li>wrong parameter modes (can hurt readability and maintainability or even be
the sign of a bug, for example if the programmer forgot to update a
parameter, to read the value of an out parameter, or to use the initial value
of a parameter)</li>
<li>unused variables or statements (again, can hurt readability and
maintainability or even be the sign of a bug)</li>
</ul>
</div>
</div>
<div class="section" id="prove-absence-of-run-time-errors-aorte">
<span id="id4"></span><h3>8.1.2. Prove Absence of Run-Time Errors (AoRTE)<a class="headerlink" href="#prove-absence-of-run-time-errors-aorte" title="Permalink to this headline">Â¶</a></h3>
<div class="section" id="with-proof-only">
<h4>8.1.2.1. With Proof Only<a class="headerlink" href="#with-proof-only" title="Permalink to this headline">Â¶</a></h4>
<p>GNATprove can be used to prove the complete absence of possible run-time
errors corresponding to:</p>
<ul class="simple">
<li>all possible explicit raising of exceptions in the program,</li>
<li>raising exception <code class="docutils literal"><span class="pre">Constraint_Error</span></code> at run time, and</li>
<li>all possible failures of assertions corresponding to raising exception
<code class="docutils literal"><span class="pre">Assert_Error</span></code> at run time.</li>
</ul>
<p>AoRTE is important for ensuring safety in all possible operational conditions
for safety-critical software (including boundary conditions, or abnormal
conditions) or for ensuring availability of a service (absence of DOS attack
that can crash the software).</p>
<p>When run-time checks are enabled during execution, Ada programs are not
vulnerable to the kind of attacks like buffer overflows that plague programs in
C and C++, which allow attackers to gain control over the system. But in the
case where run-time checks are disabled (in general for efficiency, but it
could be for other reasons), proving their absence with GNATprove also
prevents such attacks. This is specially important for ensuring security when
some inputs may have been crafted by an attacker.</p>
<p>Few subprogram contracts (<a class="reference internal" href="source/subprogram_contracts.html#preconditions"><span class="std std-ref">Preconditions</span></a> and <a class="reference internal" href="source/subprogram_contracts.html#postconditions"><span class="std std-ref">Postconditions</span></a>) are
needed in general to prove AoRTE, far fewer than for proving functional
properties. Even fewer subprogram contracts are needed if types are suitably
constrained with <a class="reference internal" href="source/type_contracts.html#type-contracts"><span class="std std-ref">Type Contracts</span></a>. Typically, 95% to 98% of run-time
checks can be proved automatically, and the remaining checks can be either
verified with manual provers or justified by manual analysis.</p>
<p>GNATprove supports this type of combination of results in the summary table
of <a class="reference internal" href="source/how_to_view_gnatprove_output.html#the-analysis-results-summary-file"><span class="std std-ref">The Analysis Results Summary File</span></a>. Multiple columns display the
number of checks automatically verified, while the column <cite>Justified</cite> displays
the number of checks manually justified. The column <cite>Unproved</cite> should be empty
for all checks to be verified.</p>
</div>
<div class="section" id="with-a-combination-of-proof-and-test">
<h4>8.1.2.2. With a Combination of Proof and Test<a class="headerlink" href="#with-a-combination-of-proof-and-test" title="Permalink to this headline">Â¶</a></h4>
<p>It is not always possible to achieve 100% proof of AoRTE, for multiple reasons:</p>
<ol class="arabic simple">
<li>Formal verification is only applicable to the part of the program that is in
SPARK. If the program includes parts in Ada that are not in SPARK, for
example, then it is not possible to prove AoRTE on those parts.</li>
<li>Some run-time checks may not be proved automatically due to prover
shortcomings (see <a class="reference internal" href="source/how_to_investigate_unproved_checks.html#investigating-prover-shortcomings"><span class="std std-ref">Investigating Prover Shortcomings</span></a> for details).</li>
<li>It may not be cost-effective to add the required contracts for proving AoRTE
in a less critical part of the code, compared to using testing as a means of
verification.</li>
</ol>
<p>For all these reasons, it is important to be able to combine the results of
formal verification and testing on different parts of a codebase. Formal
verification works by making some assumptions, and these assumptions should be
shown to hold even when formal verification and testing are
combined. Certainly, formal verification cannot guarantee the same properties
when part of a program is only tested, as when all of a program is proved. The
goal then, when combining formal verification and testing, is to reach a level
of confidence as good as the level reached by testing alone.</p>
<div class="section" id="at-the-level-of-individual-run-time-checks">
<h5>At the Level of Individual Run-Time Checks<a class="headerlink" href="#at-the-level-of-individual-run-time-checks" title="Permalink to this headline">Â¶</a></h5>
<p>One way to get confidence that unproved run-time checks cannot fail during
execution is to exercise them during testing. Test coverage information allows
guaranteeing a set of run-time checks have been executed successfully during a
test run. This coverage information may be gathered from the execution of a
unit testing campaign, an integration testing campaign, or the execution of a
dedicated testsuite focussing on exercising the run-time checks (for example on
boundary values or random ones).</p>
<p>This strategy is already applied in other static analysis tools, for example
in the integration between the CodePeer static analyzer and the VectorCAST
testing tool for Ada programs.</p>
</div>
<div class="section" id="between-proof-and-integration-testing">
<h5>Between Proof and Integration Testing<a class="headerlink" href="#between-proof-and-integration-testing" title="Permalink to this headline">Â¶</a></h5>
<p>Contracts can also be exercised dynamically during integration testing. In
cases where unit testing is not required (either because proof has been applied
to all subprograms, or because the verification context allows it), exercising
contracts during integration testing can complement proof results, by giving
the assurance that the actual compiled program behaves as expected.</p>
<p>This strategy has been applied at Altran on UK military projects submitted to
Def Stan 00-56 certification: AoRTE was proved on all the code, and contracts
were exercised during integration testing, which allowed to scrap unit testing.</p>
</div>
<div class="section" id="between-proof-and-unit-testing">
<h5>Between Proof and Unit Testing<a class="headerlink" href="#between-proof-and-unit-testing" title="Permalink to this headline">Â¶</a></h5>
<p>Contracts on subprograms provide a natural boundary for combining proof and
test:</p>
<ul class="simple">
<li>If proof is used to demonstrate that a subprogram is free of run-time errors
and respects its contract, this proof depends on the precondition of the
subprogram being respected at the call site. This verification can be
achieved by proving the caller too, or by checking dynamically the
precondition of the called subprogram during unit testing of the caller.</li>
<li>If proof is used to demonstrate that a subprogram is free of run-time errors
and respects its contract, and this subprogram calls other subprograms, this
proof depends on the postconditions of the called subprogram being respected
at call sites. This verification can be achieved by proving the callees too,
or by checking dynamically the postcondition of the called subprograms during
their unit testing.</li>
</ul>
<p>Thus, it is possible to combine freely subprograms that are proved and
subprograms that are unit tested, provided subprogram contracts
(<a class="reference internal" href="source/subprogram_contracts.html#preconditions"><span class="std std-ref">Preconditions</span></a> and <a class="reference internal" href="source/subprogram_contracts.html#postconditions"><span class="std std-ref">Postconditions</span></a>) are exercised during unit
testing. This can be achieved by compiling the program with assertions for
testing (for example with switch <code class="docutils literal"><span class="pre">-gnata</span></code> in GNAT), or by using
GNATtest to create the test harness (see section 7.10.12 of GNAT User&#8217;s
Guide on <cite>Testing with Contracts</cite>).</p>
<p>When combining proof and test on individual subprograms, one should make sure
that the assumptions made for proof are justified at the boundary between
proved subprograms and tested subprograms (see section on <a class="reference internal" href="source/how_to_use_gnatprove_in_a_team.html#managing-assumptions"><span class="std std-ref">Managing Assumptions</span></a>). To help with this verification, special switches are defined in
GNAT to add run-time checks that verify dynamically the assumptions made
during proof:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">-gnateA</span></code> adds checks that parameters are not aliased</li>
<li><code class="docutils literal"><span class="pre">-gnateV</span></code> adds checks that parameters are valid, including parameters of
composite types (arrays, records)</li>
<li><code class="docutils literal"><span class="pre">-gnatVa</span></code> adds checks that objects are valid at more places than -gnateV,
but only for scalar objects</li>
</ul>
<p>This strategy is particularly well suited in the context of the DO-178C
certification standard in avionics, which explicitly allows proof or test to be
used as verification means on each module.</p>
</div>
</div>
</div>
<div class="section" id="prove-correct-integration-between-components">
<span id="id5"></span><h3>8.1.3. Prove Correct Integration Between Components<a class="headerlink" href="#prove-correct-integration-between-components" title="Permalink to this headline">Â¶</a></h3>
<div class="section" id="in-new-developments">
<h4>8.1.3.1. In New Developments<a class="headerlink" href="#in-new-developments" title="Permalink to this headline">Â¶</a></h4>
<p>GNATprove can be used to prove correct integration between components, where
a component could be a subprogram, a unit or a set of units. Indeed, even if
components are verified individually (for example by proof or test or a
combination thereof), their combination may still fail because of unforeseen
interactions or design problems.</p>
<p>SPARK is ideally equipped to support such analysis, with its detailed
<a class="reference internal" href="source/subprogram_contracts.html#subprogram-contracts"><span class="std std-ref">Subprogram Contracts</span></a>:</p>
<ul class="simple">
<li>With <a class="reference internal" href="source/subprogram_contracts.html#data-dependencies"><span class="std std-ref">Data Dependencies</span></a>, a user can specify exactly the input and
output data of a subprogram, which goes a long way towards uncovering
unforeseen interactions.</li>
<li>With functional contracts (<a class="reference internal" href="source/subprogram_contracts.html#preconditions"><span class="std std-ref">Preconditions</span></a> and <a class="reference internal" href="source/subprogram_contracts.html#postconditions"><span class="std std-ref">Postconditions</span></a>), a
user can specify precisely properties about the behavior of the subprogram
that are relevant for component integration. In general, simple contracts are
needed for component integration, which means that they are easy to write and
to verify automatically. See section on <a class="reference internal" href="source/how_to_write_subprogram_contracts.html#writing-contracts-for-program-integrity"><span class="std std-ref">Writing Contracts for Program Integrity</span></a> for examples of such contracts.</li>
</ul>
<p>When using data dependencies, GNATprove&#8216;s flow analysis is sufficient to
check correct integration between components. When using functional contracts,
GNATprove&#8216;s proof should also be applied.</p>
</div>
<div class="section" id="in-replacement-of-comments">
<h4>8.1.3.2. In Replacement of Comments<a class="headerlink" href="#in-replacement-of-comments" title="Permalink to this headline">Â¶</a></h4>
<p>It is good practice to specify properties of a subprogram that are important
for integration in the comments that are attached to the subprogram
declaration.</p>
<p>Comments can be advantageously replaced by contracts:</p>
<ul class="simple">
<li>Comments about the domain of the subprogram can be replaced by
<a class="reference internal" href="source/subprogram_contracts.html#preconditions"><span class="std std-ref">Preconditions</span></a>.</li>
<li>Comments about the effects of the subprogram can be replaced by
<a class="reference internal" href="source/subprogram_contracts.html#postconditions"><span class="std std-ref">Postconditions</span></a> and <a class="reference internal" href="source/subprogram_contracts.html#data-dependencies"><span class="std std-ref">Data Dependencies</span></a>.</li>
<li>Comments about the result of functions can be replaced by
<a class="reference internal" href="source/subprogram_contracts.html#postconditions"><span class="std std-ref">Postconditions</span></a>.</li>
<li>GNATprove can use the contracts to prove correct integration between
components, as in new developments.</li>
</ul>
<p>Contracts are less ambiguous than comments, and can be accompanied by (or
interspersed with) higher level comments that need not be focused on the finer
grain details of which variables must have which values, as these are already
specified concisely and precisely in the contracts.</p>
</div>
<div class="section" id="in-replacement-of-defensive-coding">
<h4>8.1.3.3. In Replacement of Defensive Coding<a class="headerlink" href="#in-replacement-of-defensive-coding" title="Permalink to this headline">Â¶</a></h4>
<p>In existing Ada code that is migrated to SPARK, defensive coding is typically
used to verify the correct integration between components: checks are made at
the start of a subprogram that inputs (parameters and global variables) satisfy
expected properties, and an exception is raised or the program halted if an
unexpected situation is found.</p>
<p>Defensive code can be advantageously replaced by preconditions:</p>
<ul class="simple">
<li>The dynamic checks performed by defensive code at run time can be performed
equally by preconditions, and they can be enabled at a much finer grain
thanks to <a class="reference internal" href="source/assertion_pragmas.html#pragma-assertion-policy"><span class="std std-ref">Pragma Assertion_Policy</span></a>.</li>
<li>GNATprove can use the preconditions to prove correct integration between
components, as in new developments.</li>
</ul>
</div>
</div>
<div class="section" id="prove-functional-correctness">
<span id="id6"></span><h3>8.1.4. Prove Functional Correctness<a class="headerlink" href="#prove-functional-correctness" title="Permalink to this headline">Â¶</a></h3>
<div class="section" id="id7">
<h4>8.1.4.1. In New Developments<a class="headerlink" href="#id7" title="Permalink to this headline">Â¶</a></h4>
<p>GNATprove can be used to prove functional correctness of an implementation
against its specification. This strongest level of verification can be applied
either to specific subprograms, or specific units, or the complete program. For
those subprograms whose functional correctness is to be checked, the user
should:</p>
<ol class="arabic simple">
<li>express the specification of the subprogram as a subprogram contract
(see <a class="reference internal" href="source/subprogram_contracts.html#preconditions"><span class="std std-ref">Preconditions</span></a> and <a class="reference internal" href="source/subprogram_contracts.html#postconditions"><span class="std std-ref">Postconditions</span></a>);</li>
<li>use GNATprove to prove automatically that most checks (including
contracts) always hold; and</li>
<li>address the remaining unproved checks with manual justifications or testing,
as already discussed in the section on how to <a class="reference internal" href="#prove-absence-of-run-time-errors-aorte"><span class="std std-ref">Prove Absence of Run-Time Errors (AoRTE)</span></a>.</li>
</ol>
<p>As more complex contracts are required in general, it is expected that
achieving that strongest level of verification is also more costly than proving
absence of run-time errors. Typically, SPARK features like <a class="reference internal" href="source/specification_features.html#quantified-expressions"><span class="std std-ref">Quantified Expressions</span></a> and <a class="reference internal" href="source/specification_features.html#expression-functions"><span class="std std-ref">Expression Functions</span></a> are needed to express the
specification, and features like <a class="reference internal" href="source/assertion_pragmas.html#loop-invariants"><span class="std std-ref">Loop Invariants</span></a> are needed to achieve
automatic proof. See section on <a class="reference internal" href="source/how_to_write_subprogram_contracts.html#writing-contracts-for-functional-correctness"><span class="std std-ref">Writing Contracts for Functional Correctness</span></a> for examples of such contracts, and section on <a class="reference internal" href="source/how_to_write_loop_invariants.html#how-to-write-loop-invariants"><span class="std std-ref">How to Write Loop Invariants</span></a> for examples of the required loop invariants.</p>
<p>When the functional specification is expressed as a set of disjoint cases, the
SPARK feature of <a class="reference internal" href="source/subprogram_contracts.html#contract-cases"><span class="std std-ref">Contract Cases</span></a> can be used to increase readability
and to provide an automatic means to verify that cases indeed define a
partitioning of the possible operational contexts.</p>
</div>
<div class="section" id="in-replacement-of-unit-testing">
<h4>8.1.4.2. In Replacement of Unit Testing<a class="headerlink" href="#in-replacement-of-unit-testing" title="Permalink to this headline">Â¶</a></h4>
<p>In existing Ada code that is migrated to SPARK, unit testing is typically
used to verify functional correctness: actual outputs obtained when calling the
subprogram are compared to expected outputs for given inputs. A <cite>test case</cite>
defines an expected behavior to verify; a <cite>test procedure</cite> implements a <cite>test
case</cite> with specific given inputs and expected outputs.</p>
<p>Test cases can be used as a basis for functional contracts, as they define in
general a behavior for a set of similar inputs. Thus, a set of test cases can
be transformed into <a class="reference internal" href="source/subprogram_contracts.html#contract-cases"><span class="std std-ref">Contract Cases</span></a>, where each case corresponds to a
test case: the test input constraint becomes the guard of the corresponding
case, while the test output constraint becomes the consequence of the
corresponding case.</p>
<p>GNATprove can be used to prove this initial functional contract, as in new
developments. Then, cases can be progressively generalized (by relaxing the
conditions in the guards), or new cases added to the contract, until the full
functional behavior of the subprogram is specified and proved.</p>
</div>
</div>
<div class="section" id="ensure-correct-behavior-of-parameterized-software">
<span id="id8"></span><h3>8.1.5. Ensure Correct Behavior of Parameterized Software<a class="headerlink" href="#ensure-correct-behavior-of-parameterized-software" title="Permalink to this headline">Â¶</a></h3>
<p>In some domains (railway, space), it is common to develop software which
depends on parameterization data, which changes from mission to mission. For
example, the layout of railroads or the characteristics of the payload for a
spacecraft are mission specific, but in general do not require developing
completely new software for the mission. Instead, the software may either
depend on data definition units which are subject to changes between missions,
or the software may load at starting time (possibly during <cite>elaboration</cite> in
Ada) the data which defines the characteristics of the mission. Then, the issue
is that a verification performed on a specific version of the software (for a
given parameterization) is not necessarily valid for all versions of the
software. In general, this means that verification has to be performed again
for each new version of the software, which can be costly.</p>
<p>SPARK provides a better solution to ensure correct behavior of the software
for all possible parameterizations. It requires defining a getter function for
every variable or constant in the program that represents an element of
parameterization, and calling this getter function instead of reading the
variable or constant directly. Because GNATprove performs an analysis based
on contracts, all that is known at analysis time about the value returned by a
getter function is what is available from its signature and
contract. Typically, one may want to use <a class="reference internal" href="source/type_contracts.html#scalar-ranges"><span class="std std-ref">Scalar Ranges</span></a> or
<a class="reference internal" href="source/type_contracts.html#predicates"><span class="std std-ref">Predicates</span></a> to constrain the return subtype of such getter functions, to
reflect the operational constraints respected by all parameterizations.</p>
<p>This technique ensures that the results of applying GNATprove are valid not
only for the version of the software analyzed, but for any other version that
satisfies the same operational constraints. This is valid whatever the
objective(s) pursued with the use of SPARK: <a class="reference internal" href="#prove-absence-of-run-time-errors-aorte"><span class="std std-ref">Prove Absence of Run-Time Errors (AoRTE)</span></a>, <a class="reference internal" href="#prove-correct-integration-between-components"><span class="std std-ref">Prove Correct Integration Between Components</span></a>,
<a class="reference internal" href="#prove-functional-correctness"><span class="std std-ref">Prove Functional Correctness</span></a>, etc.</p>
<p>It may be the case that changing constants into functions makes the code
illegal because the constants were used in representation clauses that require
static values. In that case, compilation switch <code class="docutils literal"><span class="pre">-gnatI</span></code> should be specified
when analyzing the modified code with GNATprove, so that representation
clauses are ignored. As representation clauses have no effect on GNATprove&#8216;s
analysis, and their validity is checked by GNAT when compiling the
original code, the formal verification results are valid for the original code.</p>
<p>For constants of a non-scalar type (for example, constants of record or array
type), an alternative way to obtain a similar result as the getter function is
to define the constant as a deferred constant, whose initial declaration in the
visible part of a package spec does not specify the value of the
constant. Then, the private part of the package spec which defines the
completion of the deferred constant must be marked <code class="docutils literal"><span class="pre">SPARK_Mode</span> <span class="pre">=&gt;</span> <span class="pre">Off</span></code>, so
that clients of the package only see the visible constant declaration without
value. In such a case, the analysis of client units with GNATprove is valid
for all possible values of the constant.</p>
</div>
<div class="section" id="safe-optimization-of-run-time-checks">
<span id="id9"></span><h3>8.1.6. Safe Optimization of Run-Time Checks<a class="headerlink" href="#safe-optimization-of-run-time-checks" title="Permalink to this headline">Â¶</a></h3>
<p>Enabling run-time checks in a program usually increases the running time by
around 10%. This may not fit the timing schedule in some highly constrained
applications. In some cases where a piece of code is called a large number of
times (for example in a loop), enabling run-time checks on that piece of code
may increase the running time by far more than 10%. Thus, it may be tempting to
remove run-time checking in the complete program (with compilation switch
<code class="docutils literal"><span class="pre">-gnatp</span></code>) or a selected piece of code (with pragma <code class="docutils literal"><span class="pre">Suppress</span></code>), for the
purpose of decreasing running time. The problem with that approach is that the
program is not protected anymore against programming mistakes (for safety) or
attackers (for security).</p>
<p>GNATprove provides a better solution, by allowing users to prove the absence
of all run-time errors (or run-time errors of a specific kind, for example
overflow checks) in a piece of code, provided the precondition of the enclosing
subprogram is respected. Then, all run-time checks (or run-time errors of a
specific kind) can be suppressed in that piece of code using pragma
<code class="docutils literal"><span class="pre">Suppress</span></code>, knowing that they will never fail at run time, provided the
precondition of the enclosing subprogram is checked (for example by using
<a class="reference internal" href="source/assertion_pragmas.html#pragma-assertion-policy"><span class="std std-ref">Pragma Assertion_Policy</span></a>). By replacing many checks with one check, we
can decrease the running time of the application by doing safe and controlled
optimization of run-time checks.</p>
</div>
<div class="section" id="address-data-and-control-coupling">
<span id="id10"></span><h3>8.1.7. Address Data and Control Coupling<a class="headerlink" href="#address-data-and-control-coupling" title="Permalink to this headline">Â¶</a></h3>
<p>As defined in the avionics standard DO-178, data coupling is <cite>&#8220;The dependence
of a software component on data not exclusively under the control of that
software component&#8221;</cite> and control coupling is <cite>&#8220;The manner or degree by which
one software component influences the execution of another software
component&#8221;</cite>, where a software component could be a subprogram, a unit or a set
of units.</p>
<p>Although analysis of data and control coupling are not performed at the same
level of details in non-critical domains, knowledge of data and control
coupling is important to assess impact of code changes. In particular, it may
be critical for security that some secret data does not leak publicly, which
can be rephrased as saying that only the specified data dependencies are
allowed. SPARK is ideally equiped to support such analysis, with its detailed
<a class="reference internal" href="source/subprogram_contracts.html#subprogram-contracts"><span class="std std-ref">Subprogram Contracts</span></a>:</p>
<ul class="simple">
<li>With <a class="reference internal" href="source/subprogram_contracts.html#data-dependencies"><span class="std std-ref">Data Dependencies</span></a>, a user can specify exactly the input and
output data of a subprogram, which identifies the <cite>&#8220;data not exclusively
under the control of that software component&#8221;</cite>:<ul>
<li>When taking the subprogram as component, any variable in the data
dependencies is in general not exclusively under the control of that
software component.</li>
<li>When taking the unit (or sets of units) as component, any variable in the
data dependencies that is not defined in the unit itself (or the set of
units) is in general not exclusively under the control of that software
component.</li>
</ul>
</li>
<li>With <a class="reference internal" href="source/subprogram_contracts.html#flow-dependencies"><span class="std std-ref">Flow Dependencies</span></a>, a user can specify the nature of the
<cite>&#8220;dependence of a software component on data not exclusively under the
control of that software component&#8221;</cite>, by identifying how that data may
influence specific outputs of a subprogram.</li>
<li>With <a class="reference internal" href="source/subprogram_contracts.html#flow-dependencies"><span class="std std-ref">Flow Dependencies</span></a>, a user can also specify how <cite>&#8220;one software
component influences the execution of another software component&#8221;</cite>, by
identifying the shared data potentially written by the subprogram.</li>
<li>With functional contracts (<a class="reference internal" href="source/subprogram_contracts.html#preconditions"><span class="std std-ref">Preconditions</span></a> and <a class="reference internal" href="source/subprogram_contracts.html#postconditions"><span class="std std-ref">Postconditions</span></a>), a
user can specify very precisely the behavior of the subprogram, which defines
how it <cite>&#8220;influences the execution of another software component&#8221;</cite>. These
contracts need not be complete, for example they could describe the
precedence order rules for calling various subprograms.</li>
</ul>
<p>When using data and flow dependencies, GNATprove&#8216;s flow analysis is
sufficient to check that the program implements its specifications. When using
functional contracts, GNATprove&#8216;s proof should also be applied.</p>
</div>
<div class="section" id="ensure-portability-of-programs">
<span id="id11"></span><h3>8.1.8. Ensure Portability of Programs<a class="headerlink" href="#ensure-portability-of-programs" title="Permalink to this headline">Â¶</a></h3>
<p>Using SPARK enhances portability of programs by excluding language features
that are known to cause portability problems, and by making it possible to
obtain guarantees that specific portability problems cannot occur. In
particular, analyses of SPARK code can prove the absence of run-time errors
in the program, and that specified functional properties always hold.</p>
<p>Still, porting a SPARK program written for a given compiler and target to
another compiler and/or target may require changes in the program. As SPARK
is a subset of Ada, and because in general only some parts of a complete
program are in SPARK, we need to consider first the issue of portability in
the context of Ada, and then specialize it in the context of SPARK.</p>
<p>Note that we consider here portability in its strictest sense, whereby a
program is portable if its observable behavior is exactly the same across a
change of compiler and/or target. In the more common sense of the word, a
program is portable if it can be reused without modification on a different
target, or when changing compiler.  That is consistent with the definition of
portability in WikiPedia: &#8220;Portability in high-level computer programming is
the usability of the same software in different environments&#8221;. As an example of
a difference between both interpretations, many algorithms which use
trigonometry are portable in the more common sense, not in the strictest sense.</p>
<div class="section" id="portability-of-ada-programs">
<h4>8.1.8.1. Portability of Ada Programs<a class="headerlink" href="#portability-of-ada-programs" title="Permalink to this headline">Â¶</a></h4>
<p>Programs with errors cause additional portability issues not seen in programs
without errors, which is why we consider them separately.</p>
<div class="section" id="portability-of-programs-without-errors">
<h5>Portability of Programs Without Errors<a class="headerlink" href="#portability-of-programs-without-errors" title="Permalink to this headline">Â¶</a></h5>
<p>The Ada Reference Manual defines precisely which features of the language
depend on choices made by the compiler (see Ada RM 1.1.3 &#8220;Conformity of an
Implementation with the Standard&#8221;):</p>
<ul class="simple">
<li><em>Implementation defined behavior</em> - The set of possible behaviors is
specified in the language, and the particular behavior chosen in a compiler
should be documented. An example of implementation defined behavior is the
size of predefined integer types (like <code class="docutils literal"><span class="pre">Integer</span></code>). All implementation
defined behaviors are listed in Ada RM M.2, and GNAT documents its
implementation for each of these points in section 7 &#8220;Implementation Defined
Characteristics&#8221; of the GNAT Reference Manual.</li>
<li><em>Unspecified behavior</em> - The set of possible behaviors is specified in the
language, but the particular behavior chosen in a compiler need not be
documented. An example of unspecified behavior is the order of evaluation of
arguments in a subprogram call.</li>
</ul>
<p>Changes of compiler and/or target may lead to different implementation defined
and unspecified behavior, which may or not have a visible effect. For example,
changing the order of evaluation of arguments in a subprogram call only has a
visible effect if the evaluation of arguments itself has some side-effects.</p>
<p>Section 18.4 &#8220;Implementation-dependent characteristics&#8221; of the GNAT Reference
Manual gives some advice on how to address implementation defined behavior for
portability.</p>
<p>A particular issue is that the Ada Reference Manual gives much implementation
freedom to the compiler in the implementation of operations of fixed-point and
floating-point types:</p>
<ul class="simple">
<li>The small of a fixed-point type is implementation defined (Ada RM 3.5.9(8/2))
unless specified explicitly.</li>
<li>The base type of a fixed-point type is implementation defined (Ada RM
3.5.9(12-16)), which has an impact on possible overflows.</li>
<li>The rounded result of an ordinary fixed-point multiplication or division is
implementation defined (Ada RM G.2.3(10)).</li>
<li>For some combinations of types of operands and results for fixed-point
multiplication and division, the value of the result belongs to an
implementation defined set of values (Ada RM G.2.3(5)).</li>
<li>The semantics of operations on floating-point types is implementation defined
(Ada RM G.2). It may or may not follow the IEEE 754 floating point standard.</li>
<li>The precision of elementary functions (exponential and trigonometric
functions) is implementation defined (Ada RM G.2.4).</li>
</ul>
<p>Section 18.1 &#8220;Writing Portable Fixed-Point Declarations&#8221; of the GNAT Reference
Manual gives some advice on how to reduce implementation defined behavior for
fixed-point types. Use of IEEE 754 floating-point arithmetic can be enforced in
GNAT by using the compilation switches &#8220;-msse2 -mfpmath=sse&#8221;, as documented in
section 8.3.1.6 &#8220;Floating Point Operations&#8221; of the GNAT User&#8217;s Guide.</p>
<p>Note that a number of restrictions can be used to prevent some features leading
to implementation defined or unspecified behavior:</p>
<ul class="simple">
<li>Restriction <code class="docutils literal"><span class="pre">No_Fixed_Point</span></code> forbids the use of fixed-point types.</li>
<li>Restriction <code class="docutils literal"><span class="pre">No_Floating_Point</span></code> forbids the use of floating-point types.</li>
<li>Restriction <code class="docutils literal"><span class="pre">No_Implementation_Aspect_Specifications</span></code> forbids the use of
implementation defined aspects.</li>
<li>Restriction <code class="docutils literal"><span class="pre">No_Implementation_Attributes</span></code> forbids the use of
implementation defined attributes.</li>
<li>Restriction <code class="docutils literal"><span class="pre">No_Implementation_Pragmas</span></code> forbids the use of implementation
defined pragmas.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">SPARK defines a few constructs (aspects, pragmas and attributes) that are
not defined in Ada. While GNAT supports these constructs, care should
be exercised to use these constructs with other compilers, or older versions
of GNAT. This issue is detailed in section <a class="reference internal" href="appendix/portability_issues.html#portability-issues"><span class="std std-ref">Portability Issues</span></a>.</p>
</div>
</div>
<div class="section" id="portability-of-programs-with-errors">
<span id="id12"></span><h5>Portability of Programs With Errors<a class="headerlink" href="#portability-of-programs-with-errors" title="Permalink to this headline">Â¶</a></h5>
<p>In addition to the portability issues discussed so far, programs with errors
cause specific portability issues related to whether errors are detected and
how they are reported. The Ada Reference Manual distinguishes between four
types of errors (see Ada RM 1.1.5 &#8220;Classification of Errors&#8221;):</p>
<ul class="simple">
<li><em>Compile-time errors</em> - These errors make a program illegal, and should be
detected by any Ada compiler. They do not cause any portability issue, as
they must be fixed before compilation.</li>
<li><em>Run-time errors</em> - These errors are signaled by raising an exception at run
time. They might be a cause of portability problems, as a change of compiler
and/or target may lead to new run-time errors. For example, a new compiler
may cause the program to use more stack space, leading to an exception
<code class="docutils literal"><span class="pre">Storage_Error</span></code>, and a new target may change the size of standard integer
types, leading to an exception <code class="docutils literal"><span class="pre">Constraint_Error</span></code>.</li>
<li><em>Bounded errors</em> - These errors need not be detected either at compiler time
or at run time, but their effects should be bounded. For example, reading an
uninitialized value may result in any value of the type to be used, or to
<code class="docutils literal"><span class="pre">Program_Error</span></code> being raised. Like for run-time errors, they might be a
cause of portability problems, as a change of compiler and/or target may lead
to new bounded errors.</li>
<li><em>Erroneous execution</em> - For the remaining errors, a program exhibits
erroneous execution, which means that the error need not be detected, and
its effects are not bounded by the language rules. These errors might be a
cause of portability problems.</li>
</ul>
<p>Portability issues may arise in a number of cases related to errors:</p>
<ul class="simple">
<li>The original program has an error that is not detected (a run-time error,
bounded error or erroneous execution). Changing the compiler and/or target
causes the error to be detected (an exception is raised) or to trigger a
different behavior. Typically, reads of uninitialized data or illegal
accesses to memory that are not detected in the original program may result
in errors when changing the compiler and/or the target.</li>
<li>The original program has no error, but changing the compiler and/or target
causes an error to appear, which may or not be detected. Typically, uses of
low-level constructs like <code class="docutils literal"><span class="pre">Unchecked_Conversion</span></code> which depend on the exact
representation of values in bits may lead to errors when changing the
compiler and/or the target. Some run-time errors like overflow errors or
storage errors are also particularly sensitive to compiler and target
changes.</li>
</ul>
<p>To avoid portability issues, errors should be avoided by using suitable
analyses and reviews in the context of the original and the new compiler and/or
target. Whenever possible, these analyses and reviews should be automated by
tools to guarantee that all possible errors of a given kind have been reported.</p>
</div>
</div>
<div class="section" id="benefits-of-using-spark-for-portability">
<span id="id13"></span><h4>8.1.8.2. Benefits of Using SPARK for Portability<a class="headerlink" href="#benefits-of-using-spark-for-portability" title="Permalink to this headline">Â¶</a></h4>
<p>The <a class="reference internal" href="source/language_restrictions.html#language-restrictions"><span class="std std-ref">Language Restrictions</span></a> in SPARK favor portability by excluding
problematic language features (see <a class="reference internal" href="source/language_restrictions.html#excluded-ada-features"><span class="std std-ref">Excluded Ada Features</span></a>):</p>
<ul class="simple">
<li>By excluding side-effects in expressions, SPARK programs cannot suffer from
effects occurring in different orders depending on the order of evaluation of
expressions chosen by the compiler.</li>
<li>By excluding aliasing, the behavior of SPARK programs does not depend on
the parameter passing mechanism (by copy or by reference) or the order of
assignment to out and in-out parameters passed by copy after the call, which
are both chosen by the compiler.</li>
<li>By excluding controlled types, SPARK programs cannot suffer from the
presence and ordering of effects taking place as part of the initialization,
assignment and finalization of controlled objects, which depend on choices
made by the compiler.</li>
</ul>
<p>As permitted by the SPARK language rules (see section 1.4.1 &#8220;Further Details
on Formal Verification&#8221; of the SPARK Reference Manual), GNATprove rejects
with an error programs which may implicitly raise a <code class="docutils literal"><span class="pre">Program_Error</span></code> in parts
of code that are in SPARK. For example, all static execution paths in a
SPARK function should end with a return statement, a raise statement, or a
<code class="docutils literal"><span class="pre">pragma</span> <span class="pre">Assert</span> <span class="pre">(False)</span></code>. GNATprove&#8216;s analysis can be further used to ensure
that dynamic executions can only end in a return.</p>
<p>GNATprove reduces portability issues related to the use of fixed-point and
floating-point values:</p>
<ul class="simple">
<li>GNATprove supports a subset of fixed-point types and operations that
ensures that the result of an operation always belongs to the <em>perfect result
set</em> as defined in Ada RM G.2.3. Note that the perfect result set still
contains in general two values (the two model fixed-point values above and
below the perfect mathematical result), which means that two compilers may
give two different results for multiplication and division. Users should thus
avoid multiplication and division of fixed-point values for maximal
portability. See <a class="reference internal" href="appendix/gnatprove_limitations.html#tool-limitations"><span class="std std-ref">Tool Limitations</span></a>.</li>
<li>GNATprove assumes IEEE 754 standard semantics for basic operations of
floating-point types (addition, subtraction, multiplication, division). With
GNAT, this is achieved by using compilation switches
&#8220;-msse2 -mfpmath=sse&#8221;. Users should still avoid elementary functions
(exponential and trigonometric functions) for maximal portability. See
<a class="reference internal" href="appendix/semantics_of_floating_point_operations.html#semantics-of-floating-point-operations"><span class="std std-ref">Semantics of Floating Point Operations</span></a>.</li>
</ul>
<p>Additionally, GNATprove can detect all occurrences of specific portability
issues in SPARK code (that is, parts of the program for which
<code class="docutils literal"><span class="pre">SPARK_Mode=On</span></code> is specified, see section on <a class="reference internal" href="spark_mode.html#identifying-spark-code"><span class="std std-ref">Identifying SPARK Code</span></a>)
when run in specific modes (see <a class="reference internal" href="source/how_to_view_gnatprove_output.html#effect-of-mode-on-output"><span class="std std-ref">Effect of Mode on Output</span></a> for a
description of the different modes):</p>
<ul class="simple">
<li>In all modes (including mode <code class="docutils literal"><span class="pre">check</span></code>), when switch <code class="docutils literal"><span class="pre">--pedantic</span></code> is set,
GNATprove issues a warning for every arithmetic operation which could be
re-ordered by the compiler, thus leading to a possible overflow with one
compiler and not another. For example, arithmetic operation <code class="docutils literal"><span class="pre">A</span> <span class="pre">+</span> <span class="pre">B</span> <span class="pre">+</span> <span class="pre">C</span></code> can
be interpreted as <code class="docutils literal"><span class="pre">(A</span> <span class="pre">+</span> <span class="pre">B)</span> <span class="pre">+</span> <span class="pre">C</span></code> by one compiler, and <code class="docutils literal"><span class="pre">A</span> <span class="pre">+</span> <span class="pre">(B</span> <span class="pre">+</span> <span class="pre">C)</span></code> (after
re-ordering) by another compiler. Note that GNAT always uses the former
version without re-ordering. See <a class="reference internal" href="appendix/portability_issues.html#parenthesized-arithmetic-operations"><span class="std std-ref">Parenthesized Arithmetic Operations</span></a>.</li>
<li>In modes <code class="docutils literal"><span class="pre">flow</span></code>, <code class="docutils literal"><span class="pre">prove</span></code> and <code class="docutils literal"><span class="pre">all</span></code>, GNATprove issues high check
messages on possible parameter aliasing, when such an aliasing may lead to
interferences. This includes all cases where the choice of parameter passing
mechanism in a compiler (by copy or by reference) might influence the
behavior of the subprogram. See <a class="reference internal" href="source/language_restrictions.html#absence-of-interferences"><span class="std std-ref">Absence of Interferences</span></a>.</li>
<li>In modes <code class="docutils literal"><span class="pre">flow</span></code>, <code class="docutils literal"><span class="pre">prove</span></code> and <code class="docutils literal"><span class="pre">all</span></code>, GNATprove issues check messages
on possible reads of uninitialized data. These messages should be reviewed
with respect to the stricter <a class="reference internal" href="source/language_restrictions.html#data-initialization-policy"><span class="std std-ref">Data Initialization Policy</span></a> in SPARK
rather than in Ada. Hence, it is possible when the program does not conform
to the stricter SPARK rules to manually validate them, see section
<a class="reference internal" href="source/how_to_use_gnatprove_in_a_team.html#justifying-check-messages"><span class="std std-ref">Justifying Check Messages</span></a>.</li>
<li>In modes <code class="docutils literal"><span class="pre">prove</span></code> and <code class="docutils literal"><span class="pre">all</span></code>, GNATprove issues check messages on all
possible run-time errors corresponding to raising exception
<code class="docutils literal"><span class="pre">Constraint_Error</span></code> at run time, all possible failures of assertions
corresponding to raising exception <code class="docutils literal"><span class="pre">Assert_Error</span></code> at run time, and all
possible explicit raising of exceptions in the program.</li>
</ul>
<p>The analysis of GNATprove can take into account characteristics of the target
(size and alignment of standard scalar types, endianness) by specifying a
<a class="reference internal" href="source/how_to_run_gnatprove.html#target-parameterization"><span class="std std-ref">Target Parameterization</span></a>.</p>
</div>
<div class="section" id="how-to-use-spark-for-portability">
<h4>8.1.8.3. How to Use SPARK for Portability<a class="headerlink" href="#how-to-use-spark-for-portability" title="Permalink to this headline">Â¶</a></h4>
<p>GNATprove&#8216;s analysis may be used to enhance the portability of programs. Note
that the guarantees provided by this analysis only hold for the source
program. To ensure that these guarantees extend to the executable object code,
one should independently provide assurance that the object code correctly
implements the semantics of the source code.</p>
<div class="section" id="avoiding-non-portable-features">
<h5>Avoiding Non-Portable Features<a class="headerlink" href="#avoiding-non-portable-features" title="Permalink to this headline">Â¶</a></h5>
<p>As much as possible, uses of non-portable language features should be avoided,
or at least isolated in specific parts of the program to facilitate analyses
and reviews when changing the compiler and/or the target.</p>
<p>This includes in particular language features that deal with machine addresses,
data representations, interfacing with assembler code, and similar issues (for
example, language attribute <code class="docutils literal"><span class="pre">Size</span></code>). When changing the compiler and/or the
target, the program logic should be carefully reviewed for possible dependences
on the original compiler behavior and/or original target characteristics. See
also the section 18.4.5 &#8220;Target-specific aspects&#8221; of the GNAT Reference
Manual.</p>
<p>In particular, features that bypass the type system of Ada for reinterpreting
values (<code class="docutils literal"><span class="pre">Unchecked_Conversion</span></code>) and memory locations (<code class="docutils literal"><span class="pre">Address</span></code> clause
overlays, in which multiple objects are defined to share the same address,
something that can also be achieved by sharing the same <code class="docutils literal"><span class="pre">Link_Name</span></code> or
<code class="docutils literal"><span class="pre">External_Name</span></code>) have no impact on SPARK analysis, yet they may lead to
portability issues.</p>
<p>By using the following restrictions (or a subset thereof), one can ensure that
the corresponding non-portable features are not used in the program:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">No_Dependence</span> <span class="o">(</span><span class="n">Ada.Unchecked_Conversion</span><span class="o">)</span><span class="p">;</span>
<span class="kr">pragma</span><span class="p"> </span><span class="n">No_Dependence</span> <span class="o">(</span><span class="n">System.Machine_code</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>Similarly, the program logic should be carefully reviewed for possible
dependency on target characteristics (for example, the size of standard integer
types). GNATprove&#8216;s analysis may help here as it can take into account the
characteristics of the target. Hence, proofs of functional properties with
GNATprove ensure that these properties will always hold on the target.</p>
<p>In the specific case that the target is changing, it might be useful to run
GNATprove&#8216;s analysis on the program in <code class="docutils literal"><span class="pre">proof</span></code> mode, even if it cannot
prove completely the absence of run-time errors and that the specified
functional properties (if any) hold. Indeed, by running GNATprove twice, once
with the original target and once with the new target, comparing the results
obtained in both cases might point to parts of the code that are impacted by
the change of target, which may require more detailed manual reviews.</p>
<p>Apart from non-portable language features and target characteristics,
non-portability in SPARK may come from a small list of causes:</p>
<ul class="simple">
<li>Possible re-ordering of non-parenthesized arithmetic operations. These can be
detected by running GNATprove (see <a class="reference internal" href="#benefits-of-using-spark-for-portability"><span class="std std-ref">Benefits of Using SPARK for Portability</span></a>). Then, either these operations may not be re-ordered by the
compiler (for example, GNAT ensures this property), or re-ordering may not
lead to an intermediate overflow (for example, if the base type is large
enough), or the user may introduce parentheses to prevent re-ordering.</li>
<li>Possible aliasing between parameters (or parameters and global variables) of
a call causing interferences.  These can be detected by running GNATprove
(see <a class="reference internal" href="#benefits-of-using-spark-for-portability"><span class="std std-ref">Benefits of Using SPARK for Portability</span></a>). Then, either aliasing
is not possible in reality, or aliasing may not cause different behaviors
depending on the parameter passing mechanism chosen in the compiler, or the
user may change the code to avoid aliasing. When SPARK subprograms are
called from non-SPARK code (for example Ada or C code), manual reviews
should be performed to ensure that these calls cannot introduce aliasing
between parameters, or between parameters and global variables.</li>
<li>Possible different choices of base type for user-defined integer types
(contrary to derived types or subtypes, which inherit their base type from
their parent type). GNATprove follows GNAT in choosing as base type
the smallest multiple-words-size integer type that contains the type
bounds (see <a class="reference internal" href="appendix/portability_issues.html#base-type-of-user-defined-integer-types"><span class="std std-ref">Base Type of User-Defined Integer Types</span></a> for more
information).</li>
<li>Issues related to errors. See section <a class="reference internal" href="#avoiding-errors-to-enhance-portability"><span class="std std-ref">Avoiding Errors to Enhance Portability</span></a>.</li>
<li>Issues related to the use of fixed-point or floating-point operations. See
section <a class="reference internal" href="#portability-of-fixed-point-and-floating-point-computations"><span class="std std-ref">Portability of Fixed-Point and Floating-Point Computations</span></a>
below.</li>
</ul>
</div>
<div class="section" id="avoiding-errors-to-enhance-portability">
<span id="id14"></span><h5>Avoiding Errors to Enhance Portability<a class="headerlink" href="#avoiding-errors-to-enhance-portability" title="Permalink to this headline">Â¶</a></h5>
<p>Because errors in a program make portability particularly challenging (see
<a class="reference internal" href="#portability-of-programs-with-errors"><span class="std std-ref">Portability of Programs With Errors</span></a>), it is important to ensure that a
program is error-free for portability. GNATprove&#8216;s analysis can help by
ensuring that the SPARK parts of a program are free from broad kinds of
errors:</p>
<ul class="simple">
<li>all possible reads of uninitialized data</li>
<li>all possible explicit raise of exceptions in the program</li>
<li>all possible run-time errors except raising exception <code class="docutils literal"><span class="pre">Storage_Error</span></code>,
corresponding to raising exception <code class="docutils literal"><span class="pre">Program_Error</span></code>, <code class="docutils literal"><span class="pre">Constraint_Error</span></code> or
<code class="docutils literal"><span class="pre">Tasking_Error</span></code> at run time</li>
<li>all possible failures of assertions corresponding to raising exception
<code class="docutils literal"><span class="pre">Assert_Error</span></code> at run time</li>
</ul>
<p>When parts of the program are not in SPARK (for example, in Ada or C), the
results of GNATprove&#8216;s analysis depend on assumptions on the correct behavior
of the non-SPARK code. For example, callers of a SPARK subprogram should
only pass initialized input values, and non-SPARK subprograms called from
SPARK code should respect their postcondition. See section <a class="reference internal" href="source/how_to_use_gnatprove_in_a_team.html#managing-assumptions"><span class="std std-ref">Managing Assumptions</span></a> for the complete list of assumptions.</p>
<p>In particular, when changing the target characteristics, GNATprove&#8216;s analysis
can be used to show that no possible overflow can occur as a result of changing
the size of standard integer types.</p>
<p>GNATprove&#8216;s analysis does not detect possible run-time errors corresponding
to raising exception <code class="docutils literal"><span class="pre">Storage_Error</span></code> at run time, which should be
independently assessed. Because access types and dynamic allocation are
forbidden in SPARK, the only possible cause for raising exception
<code class="docutils literal"><span class="pre">Storage_Error</span></code> in a SPARK program is overflowing the stack.</p>
</div>
<div class="section" id="portability-of-fixed-point-and-floating-point-computations">
<span id="id15"></span><h5>Portability of Fixed-Point and Floating-Point Computations<a class="headerlink" href="#portability-of-fixed-point-and-floating-point-computations" title="Permalink to this headline">Â¶</a></h5>
<p>Portability issues related to the use of fixed-point or floating-point
operations can be avoided altogether by ensuring that the program does not use
fixed-point or floating-point values, using:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Restrictions</span> <span class="o">(</span><span class="n">No_Fixed_Point</span><span class="o">)</span><span class="p">;</span>
<span class="kr">pragma</span><span class="p"> </span><span class="n">Restrictions</span> <span class="o">(</span><span class="n">No_Floating_Point</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>When fixed-point values are used, the value of the small and size in bits for
the type should be specified explicitly, as documented in section 18.1 &#8220;Writing
Portable Fixed-Point Declarations&#8221; of the GNAT Reference Manual:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="n">My_Small</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="o">:=</span> <span class="mi">2</span><span class="o">.</span><span class="mi">0</span><span class="o">**(-</span><span class="mi">15</span><span class="o">)</span><span class="p">;</span>
<span class="n">My_First</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="o">:=</span> <span class="o">-</span><span class="mi">1</span><span class="o">.</span><span class="mi">0</span><span class="p">;</span>
<span class="n">My_Last</span>  <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="o">:=</span> <span class="o">+</span><span class="mi">1</span><span class="o">.</span><span class="mi">0</span> <span class="o">-</span> <span class="n">My_Small</span><span class="p">;</span>

<span class="kr">type</span><span class="p"> </span><span class="n">F2</span> <span class="kr">is</span><span class="p"> </span><span class="kr">delta</span><span class="p"> </span><span class="n">My_Small</span> <span class="kr">range</span><span class="p"> </span><span class="n">My_First</span> <span class="o">..</span> <span class="n">My_Last</span><span class="p">;</span>
<span class="kr">for</span><span class="p"> </span><span class="n">F2</span><span class="na">&#39;Small</span> <span class="kr">use</span><span class="p"> </span><span class="n">my_Small</span><span class="p">;</span>
<span class="kr">for</span><span class="p"> </span><span class="n">F2</span><span class="na">&#39;Size</span>  <span class="kr">use</span><span class="p"> </span><span class="mi">16</span><span class="p">;</span>
</pre></div>
</div>
<p>The program should also avoid multiplication and division of fixed-point values
to ensure that the result of arithmetic operations is exactly defined.</p>
<p>When floating-point values are used, use of IEEE 754 standard semantics for
basic operations of floating-point types (addition, subtraction,
multiplication, division) should be enforced. With GNAT, this is achieved by
using compilation switches &#8220;-msse2 -mfpmath=sse&#8221;.</p>
<p>The program should also avoid elementary functions (exponential and
trigonometric functions), which can be ensured with a restriction:</p>
<div class="highlight-ada"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">No_Dependence</span> <span class="o">(</span><span class="n">Ada.Numerics</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>If elementary functions are used, subject to reviews for ensuring portability,
GNATprove&#8216;s proof results may depend on the fact that elementary functions
can be modeled as mathematical functions of their inputs that always return
the same result when taking the same values in arguments. GNAT compiler was
modified to ensure this property (see <a class="reference external" href="https://blog.adacore.com/how-our-compiler-learnt-from-our-analyzers">https://blog.adacore.com/how-our-compiler-learnt-from-our-analyzers</a>),
which may not hold for other Ada compilers.</p>
</div>
</div>
</div>
</div>
<div class="section" id="project-scenarios">
<span id="id16"></span><h2>8.2. Project Scenarios<a class="headerlink" href="#project-scenarios" title="Permalink to this headline">Â¶</a></h2>
<p>The workflow for using SPARK depends not only on the chosen <a class="reference internal" href="#objectives-of-using-spark"><span class="std std-ref">Objectives of Using SPARK</span></a>, but also on the context in which SPARK is used: Is it for a
new development? Or an evolution of an existing codebase? Is the existing
codebase in Ada or in a version of SPARK prior to SPARK 2014? We examine all
these project scenarios in this section.</p>
<div class="section" id="maintenance-and-evolution-of-existing-ada-software">
<span id="id17"></span><h3>8.2.1. Maintenance and Evolution of Existing Ada Software<a class="headerlink" href="#maintenance-and-evolution-of-existing-ada-software" title="Permalink to this headline">Â¶</a></h3>
<p>Although SPARK is a large subset of Ada, it contains a number of
<a class="reference internal" href="source/language_restrictions.html#language-restrictions"><span class="std std-ref">Language Restrictions</span></a> which prevent in general direct application of
GNATprove to an existing Ada codebase without any modifications. The
suggested workflow is to:</p>
<ol class="arabic simple">
<li>Identify violations of SPARK restrictions.</li>
<li>For each violation, either rewrite the code in SPARK or mark it
<code class="docutils literal"><span class="pre">SPARK_Mode</span> <span class="pre">=&gt;</span> <span class="pre">Off</span></code> (see section on <a class="reference internal" href="spark_mode.html#identifying-spark-code"><span class="std std-ref">Identifying SPARK Code</span></a>).</li>
<li>Perform the required analyses to achieve the desired objectives (see section
on <a class="reference internal" href="gnatprove.html#formal-verification-with-gnatprove"><span class="std std-ref">Formal Verification with GNATprove</span></a>), a process which likely
involved writing contracts (see in particular section on <a class="reference internal" href="source/how_to_write_subprogram_contracts.html#how-to-write-subprogram-contracts"><span class="std std-ref">How to Write Subprogram Contracts</span></a>).</li>
<li>Make sure that the assumptions made for formal verification are justified at
the boundary between SPARK and full Ada code (see section on
<a class="reference internal" href="source/how_to_use_gnatprove_in_a_team.html#managing-assumptions"><span class="std std-ref">Managing Assumptions</span></a>).</li>
</ol>
<div class="section" id="identifying-violations-of-spark-restrictions">
<h4>8.2.1.1. Identifying Violations of SPARK Restrictions<a class="headerlink" href="#identifying-violations-of-spark-restrictions" title="Permalink to this headline">Â¶</a></h4>
<p>A simple way to identify violations of SPARK restrictions is by <a class="reference internal" href="spark_mode.html#setting-the-default-spark-mode"><span class="std std-ref">Setting the Default SPARK_Mode</span></a> to <code class="docutils literal"><span class="pre">SPARK_Mode</span> <span class="pre">=&gt;</span> <span class="pre">On</span></code>, and then running GNATprove
either in <code class="docutils literal"><span class="pre">check</span></code> mode (to report basic violations) or in <code class="docutils literal"><span class="pre">flow</span></code> mode (to
report violations whose detection requires flow analysis).</p>
<p>If only a subset of the project files should be analyzed, one should create a
project file for <a class="reference internal" href="spark_mode.html#specifying-files-to-analyze"><span class="std std-ref">Specifying Files To Analyze</span></a> or <a class="reference internal" href="spark_mode.html#excluding-files-from-analysis"><span class="std std-ref">Excluding Files From Analysis</span></a>.</p>
<p>Finally, one may prefer to work her way through the project one unit at a time
by <a class="reference internal" href="spark_mode.html#using-spark-mode-in-code"><span class="std std-ref">Using SPARK_Mode in Code</span></a>, and running GNATprove on the current unit
only.</p>
</div>
<div class="section" id="rewriting-the-code-in-spark">
<h4>8.2.1.2. Rewriting the Code in SPARK<a class="headerlink" href="#rewriting-the-code-in-spark" title="Permalink to this headline">Â¶</a></h4>
<p>Depending on the violation, it may be more or less easy to rewrite the code in
SPARK:</p>
<ul class="simple">
<li>Access types should in general be rewritten as private types of a package
whose public part is marked <code class="docutils literal"><span class="pre">SPARK_Mode</span> <span class="pre">=&gt;</span> <span class="pre">On</span></code> and whose private part is
marked <code class="docutils literal"><span class="pre">SPARK_Mode</span> <span class="pre">=&gt;</span> <span class="pre">Off</span></code>. Thus, the body of that package cannot be
analyzed by GNATprove, but clients of the package can be analyzed.</li>
<li>Functions with side-effects should be rewritten as procedures, by adding an
additional out parameter for the result of the function.</li>
<li>Aliasing should be either explicitly signed off by <a class="reference internal" href="source/how_to_use_gnatprove_in_a_team.html#justifying-check-messages"><span class="std std-ref">Justifying Check Messages</span></a> or removed by introducing a copy of the object to pass as argument
to the call.</li>
<li>Goto statements should be rewritten into regular control and looping
structures when possible.</li>
<li>Controlled types cannot be rewritten easily.</li>
<li>Top-level exception handlers can be moved to a wrapper subprogram, which
calls the subprogram without handlers and handles the exceptions which may be
raised. The callee subprogram (and any callers) can thus be analyzed by
GNATprove, while the body of the wrapper subprogram is marked <code class="docutils literal"><span class="pre">SPARK_Mode</span>
<span class="pre">=&gt;</span> <span class="pre">Off</span></code>. The same result can be obtained for exception handlers not at
top-level by first refactoring the corresponding block into a subprogram.</li>
</ul>
</div>
<div class="section" id="using-spark-mode-to-select-or-exclude-code">
<span id="id18"></span><h4>8.2.1.3. Using <code class="docutils literal"><span class="pre">SPARK_Mode</span></code> to Select or Exclude Code<a class="headerlink" href="#using-spark-mode-to-select-or-exclude-code" title="Permalink to this headline">Â¶</a></h4>
<p>Depending on the number and location of remaining violations, <code class="docutils literal"><span class="pre">SPARK_Mode</span></code>
can be used in different ways:</p>
<ul class="simple">
<li>If most of the codebase is in SPARK, <a class="reference internal" href="spark_mode.html#setting-the-default-spark-mode"><span class="std std-ref">Setting the Default SPARK_Mode</span></a>
to <code class="docutils literal"><span class="pre">SPARK_Mode</span> <span class="pre">=&gt;</span> <span class="pre">On</span></code> is best. Violations should be isolated in parts of
the code marked <code class="docutils literal"><span class="pre">SPARK_Mode</span> <span class="pre">=&gt;</span> <span class="pre">Off</span></code> by either <a class="reference internal" href="spark_mode.html#excluding-selected-unit-bodies"><span class="std std-ref">Excluding Selected Unit Bodies</span></a> or <a class="reference internal" href="spark_mode.html#excluding-selected-parts-of-a-unit"><span class="std std-ref">Excluding Selected Parts of a Unit</span></a>.</li>
<li>Otherwise, <code class="docutils literal"><span class="pre">SPARK_Mode</span> <span class="pre">=&gt;</span> <span class="pre">On</span></code> should be applied selectively for
<a class="reference internal" href="spark_mode.html#verifying-selected-subprograms"><span class="std std-ref">Verifying Selected Subprograms</span></a> or <a class="reference internal" href="spark_mode.html#verifying-selected-units"><span class="std std-ref">Verifying Selected Units</span></a>. Violations are allowed outside the parts of the code marked
<code class="docutils literal"><span class="pre">SPARK_Mode</span> <span class="pre">=&gt;</span> <span class="pre">On</span></code>.</li>
<li>Even when most of the code is in SPARK, it may be more cost effective to
apply <code class="docutils literal"><span class="pre">SPARK_Mode</span> <span class="pre">=&gt;</span> <span class="pre">On</span></code> selectively rather than by default. This is the
case in particular when some units have non-SPARK declarations in the
public part of their package spec (for example access type
definitions). Rewriting the code of these units to isolate the non-SPARK
declarations in a part that can be marked <code class="docutils literal"><span class="pre">SPARK_Mode</span> <span class="pre">=&gt;</span> <span class="pre">Off</span></code> may be more
costly than specifying no <code class="docutils literal"><span class="pre">SPARK_Mode</span></code> for these units, which allows
SPARK code elsewhere in the program to refer to the SPARK entities in
these units.</li>
</ul>
<p>When analyzing a unit for the first time, it may help to gradually mark the
code <code class="docutils literal"><span class="pre">SPARK_Mode</span> <span class="pre">=&gt;</span> <span class="pre">On</span></code>:</p>
<ol class="arabic simple">
<li>Start with the unit spec marked <code class="docutils literal"><span class="pre">SPARK_Mode</span> <span class="pre">=&gt;</span> <span class="pre">On</span></code> and the unit body
marked <code class="docutils literal"><span class="pre">SPARK_Mode</span> <span class="pre">=&gt;</span> <span class="pre">Off</span></code>. First run GNATprove in <code class="docutils literal"><span class="pre">flow</span></code> mode, then
in <code class="docutils literal"><span class="pre">proof</span></code> mode, until all errors are resolved (some unproved checks may
remain, as errors and checks are different <a class="reference internal" href="source/how_to_view_gnatprove_output.html#categories-of-messages"><span class="std std-ref">Categories of Messages</span></a>).</li>
<li>Continue with the both the unit spec and body marked <code class="docutils literal"><span class="pre">SPARK_Mode</span> <span class="pre">=&gt;</span>
<span class="pre">On</span></code>. First run GNATprove in <code class="docutils literal"><span class="pre">flow</span></code> mode, then in <code class="docutils literal"><span class="pre">proof</span></code> mode, until
all errors are resolved.</li>
<li>Now that GNATprove can analyze the unit without any errors, continue with
whatever analysis is required to achieve the desired objectives.</li>
</ol>
</div>
</div>
<div class="section" id="new-developments-in-spark">
<span id="id19"></span><h3>8.2.2. New Developments in SPARK<a class="headerlink" href="#new-developments-in-spark" title="Permalink to this headline">Â¶</a></h3>
<p>In this scenario, a significant part of a software (possibly a module, possibly
the whole software) is developed in SPARK. Typically, SPARK is used for the
most critical parts of the software, with less critical parts programmed in
Ada, C or Java (for example the graphical interface). A typical development
process for this scenario might be:</p>
<ol class="arabic simple">
<li>Produce the high level (architectural) design in terms of package
specifications. Determine which packages will be in SPARK, to be marked
<code class="docutils literal"><span class="pre">SPARK_Mode</span> <span class="pre">=&gt;</span> <span class="pre">On</span></code>.</li>
<li>Alternatively, if the majority of packages are to be SPARK, <a class="reference internal" href="spark_mode.html#setting-the-default-spark-mode"><span class="std std-ref">Setting the Default SPARK_Mode</span></a> to <code class="docutils literal"><span class="pre">SPARK_Mode</span> <span class="pre">=&gt;</span> <span class="pre">On</span></code> is best. Those few units
that are not SPARK should be marked <code class="docutils literal"><span class="pre">SPARK_Mode</span> <span class="pre">=&gt;</span> <span class="pre">Off</span></code>.</li>
<li>Add <a class="reference internal" href="source/package_contracts.html#package-contracts"><span class="std std-ref">Package Contracts</span></a> to SPARK packages and, depending on the
desired objectives, add relevant <a class="reference internal" href="source/subprogram_contracts.html#subprogram-contracts"><span class="std std-ref">Subprogram Contracts</span></a> to the
subprograms declared in these packages. The package contracts should
identify the key elements of <a class="reference internal" href="source/package_contracts.html#state-abstraction"><span class="std std-ref">State Abstraction</span></a> which might also be
referred to in <a class="reference internal" href="source/subprogram_contracts.html#data-dependencies"><span class="std std-ref">Data Dependencies</span></a> and <a class="reference internal" href="source/subprogram_contracts.html#flow-dependencies"><span class="std std-ref">Flow Dependencies</span></a>.</li>
<li>Begin implementing the package bodies. One typical method of doing this is
to use a process of top-down decomposition, starting with a top-level
subprogram specification and implementing the body by breaking it down into
further (nested) subprograms which are themselves specified but not yet
implemented, and to iterate until a level is reached where it is appropriate
to start writing executable code. However the exact process is not mandated
and will depend on other factors such as the design methodology being
employed. Provided unimplemented subprograms are stubbed (that is, they are
given dummy bodies), GNATprove can be used at any point to analyze the
program.</li>
<li>As each subprogram is implemented, GNATprove can be used (in mode <code class="docutils literal"><span class="pre">flow</span></code>
or <code class="docutils literal"><span class="pre">proof</span></code> depending on the objectives) to verify it (against its
contract, and/or to show absence of run-time errors).</li>
</ol>
</div>
<div class="section" id="conversion-of-existing-spark-software-to-spark-2014">
<span id="id20"></span><h3>8.2.3. Conversion of Existing SPARK Software to SPARK 2014<a class="headerlink" href="#conversion-of-existing-spark-software-to-spark-2014" title="Permalink to this headline">Â¶</a></h3>
<p>If an existing piece of software has been developed in a previous version of
SPARK and is still undergoing active development/maintenance then it may be
advantageous to upgrade to using SPARK 2014 in order to make use of the larger
language subset and the new tools and environment. This requires more efforts
than previous upgrades between versions of SPARK (SPARK 83, SPARK 95 and
SPARK 2005) because the new version SPARK 2014 of SPARK is incompatible with
those previous versions of the language. While the programming language itself
in those previous versions of SPARK is a strict subset of SPARK 2014, the
contracts and assertions in previous versions of SPARK are expressed as
stylized comments that are ignored by GNATprove. Instead, those contracts and
assertions should be expressed as executable Ada constructs, as presented in
the <a class="reference internal" href="spark_2014.html#overview-of-spark-language"><span class="std std-ref">Overview of SPARK Language</span></a>.</p>
<p>The SPARK Language Reference Manual has an appendix containing a <cite>SPARK 2005
to SPARK 2014 Mapping Specification</cite> which can be used to guide the conversion
process. Various options can be considered for the conversion process:</p>
<ol class="arabic">
<li><p class="first"><cite>Only convert annotations into contracts and assertions, with minimal
changes to the executable code</cite> - Note that some changes to the code may be
required when converting annotations, for example adding with-clauses in a
unit to give visibility over entities used in contracts in this unit but
defined in another units (which was performed in previous versions of
SPARK with <code class="docutils literal"><span class="pre">inherit</span></code> annotations). This conversion should be relatively
straightforward by following the mapping of features between the two
languages.</p>
<p>The SPARK tools should be used to analyze the work in progress throughout
the conversion process (which implies that a bottom-up approach may work
best) and any errors corrected as they are found. This may also be an
occasion to dramatically simplify annotations, as GNATprove requires far
fewer of them. See the description of the conversion of SPARKSkein program
in the section about <a class="reference internal" href="source/examples_in_the_toolset_distribution.html#examples-in-the-toolset-distribution"><span class="std std-ref">Examples in the Toolset Distribution</span></a>, for which
a majority of the annotations are not needed anymore.</p>
<p>Once the conversion is complete, development and maintenance can continue in
SPARK.</p>
</li>
<li><p class="first"><cite>In addition to converting annotations, benefit from the larger language and
more powerful tools to simplify code and contracts</cite> - SPARK 2014 is far less
constraining than previous versions of SPARK in terms of dependencies
between units (which can form a graph instead of a tree), control structures
(for example arbitrary return statements and exit statements are allowed),
data structures (for example scalar types with dynamic bounds are allowed),
expressions (for example local variables can be initialized with non-static
expressions at declaration). In addition, useful new language constructs are
available:</p>
<ul class="simple">
<li><a class="reference internal" href="source/subprogram_contracts.html#contract-cases"><span class="std std-ref">Contract Cases</span></a> can be used to replace complex postconditions with
implications.</li>
<li><a class="reference internal" href="source/type_contracts.html#predicates"><span class="std std-ref">Predicates</span></a> can be used to state invariant properties of subtypes, so
that they need not be repeated in preconditions, postconditions, loop
invariants, etc.</li>
<li><a class="reference internal" href="source/specification_features.html#expression-functions"><span class="std std-ref">Expression Functions</span></a> can be used to replace simple query functions
and their postcondition.</li>
<li><a class="reference internal" href="source/specification_features.html#ghost-code"><span class="std std-ref">Ghost Code</span></a> can be used to mark code only used for verification.</li>
<li><a class="reference internal" href="source/assertion_pragmas.html#loop-variants"><span class="std std-ref">Loop Variants</span></a> can be used to prove the termination of loops.</li>
</ul>
<p>Changing the code to use these new features may favor readability and
maintenance. These changes can be performed either while converting
annotations, or as a second stage after all annotations have been converted
(the case discussed above). Like in the previous case, the SPARK tools
should be used to analyze the work in progress throughout the conversion
process (which implies that a bottom-up approach may work best) and any
errors corrected as they are found. Once the conversion is complete,
development and maintenance can continue in SPARK.</p>
</li>
<li><p class="first"><cite>Gradually convert annotations and code</cite> - It is possible to keep
annotations in comments for the previous versions of SPARK while gradually
adding contracts and assertions in SPARK 2014. The latest version of the
SPARK 2005 toolset facilitates this gradual migration by ignoring SPARK
pragmas. Thus, new contracts (for example <a class="reference internal" href="source/subprogram_contracts.html#preconditions"><span class="std std-ref">Preconditions</span></a> and
<a class="reference internal" href="source/subprogram_contracts.html#postconditions"><span class="std std-ref">Postconditions</span></a>) should be expressed as pragmas rather than aspects in
that case.</p>
<p>Typically, annotations and code would be converted when it needs to be
changed. The granularity of how much code needs to be converted when a
module is touched should be considered, and is likely to be at the level of
the whole package.</p>
<p>The latest version of the SPARK 2005 toolset can be used to continue
analyzing the parts of the program that do not use the new features of SPARK
2014, including units which have the two versions of contracts in
parallel. GNATprove can be used to analyze parts of the program that have
contracts in SPARK 2014 syntax, including units which have the two versions
of contracts in parallel.</p>
</li>
</ol>
<p>Note that some users may wish to take advantage of the new SPARK contracts
and tools whilst retaining the more restrictive nature of SPARK 2005. (Many of
the restrictions from SPARK 2005 have been lifted in SPARK because
improvements in the tools mean that sound analysis can be performed without
them, but some projects may need to operate in a more constrained environment.)
This can be achieved using <code class="docutils literal"><span class="pre">pragma</span> <span class="pre">Restrictions</span> <span class="pre">(SPARK_05)</span></code>. For further
details of this restriction please see the GNAT Reference Manual.</p>
</div>
<div class="section" id="analysis-of-frozen-ada-software">
<span id="id21"></span><h3>8.2.4. Analysis of Frozen Ada Software<a class="headerlink" href="#analysis-of-frozen-ada-software" title="Permalink to this headline">Â¶</a></h3>
<p>In some very specific cases, users may be interested in the results of
GNATprove&#8216;s analysis on an unmodified code. This may be the case for example
if the only objective is to <a class="reference internal" href="#ensure-portability-of-programs"><span class="std std-ref">Ensure Portability of Programs</span></a> for existing
Ada programs that cannot be modified (due to some certification or legal
constraints).</p>
<p>In such a case, the suggested workflow is very similar to the one described for
<a class="reference internal" href="#maintenance-and-evolution-of-existing-ada-software"><span class="std std-ref">Maintenance and Evolution of Existing Ada Software</span></a>, except the code
cannot be rewritten when a violation of SPARK restrictions is encountered,
and instead that part of the code should be marked <code class="docutils literal"><span class="pre">SPARK_Mode</span> <span class="pre">=&gt;</span> <span class="pre">Off</span></code>. To
minimize the parts of the code that need to be marked <code class="docutils literal"><span class="pre">SPARK_Mode</span> <span class="pre">=&gt;</span> <span class="pre">Off</span></code>, it
is in general preferable to apply <code class="docutils literal"><span class="pre">SPARK_Mode</span> <span class="pre">=&gt;</span> <span class="pre">On</span></code> selectively rather than
by default, so that units that have non-SPARK declarations in the public part
of their package spec (for example access type definitions) need not be marked
<code class="docutils literal"><span class="pre">SPARK_Mode</span> <span class="pre">=&gt;</span> <span class="pre">Off</span></code>. See <a class="reference internal" href="#using-spark-mode-to-select-or-exclude-code"><span class="std std-ref">Using SPARK_Mode to Select or Exclude Code</span></a>
for details.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="appendix/command_line_invocation.html" title="Command Line Invocation"
             >next</a> |</li>
        <li class="right" >
          <a href="source/examples_in_the_toolset_distribution.html" title="7.10. Examples in the Toolset Distribution"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">SPARK 2014 User&#39;s Guide 2019</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2011-2019, AdaCore and Altran UK Ltd.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.2.
    </div>
  </body>
</html>